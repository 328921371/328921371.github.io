<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈先生的小前端</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.chensheng.group/"/>
  <updated>2021-11-02T13:42:26.344Z</updated>
  <id>https://www.chensheng.group/</id>
  
  <author>
    <name>陈晟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动端点击延迟问题</title>
    <link href="https://www.chensheng.group/2021/11/02/155-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/"/>
    <id>https://www.chensheng.group/2021/11/02/155-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/</id>
    <published>2021-11-02T13:39:00.000Z</published>
    <updated>2021-11-02T13:42:26.344Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>本来是放在js面试题里面的,但是内容太多了,所以还是再分出来单独讲</p></blockquote><a id="more"></a><blockquote><p>移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</p></blockquote><p>怎么处理呢?</p><ul><li><p>通过 meta 标签禁用网页的缩放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;user-scalable&#x3D;no&quot;&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;initial-scale&#x3D;1,maximum-scale&#x3D;1&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>通过 meta 标签将网页的 viewport 设置为 ideal viewport。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这个方案相比上一个的好处在于，它没有完全禁用缩放，而只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面。</p></blockquote><ul><li>CSS touch-action</li></ul><p>touch-action这个CSS属性。这个属性指定了相应元素上能够触发的用户代理（也就是浏览器）的默认行为。</p><p>如果将该属性值设置为touch-action: none，那么表示在该元素上的操作不会触发用户代理的任何默认行为，就无需进行300ms的延迟判断。</p><ul><li>调用一些 js 库，比如 FastClick</li></ul><h3 id="点击穿透问题"><a href="#点击穿透问题" class="headerlink" title="点击穿透问题"></a>点击穿透问题</h3><p>说完移动端点击300ms延迟的问题，还不得不提一下移动端点击穿透的问题。可能有人会想，既然click点击有300ms的延迟，那对于触摸屏，我们直接监听touchstart事件不就好了吗？</p><p>使用touchstart去代替click事件有两个不好的地方。</p><p>第一：touchstart是手指触摸屏幕就触发，有时候用户只是想滑动屏幕，却触发了touchstart事件，这不是我们想要的结果；<br>第二：使用touchstart事件在某些场景下可能会出现点击穿透的现象。</p><h3 id="什么是点击穿透？"><a href="#什么是点击穿透？" class="headerlink" title="什么是点击穿透？"></a>什么是点击穿透？</h3><p>假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。</p><p>这是因为在移动端浏览器，事件执行的顺序是touchstart &gt; touchend &gt; click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。</p><blockquote><p>浏览器事件触发的顺序 touchstart –&gt; mouseover(有的浏览器没有实现) –&gt; mousemove(一次) –&gt;mousedown –&gt; mouseup –&gt; click –&gt;touchend</p></blockquote><p>说完了,告辞…</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;本来是放在js面试题里面的,但是内容太多了,所以还是再分出来单独讲&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue高频考题</title>
    <link href="https://www.chensheng.group/2021/11/02/154-vue%E6%95%B4%E7%90%86/"/>
    <id>https://www.chensheng.group/2021/11/02/154-vue%E6%95%B4%E7%90%86/</id>
    <published>2021-11-02T12:48:00.000Z</published>
    <updated>2021-11-02T13:34:32.044Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>整理了一下常见的vue的问题</p></blockquote><a id="more"></a><p>vue的问题整理的不太多,一些基础的并没有整理出来</p><h3 id="什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h3><p>阮老师说的就很详细 <a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">戳我戳我</a></p><h3 id="Vue-的各个生命阶段是什么"><a href="#Vue-的各个生命阶段是什么" class="headerlink" title="Vue 的各个生命阶段是什么?"></a>Vue 的各个生命阶段是什么?</h3><p><a href="https://www.chensheng.group/2019/09/13/45-vue-cli%E6%80%BB%E7%BB%93/">戳我跳转搜索生命周期</a></p><h3 id="Vue-组件间的参数传递方式"><a href="#Vue-组件间的参数传递方式" class="headerlink" title="Vue 组件间的参数传递方式"></a>Vue 组件间的参数传递方式</h3><p>普通的组件传值可以去我其他的博客搜一下,这里重点说一下 多个子组件嵌套</p><p>使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</p><h3 id="computed-和-watch-的差异"><a href="#computed-和-watch-的差异" class="headerlink" title="computed 和 watch 的差异"></a>computed 和 watch 的差异</h3><ol><li><p>computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。</p></li><li><p>computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。</p></li><li><p>从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。</p></li></ol><h3 id="v-model的实现原理以及如何自定义v-model"><a href="#v-model的实现原理以及如何自定义v-model" class="headerlink" title="v-model的实现原理以及如何自定义v-model"></a>v-model的实现原理以及如何自定义v-model</h3><p><a href="https://www.chensheng.group/2019/10/09/104-Vue随笔记录/">戳我跳转</a></p><h3 id="vue响应式数据原理？"><a href="#vue响应式数据原理？" class="headerlink" title="vue响应式数据原理？"></a>vue响应式数据原理？</h3><p><a href="https://www.chensheng.group/2020/05/31/127-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/">戳我跳转</a></p><h3 id="什么是-Virtual-DOM？如何比较两个-DOM-树的差异？"><a href="#什么是-Virtual-DOM？如何比较两个-DOM-树的差异？" class="headerlink" title="什么是 Virtual DOM？如何比较两个 DOM 树的差异？"></a>什么是 Virtual DOM？如何比较两个 DOM 树的差异？</h3><p><a href="https://www.chensheng.group/2021/02/11/138-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-diff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/">戳我跳转</a></p><h3 id="vue-中-key-值的作用？"><a href="#vue-中-key-值的作用？" class="headerlink" title="vue 中 key 值的作用？"></a>vue 中 key 值的作用？</h3><p>vue 中 key 值的作用可以分为两种情况来考虑。</p><p>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而<br>不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类<br>型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不<br>会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个<br>情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</p><p>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地<br>复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，<br>而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元<br>素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</p><h3 id="没有整理的题目"><a href="#没有整理的题目" class="headerlink" title="没有整理的题目"></a>没有整理的题目</h3><ul><li>Vue中如何检测数组变化</li><li>为何Vue采用异步处理</li><li>nextTick的实现原理</li><li>Vue中v-html会导致哪些问题</li><li>组件中的data为什么是一个函数</li><li>Vue中常见性能优化</li><li>keep-alive的了解</li><li>如何实现hash路由和history路由</li></ul><p>(未完待续…)</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;整理了一下常见的vue的问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://www.chensheng.group/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://www.chensheng.group/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>js高频考题</title>
    <link href="https://www.chensheng.group/2021/11/02/153-js%E6%95%B4%E7%90%86/"/>
    <id>https://www.chensheng.group/2021/11/02/153-js%E6%95%B4%E7%90%86/</id>
    <published>2021-11-02T12:46:00.000Z</published>
    <updated>2021-11-02T14:05:22.201Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>整理了一下常见的js的问题</p></blockquote><a id="more"></a><h2 id="1-10"><a href="#1-10" class="headerlink" title="1~10"></a>1~10</h2><h3 id="JavaScript-有几种类型的值-你能简单说一下他们的区别吗"><a href="#JavaScript-有几种类型的值-你能简单说一下他们的区别吗" class="headerlink" title="JavaScript 有几种类型的值? 你能简单说一下他们的区别吗?"></a>JavaScript 有几种类型的值? 你能简单说一下他们的区别吗?</h3><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。</p><h3 id="JavaScript-原型，原型链-有什么特点"><a href="#JavaScript-原型，原型链-有什么特点" class="headerlink" title="JavaScript 原型，原型链? 有什么特点?"></a>JavaScript 原型，原型链? 有什么特点?</h3><p><a href="https://www.chensheng.group/2016/09/20/04-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/">戳我跳转</a></p><h3 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h3><ul><li>p.<strong>proto</strong></li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h3 id="在-js-中不同进制数字的表示方式"><a href="#在-js-中不同进制数字的表示方式" class="headerlink" title="在 js 中不同进制数字的表示方式"></a>在 js 中不同进制数字的表示方式</h3><ul><li>以 0X、0x 开头的表示为十六进制。</li><li>以 0、0O、0o 开头的表示为八进制。</li><li>以 0B、0b 开头的表示为二进制格式。</li></ul><h3 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h3><p>NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><p>typeof NaN; // “number”</p><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN 为 true。</p><h3 id="javascript-创建对象的几种方式？"><a href="#javascript-创建对象的几种方式？" class="headerlink" title="javascript 创建对象的几种方式？"></a>javascript 创建对象的几种方式？</h3><p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。</p><ul><li>工厂模式</li></ul><p>工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><ul><li>构造函数模式</li></ul><p>只要一个函数是通过 new来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。</p><blockquote><p>构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型</p></blockquote><ul><li>原型模式</li></ul><p>因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用</p><h3 id="JavaScript-继承的几种实现方式"><a href="#JavaScript-继承的几种实现方式" class="headerlink" title="JavaScript 继承的几种实现方式"></a>JavaScript 继承的几种实现方式</h3><p><a href="https://www.chensheng.group/2016/09/15/03-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/">戳我跳转</a></p><h3 id="谈谈-This-对象的理解。什么是闭包-说一下闭包。"><a href="#谈谈-This-对象的理解。什么是闭包-说一下闭包。" class="headerlink" title="谈谈 This 对象的理解。什么是闭包,说一下闭包。"></a>谈谈 This 对象的理解。什么是闭包,说一下闭包。</h3><p><a href="https://www.chensheng.group/2016/09/24/05-This%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%E4%B8%8E%E9%97%AD%E5%8C%85/">戳我跳转</a></p><h3 id="“1”-“2”-“3”-map-parseInt-答案是多少"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少?"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少?</h3><p>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (string, radix)</p><p>其中radix 表示要解析的数字的基数。(该值介于 2 ~ 36 之间)</p><blockquote><p>如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</p></blockquote><p>由于map传参默认有三个(currentValue, index, arr)</p><p>所以传入到parseInt中去之后,就变成了下面这样了,后面的0,1,2 对应的就是index索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#39;1&#39;, 0);</span><br><span class="line">parseInt(&#39;2&#39;, 1);</span><br><span class="line">parseInt(&#39;3&#39;, 2);</span><br></pre></td></tr></table></figure><blockquote><p>当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p></blockquote><p>所以答案是 [1, NaN, NaN]</p><h3 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h3><ol><li>使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li><li>可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li><li>如果需要判断的是某个内置的引用类型的话，可以使用Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li></ol><h2 id="11-20"><a href="#11-20" class="headerlink" title="11~20"></a>11~20</h2><h3 id="new-操作符具体干了什么呢？如何实现？"><a href="#new-操作符具体干了什么呢？如何实现？" class="headerlink" title="new 操作符具体干了什么呢？如何实现？"></a>new 操作符具体干了什么呢？如何实现？</h3><p><a href="https://www.chensheng.group/2019/10/10/106-JS%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E5%88%86%E4%BA%AB/">戳我跳转</a></p><h3 id="一行代码学习js"><a href="#一行代码学习js" class="headerlink" title="一行代码学习js"></a>一行代码学习js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline&#x3D;&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</span><br></pre></td></tr></table></figure><p>解释一下上面这段代码的意思</p><ol><li>选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。</li><li>循环遍历 DOM 元素</li><li>给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加outline 并不会影响元素的大小和页面的布局。</li><li>生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</li></ol><h3 id="如何创建一个-Ajax"><a href="#如何创建一个-Ajax" class="headerlink" title="如何创建一个 Ajax"></a>如何创建一个 Ajax</h3><ol><li>创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li><li>创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li><li>设置响应 HTTP 请求状态变化的函数</li><li>发送 HTTP 请求</li><li>获取异步调用返回的数据</li><li>使用 JavaScript 和 DOM 实现局部刷新</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">const SERVER_URL &#x3D; &quot;&#x2F;server&quot;;</span><br><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">&#x2F;&#x2F; 创建 Http 请求 </span><br><span class="line">xhr.open(&quot;GET&quot;, SERVER_URL, true);</span><br><span class="line">&#x2F;&#x2F; 设置状态监听函数 </span><br><span class="line">xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">  if (this.readyState !&#x3D;&#x3D; 4) return;</span><br><span class="line">  &#x2F;&#x2F; 当请求成功时</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    handle(this.response);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.error(this.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 设置请求失败时的监听函数 </span><br><span class="line">xhr.onerror &#x3D; function() &#123;</span><br><span class="line">  console.error(this.statusText);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 设置请求头信息 </span><br><span class="line">xhr.responseType &#x3D; &quot;json&quot;;</span><br><span class="line">xhr.setRequestHeader(&quot;Accept&quot;, &quot;application&#x2F;json&quot;);</span><br><span class="line">&#x2F;&#x2F; 发送 Http 请求 </span><br><span class="line">xhr.send(null);</span><br><span class="line">&#x2F;&#x2F; promise 封装实现：</span><br><span class="line">function getJSON(url) &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建一个 promise 对象</span><br><span class="line">  let promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    &#x2F;&#x2F; 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">    &#x2F;&#x2F; 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">      if (this.readyState !&#x3D;&#x3D; 4) return;</span><br><span class="line">      &#x2F;&#x2F; 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 设置错误监听函数</span><br><span class="line">    xhr.onerror &#x3D; function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 设置响应的数据类型</span><br><span class="line">    xhr.responseType &#x3D; &quot;json&quot;;</span><br><span class="line">    &#x2F;&#x2F; 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application&#x2F;json&quot;);</span><br><span class="line">    &#x2F;&#x2F; 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JS事件循环机制"><a href="#JS事件循环机制" class="headerlink" title="JS事件循环机制"></a>JS事件循环机制</h3><p><a href="https://www.chensheng.group/2020/07/04/133-JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">戳我跳转</a></p><h3 id="什么是浏览器的同源政策？如何解决跨域问题？"><a href="#什么是浏览器的同源政策？如何解决跨域问题？" class="headerlink" title="什么是浏览器的同源政策？如何解决跨域问题？"></a>什么是浏览器的同源政策？如何解决跨域问题？</h3><p><a href="https://www.chensheng.group/2018/01/19/49-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">戳我跳转</a></p><p><a href="https://www.chensheng.group/2018/10/10/63-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%B7%B1%E5%85%A5/">戳我跳转</a></p><h3 id="简单介绍几种模块规范"><a href="#简单介绍几种模块规范" class="headerlink" title="简单介绍几种模块规范"></a>简单介绍几种模块规范</h3><ul><li>CommonJS 方案</li></ul><p>它通过 require 来引入模块，通过 module.exports 定义模块的输出接口</p><ul><li>AMD 方案</li></ul><p>采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p><ul><li>CMD 方案</li></ul><p>这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</p><ul><li>ES6 模块化</li></ul><p>使用 import 和 export 的形式来导入导出模块。</p><h3 id="AMD-和-CMD-规范的区别？"><a href="#AMD-和-CMD-规范的区别？" class="headerlink" title="AMD 和 CMD 规范的区别？"></a>AMD 和 CMD 规范的区别？</h3><ul><li>在模块定义时对依赖的处理不同</li></ul><p>AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。<br>CMD 推崇 就近依赖，只有在用到某个模块的时候再去 require。</p><ul><li>对依赖模块的执行时机处理不同。</li></ul><p>首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机</p><p>AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致<br>CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p><h3 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><ul><li><p>创建新节点</p><ul><li>createDocumentFragment(node);</li><li>createElement(node);</li><li>createTextNode(text);</li></ul></li><li><p>添加、移除、替换、插入</p><ul><li>appendChild(node)</li><li>removeChild(node)</li><li>replaceChild(new,old)</li><li>insertBefore(new,old)</li></ul></li><li><p>查找</p><ul><li>getElementById();</li><li>getElementsByName();</li><li>getElementsByTagName();</li><li>getElementsByClassName();</li><li>querySelector();</li><li>querySelectorAll();</li></ul></li><li><p>属性操作</p><ul><li>getAttribute(key);</li><li>setAttribute(key,value);</li><li>hasAttribute(key);</li><li>removeAttribute(key);</li></ul></li></ul><h3 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title=".call() 和 .apply() 的区别？"></a>.call() 和 .apply() 的区别？</h3><p><a href="https://www.chensheng.group/2016/09/15/03-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/">戳我跳转</a></p><h3 id="的长度？"><a href="#的长度？" class="headerlink" title="[,,,] 的长度？"></a>[,,,] 的长度？</h3><p>尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</p><p>如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数量。</p><h2 id="21-30"><a href="#21-30" class="headerlink" title="21~30"></a>21~30</h2><h3 id="JavaScript-中的作用域与变量声明提升？"><a href="#JavaScript-中的作用域与变量声明提升？" class="headerlink" title=". JavaScript 中的作用域与变量声明提升？"></a>. JavaScript 中的作用域与变量声明提升？</h3><p><a href="https://www.chensheng.group/2018/12/04/69-ES6%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/">戳我跳转</a></p><h3 id="深入理解垃圾回收原理"><a href="#深入理解垃圾回收原理" class="headerlink" title="深入理解垃圾回收原理"></a>深入理解垃圾回收原理</h3><p><a href="https://www.chensheng.group/2021/08/30/142-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86/">戳我跳转</a></p><h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p><a href="https://www.chensheng.group/2019/10/10/106-JS%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E5%88%86%E4%BA%AB/">戳我跳转</a></p><h3 id="移动端为什么会有点击延迟，怎么解决"><a href="#移动端为什么会有点击延迟，怎么解决" class="headerlink" title="移动端为什么会有点击延迟，怎么解决"></a>移动端为什么会有点击延迟，怎么解决</h3><p><a href="https://www.chensheng.group/2021/11/02/155-点击穿透/">戳我跳转</a></p><h3 id="使用-JS-实现获取文件扩展名？"><a href="#使用-JS-实现获取文件扩展名？" class="headerlink" title="使用 JS 实现获取文件扩展名？"></a>使用 JS 实现获取文件扩展名？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; String.lastIndexOf() 方法返回指定值（本例中的&#39;.&#39;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对于 &#39;filename&#39; 和 &#39;.hiddenfile&#39; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</span><br><span class="line"></span><br><span class="line">function getFileExtension(filename) &#123;</span><br><span class="line">  return filename.slice(((filename.lastIndexOf(&quot;.&quot;) - 1) &gt;&gt;&gt; 0) + 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="介绍一下-js-的节流与防抖"><a href="#介绍一下-js-的节流与防抖" class="headerlink" title="介绍一下 js 的节流与防抖"></a>介绍一下 js 的节流与防抖</h3><p><a href="https://www.chensheng.group/2021/09/03/147-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">戳我跳转</a></p><h3 id="Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h3><p><a href="https://www.chensheng.group/2019/01/10/77-ES6%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/">戳我跳转</a></p><h3 id="js-的事件循环是什么？"><a href="#js-的事件循环是什么？" class="headerlink" title="js 的事件循环是什么？"></a>js 的事件循环是什么？</h3><p><a href="https://www.chensheng.group/2020/07/04/133-JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">戳我跳转</a></p><h3 id="js-中的深浅拷贝实现？"><a href="#js-中的深浅拷贝实现？" class="headerlink" title="js 中的深浅拷贝实现？"></a>js 中的深浅拷贝实现？</h3><p>浅拷贝的实现;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function shallowCopy(object) &#123;</span><br><span class="line">  &#x2F;&#x2F; 只拷贝对象</span><br><span class="line">  if (!object || typeof object !&#x3D;&#x3D; &quot;object&quot;) return;</span><br><span class="line">    &#x2F;&#x2F; 根据 object 的类型判断是新建一个数组还是对象</span><br><span class="line">    let newObject &#x3D; Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F; 遍历 object，并且判断是 object 的属性才拷贝</span><br><span class="line">    for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] &#x3D; object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深拷贝的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(object) &#123;</span><br><span class="line">  if (!object || typeof object !&#x3D;&#x3D; &quot;object&quot;) return;</span><br><span class="line">  let newObject &#x3D; Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] &#x3D;</span><br><span class="line">      typeof object[key] &#x3D;&#x3D;&#x3D; &quot;object&quot; ? deepCopy(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h3><p><a href="https://www.chensheng.group/2021/11/01/149-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/">戳我戳我</a></p><h2 id="31-40"><a href="#31-40" class="headerlink" title="31~40"></a>31~40</h2><h3 id="为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="为什么 0.1 + 0.2 != 0.3？如何解决这个问题？"></a>为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</h3><p><a href="https://www.chensheng.group/2018/12/12/73-ES6%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/">戳我跳转</a></p><h3 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h3><p><a href="https://www.chensheng.group/2021/11/02/151-前端网络安全/">戳我跳转</a></p><h3 id="offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？"></a>offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</h3><p>clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。<br>clientTop 返回的是上边框的宽度。clientLeft 返回的左边框的宽度。</p><p>offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。<br>offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。</p><p>scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。<br>scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。scrollLeft 属性返回的是元素滚动条到元素左边的距离。</p><h3 id="什么是-Promise-对象"><a href="#什么是-Promise-对象" class="headerlink" title="什么是 Promise 对象?"></a>什么是 Promise 对象?</h3><p><a href="https://www.chensheng.group/2019/02/19/82-ES6%20Promise/">戳我戳我</a></p><h3 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h3><p><a href="https://www.chensheng.group/2021/11/01/150-%E6%89%8B%E5%86%99promise/">戳我戳我</a></p><h3 id="js-设计模式"><a href="#js-设计模式" class="headerlink" title="js 设计模式"></a>js 设计模式</h3><ul><li>单例模式</li></ul><p>单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。</p><ul><li>策略模式</li></ul><p>策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。</p><ul><li>代理模式</li></ul><p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</p><ul><li>中介者模式</li></ul><p>中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</p><ul><li>适配器模式</li></ul><p>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。</p><ul><li>观察者模式</li></ul><p>发布订阅模式其实属于广义上的观察者模式, 在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</p><ul><li>发布订阅模式</li></ul><p>而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦</p><p>更详细的可以看看我朋友的博客<a href="https://www.chenkl.vip/%E5%B8%B8%E8%A7%81%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">戳我跳转</a></p><h3 id="开发中常用的几种-Content-Type-？"><a href="#开发中常用的几种-Content-Type-？" class="headerlink" title="开发中常用的几种 Content-Type ？"></a>开发中常用的几种 Content-Type ？</h3><ul><li>application/x-www-form-urlencoded</li></ul><p>浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以<br>application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，<br>数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p><ul><li>multipart/form-data</li></ul><p>该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p><ul><li>application/json</li></ul><p>告诉服务器消息主体是序列化后的 JSON 字符串。</p><ul><li>text/xml</li></ul><p>该种方式主要用来提交 XML 格式的数据。</p><h3 id="如何封装一个-javascript-的类型判断函数？"><a href="#如何封装一个-javascript-的类型判断函数？" class="headerlink" title="如何封装一个 javascript 的类型判断函数？"></a>如何封装一个 javascript 的类型判断函数？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getType(value) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断数据是 null 的情况</span><br><span class="line">  if (value &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    return value + &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 判断数据是引用类型的情况</span><br><span class="line">  if (typeof value &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class="line">    let valueClass &#x3D; Object.prototype.toString.call(value),</span><br><span class="line">      type &#x3D; valueClass.split(&quot; &quot;)[1].split(&quot;&quot;);</span><br><span class="line">    type.pop();</span><br><span class="line">    return type.join(&quot;&quot;).toLowerCase();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断数据是基本数据类型的情况和函数的情况</span><br><span class="line">    return typeof value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(未完待续…)</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;整理了一下常见的js的问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>uni-app使用echart</title>
    <link href="https://www.chensheng.group/2021/11/02/152-uni-app%E4%BD%BF%E7%94%A8echart/"/>
    <id>https://www.chensheng.group/2021/11/02/152-uni-app%E4%BD%BF%E7%94%A8echart/</id>
    <published>2021-11-02T12:31:00.000Z</published>
    <updated>2021-11-02T12:37:02.819Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>echart我们在web端都使用过很多次了,看看在uni-app的项目中要怎么使用echart</p></blockquote><a id="more"></a><p>uni-app推荐使用uchart,但是个人认为没有echart的功能多,所以还是想要用echart来实现</p><p>一开始的时候,我以为和web端一样,正常的引入进来就可以使用了,打开浏览器调试一下,完美,真机运行发现,一片空白</p><p>百度之后发现,运行的平台不一样,渲染层也不同,所以针对不同的运行环境,需要不同的方法</p><p>上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;view class&#x3D;&quot;trend-box&quot; style&#x3D;&quot;height: 415rpx;&quot;&gt;</span><br><span class="line">      &lt;!-- #ifdef  MP-WEIXIN --&gt;</span><br><span class="line">      &lt;uniEcCanvas class&#x3D;&quot;uni-ec-canvas&quot; :force-use-old-canvas&#x3D;&quot;true&quot; canvas-id&#x3D;&quot;multi-charts-bar&quot; :ec&#x3D;&quot;dealEc&quot;&gt;&lt;&#x2F;uniEcCanvas&gt;</span><br><span class="line">      &lt;!-- #endif --&gt;</span><br><span class="line">      &lt;!-- #ifdef H5||APP-PLUS --&gt;</span><br><span class="line">      &lt;h5echart style&#x3D;&quot;height: 100%&quot; :option&#x3D;&quot;dealEc.option&quot;&gt;&lt;&#x2F;h5echart&gt;</span><br><span class="line">      &lt;!-- #endif --&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt; </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import uniEcCanvas from &#39;@&#x2F;components&#x2F;uni-ec-canvas&#x2F;uni-ec-canvas&#39;</span><br><span class="line">  import h5echart from &#39;@&#x2F;components&#x2F;h5-echart&#x2F;echarts.vue&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">components: &#123;</span><br><span class="line">uniEcCanvas,</span><br><span class="line">      h5echart</span><br><span class="line">&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>用法和echart一样的,需要注意的是,一个入参传入option,一个传入整个数据</p></blockquote><h3 id="ec-canvas"><a href="#ec-canvas" class="headerlink" title="ec-canvas"></a>ec-canvas</h3><p>这个组件是为了适配小程序的</p><p>首先，下载 GitHub 上的 <a href="https://github.com/ecomfe/echarts-for-weixin%5D" target="_blank" rel="noopener">ecomfe/echarts-for-weixin</a> 项目。</p><p>ec-canvas 目录下有一个 echarts.js，可以改成自己需要的。</p><h3 id="h5-echart"><a href="#h5-echart" class="headerlink" title="h5-echart"></a>h5-echart</h3><p>因为APP上没有办法操作dom,所以需要设置 script 节点的 lang 为 renderjs,在视图层操作dom</p><p>大致的用法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script module&#x3D;&quot;echarts&quot; lang&#x3D;&quot;renderjs&quot;&gt;</span><br><span class="line">    let myChart</span><br><span class="line">    export default &#123;</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            if (typeof window.echarts &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                myChart &#x3D; echarts.init(document.getElementById(&#39;echarts&#39;))</span><br><span class="line">                &#x2F;&#x2F; 观测更新的数据在 view 层可以直接访问到</span><br><span class="line">                myChart.setOption(this.option)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 动态引入较大类库避免影响页面展示</span><br><span class="line">                const script &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line">                &#x2F;&#x2F; view 层的页面运行在 www 根目录，其相对路径相对于 www 计算</span><br><span class="line">                script.src &#x3D; &#39;static&#x2F;echarts.js&#39;</span><br><span class="line">                &#x2F;&#x2F;script标签的onload事件都是在外部js文件被加载完成并执行完成后才被触发的</span><br><span class="line">                script.onload &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">                    myChart &#x3D; echarts.init(document.getElementById(&#39;echarts&#39;),)</span><br><span class="line">                    myChart.setOption(this.option)</span><br><span class="line">                &#125;</span><br><span class="line">                document.head.appendChild(script)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这两个插件上百度搜都有,没有找到的,可以去我的网盘上下载</p><p>链接: <a href="https://pan.baidu.com/s/12jNg3Qs53Gl1PcNFGyFUlA" target="_blank" rel="noopener">https://pan.baidu.com/s/12jNg3Qs53Gl1PcNFGyFUlA</a> </p><p>是我对uni-app使用echart的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;echart我们在web端都使用过很多次了,看看在uni-app的项目中要怎么使用echart&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端网络安全</title>
    <link href="https://www.chensheng.group/2021/11/02/151-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>https://www.chensheng.group/2021/11/02/151-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2021-11-02T11:58:00.000Z</published>
    <updated>2021-11-02T12:32:40.734Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>项目都是用的vue的框架,输入框之类的都已经帮我们做了大部分的安全处理,但是还是要了解一下</p></blockquote><a id="more"></a><p><a href="https://www.jianshu.com/p/233874b6de0d" target="_blank" rel="noopener">原文链接</a></p><p>网络安全是前端工程师需要考虑的问题，大多数我们会面对以下几点</p><ul><li>什么是 XSS 攻击？如何防范 XSS 攻击？</li><li>内容安全策略csp</li><li>什么是 CSRF 攻击？如何防范 CSRF 攻击？</li><li>什么是点击劫持？如何防范点击劫持？</li><li>SQL 注入攻击？</li></ul><h3 id="1-XSS"><a href="#1-XSS" class="headerlink" title="1. XSS"></a>1. XSS</h3><p>XSS，Cross-site script，跨站脚本攻击。是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</p><p>它可以分为两类：反射型和持久型。</p><ul><li>反射型XSS攻击场景：用户点击嵌入恶意脚本的链接，攻击者可以获取用户的cookie信息或密码等重要信息，进行恶性操作。</li></ul><blockquote><p>解决：开启cookie的HttpOnly属性，禁止JavaScript脚本读取cookie信息。</p></blockquote><ul><li>持久型XSS攻击场景：攻击者提交含有恶意脚本的请求（通常使用<script>标签），此脚本被保存在数据库中。用户再次浏览页面，包含恶意脚本的页面会自动执行脚本，从而达到攻击效果。这种攻击常见于论坛，博客等应用中。</li></ul><blockquote><p>解决：前端提交请求时，转义<为&lt，转义>为&gt；或者后台存储数据时进行特殊字符转义。</p></blockquote><h3 id="3-CSRF"><a href="#3-CSRF" class="headerlink" title="3.CSRF"></a>3.CSRF</h3><p>CSRF，Cross-site request forgery，跨站请求伪造。这种方式是利用浏览器的cookie或服务器的session策略，盗取用户信息，模拟用户向第三方网站发送恶意请求。</p><blockquote><p>再次强调一下cookie的机制：浏览器向一个域名发起http请求时（GET请求）会带上浏览器保存的关于那个域名的cookies，而不管你从哪个网站发请求。</p></blockquote><p>解决方法: </p><ol><li>同源检测</li></ol><p>既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。可以通过origin header或者referer header判断请求源.</p><ol start="2"><li>CSRF token验证</li></ol><p>提交请求中携带token，并且每次请求的token值都是合法的随机数</p><ol start="3"><li>开启cookie SameSite 强校验</li></ol><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪。</p><h3 id="4-网络请求劫持"><a href="#4-网络请求劫持" class="headerlink" title="4. 网络请求劫持"></a>4. 网络请求劫持</h3><p>请求劫持是指网站资源在请求过程中因为人为原因而没有加载到正确的资源。</p><ul><li>DNS劫持</li></ul><p>在浏览器输入URL，浏览器完成连接准备之后，第一件事情就是DNS查询。如果本地没有缓存，那么需要向DNS服务商请求该域名的IP地址。这个过程中如果发生恶意劫持，都导致正确的网址不能得到正确解析，且用户可能访问了一个非法服务器获取到恶意资源。</p><blockquote><p>解决方案：DNS over HTTP（用 HTTP 协议来传输 DNS ）</p></blockquote><ul><li>HTTP劫持</li></ul><p>在用户浏览器和目标服务器之间建立的网络数据传输通道中的任何环节，比如，网关，防火墙等，发生的恶意劫持。从而在用户浏览器上展示了广告或其他内容（常见插入iframe）。最可能的劫持方就是ISP（internet service provider互联网服务商）。</p><blockquote><p>解决方案: 改为https</p></blockquote><h3 id="5-SQL注入"><a href="#5-SQL注入" class="headerlink" title="5.SQL注入"></a>5.SQL注入</h3><p>攻击者在HTTP请求中注入恶意SQL命令，例如，drop table users，服务器用请求参数构造数据库SQL命令时，恶意SQL被执行。</p><blockquote><p>解决：后台处理，例如，使用预编译语句PreparedStatement进行预处理。</p></blockquote><p>感谢大佬们的无私分享</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;项目都是用的vue的框架,输入框之类的都已经帮我们做了大部分的安全处理,但是还是要了解一下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>手写Promise</title>
    <link href="https://www.chensheng.group/2021/11/01/150-%E6%89%8B%E5%86%99promise/"/>
    <id>https://www.chensheng.group/2021/11/01/150-%E6%89%8B%E5%86%99promise/</id>
    <published>2021-11-01T13:27:00.000Z</published>
    <updated>2021-11-02T12:32:40.732Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>Promise我们都很熟悉了,也都会使用了,如果自己实现一个promise,要怎么做</p></blockquote><a id="more"></a><p>不做解释了,代码里面都有注释,直接上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">const PENDING &#x3D; &quot;pending&quot;;</span><br><span class="line">const RESOLVED &#x3D; &quot;resolved&quot;;</span><br><span class="line">const REJECTED &#x3D; &quot;rejected&quot;;</span><br><span class="line"></span><br><span class="line">function MyPromise(fn) &#123;</span><br><span class="line">  &#x2F;&#x2F; 保存初始化状态</span><br><span class="line">  var self &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 初始化状态</span><br><span class="line">  this.state &#x3D; PENDING;</span><br><span class="line">  &#x2F;&#x2F; 用于保存 resolve 或者 rejected 传入的值</span><br><span class="line">  this.value &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 用于保存 resolve 的回调函数</span><br><span class="line">  this.resolvedCallbacks &#x3D; [];</span><br><span class="line">  &#x2F;&#x2F; 用于保存 reject 的回调函数</span><br><span class="line">  this.rejectedCallbacks &#x3D; [];</span><br><span class="line">  &#x2F;&#x2F; 状态转变为 resolved 方法</span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br><span class="line">    if (value instanceof MyPromise) &#123;</span><br><span class="line">      return value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 只有状态为 pending 时才能转变，</span><br><span class="line">      if (self.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        &#x2F;&#x2F; 修改状态</span><br><span class="line">        self.state &#x3D; RESOLVED;</span><br><span class="line">        &#x2F;&#x2F; 设置传入的值</span><br><span class="line">        self.value &#x3D; value;</span><br><span class="line">        &#x2F;&#x2F; 执行回调函数</span><br><span class="line">        self.resolvedCallbacks.forEach(callback &#x3D;&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 状态转变为 rejected 方法</span><br><span class="line">  function reject(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 只有状态为 pending 时才能转变</span><br><span class="line">      if (self.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        &#x2F;&#x2F; 修改状态</span><br><span class="line">        self.state &#x3D; REJECTED;</span><br><span class="line">        &#x2F;&#x2F; 设置传入的值</span><br><span class="line">        self.value &#x3D; value;</span><br><span class="line">        &#x2F;&#x2F; 执行回调函数</span><br><span class="line">        self.rejectedCallbacks.forEach(callback &#x3D;&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 将两个方法传入函数执行</span><br><span class="line">  try &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    &#x2F;&#x2F; 遇到错误时，捕获错误，执行 reject 函数</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then &#x3D; function(onResolved, onRejected) &#123;</span><br><span class="line">  &#x2F;&#x2F; 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br><span class="line">  onResolved &#x3D;</span><br><span class="line">    typeof onResolved &#x3D;&#x3D;&#x3D; &quot;function&quot; ?</span><br><span class="line">    onResolved :</span><br><span class="line">    function(value) &#123;</span><br><span class="line">      return value;</span><br><span class="line">    &#125;;</span><br><span class="line">  onRejected &#x3D;</span><br><span class="line">    typeof onRejected &#x3D;&#x3D;&#x3D; &quot;function&quot; ?</span><br><span class="line">    onRejected :</span><br><span class="line">    function(error) &#123;</span><br><span class="line">      throw error;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#x2F;&#x2F; 如果是等待状态，则将函数加入对应列表中</span><br><span class="line">  if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">    this.resolvedCallbacks.push(onResolved);</span><br><span class="line">    this.rejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 如果状态已经凝固，则直接执行对应状态的函数</span><br><span class="line">  if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">    onResolved(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;</span><br><span class="line">    onRejected(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码忘记是从哪里copy来的,感谢大佬们的分享</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;Promise我们都很熟悉了,也都会使用了,如果自己实现一个promise,要怎么做&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="https://www.chensheng.group/2021/11/01/149-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://www.chensheng.group/2021/11/01/149-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</id>
    <published>2021-11-01T13:20:00.000Z</published>
    <updated>2021-11-02T12:32:40.715Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>一起学习一下函数柯里化,感谢百度上各位大佬们的无私奉献</p></blockquote><a id="more"></a><h3 id="什么是柯里化"><a href="#什么是柯里化" class="headerlink" title="什么是柯里化"></a>什么是柯里化</h3><p>柯里化，是函数式编程的一个重要概念。它既能减少代码冗余，也能增加可读性。另外，附带着还能用来装逼。</p><p>先给出柯里化的定义：在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><p>理论上的东西总是抽象的,直接看最简单的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 普通的add函数</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Currying后</span><br><span class="line">function curryingAdd(x) &#123;</span><br><span class="line">  return function (y) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 2)           &#x2F;&#x2F; 3</span><br><span class="line">curryingAdd(1)(2)   &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><blockquote><p>实际上就是把add函数的x，y两个参数变成了先用一个函数接收x然后返回一个函数去处理y参数。现在思路应该就比较清晰了，就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p></blockquote><p>例如有一个简单的加法函数，他能够将自身的三个参数加起来并返回计算结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么add函数的柯里化函数_add则可以如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function _add(a) &#123;</span><br><span class="line">    return function(b) &#123;</span><br><span class="line">        return function(c) &#123;</span><br><span class="line">            return a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的运算方式是等价的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(1, 2, 3);</span><br><span class="line">_add(1)(2)(3);</span><br></pre></td></tr></table></figure><p>靠眼力封装的柯里化函数自由度偏低，柯里化通用式具备更加强大的能力。因此我们需要知道如何去封装这样一个柯里化的通用式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 简单实现，参数只能从右到左传递</span><br><span class="line">function curry(fn, args) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取函数需要的参数长度</span><br><span class="line">  let length &#x3D; fn.length;</span><br><span class="line">  args &#x3D; args || [];</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let subArgs &#x3D; args.slice(0);</span><br><span class="line">    &#x2F;&#x2F; 拼接得到现有的所有参数</span><br><span class="line">    for (let i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">      subArgs.push(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 判断参数的长度是否已经满足函数所需参数的长度</span><br><span class="line">    if (subArgs.length &gt;&#x3D; length) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果满足，执行函数</span><br><span class="line">      return fn.apply(this, subArgs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果不满足，递归返回科里化的函数，等待参数的传入</span><br><span class="line">      &#x2F;&#x2F; 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span><br><span class="line">      return curry.call(this, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用es6的语法,就更简单了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">  return fn.length &lt;&#x3D; args.length ? fn(...args) : curry.bind(null,fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是我对函数柯里化的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;一起学习一下函数柯里化,感谢百度上各位大佬们的无私奉献&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>微信开发学习</title>
    <link href="https://www.chensheng.group/2021/10/07/148-%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    <id>https://www.chensheng.group/2021/10/07/148-%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/</id>
    <published>2021-10-07T05:28:00.000Z</published>
    <updated>2021-10-16T05:23:06.737Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>简单的介绍一下微信开发的一些注意事项</p></blockquote><a id="more"></a><p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html#1" target="_blank" rel="noopener">官网地址</a></p><h3 id="什么是OpenID-UnionID"><a href="#什么是OpenID-UnionID" class="headerlink" title="什么是OpenID,UnionID"></a>什么是OpenID,UnionID</h3><p>做微信开发,绕不过两个名词 OpenID,UnionID</p><ul><li>OpenID</li></ul><p>获取OpenID是我们在做微信开发必须要做的一件事情,OpenID就理解成用户的唯一标识</p><ul><li>UnionID</li></ul><p>如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下<br>绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，<br>只有一个UnionID，可以在用户管理-获取用户基本信息（UnionID机制）</p><h3 id="什么是Access-token"><a href="#什么是Access-token" class="headerlink" title="什么是Access token"></a>什么是Access token</h3><p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。</p><p>公众号和小程序均可以使用AppID和AppSecret调用本接口来获取access_token。AppID和AppSecret可在“微信公众平台-开发-基本配置”页中获得。</p><p>调用接口时，请登录“微信公众平台-开发-基本配置”提前将服务器IP地址添加到IP白名单中，点击查看设置方法，否则将无法调用成功。</p><h3 id="网页授权-公众号"><a href="#网页授权-公众号" class="headerlink" title="网页授权(公众号)"></a>网页授权(公众号)</h3><p>接下来看看如何授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let link &#x3D; window.location.href;</span><br><span class="line">let appid &#x3D; &#39;appid&#39;;</span><br><span class="line">let uri &#x3D; encodeURIComponent(link);</span><br><span class="line">let authURL &#x3D; &#96;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorize?appid&#x3D;$&#123;appid&#125;&amp;redirect_uri&#x3D;$&#123;uri&#125;&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_userinfo&amp;state&#x3D;123#wechat_redirect&#96;;</span><br><span class="line">window.location.href &#x3D; authURL;</span><br></pre></td></tr></table></figure><p>通过代码可以看出,公众号使用跳转的方式进行网页授权,获取到用户的code,后端通过code,获取用户的openid</p><blockquote><p>关于网页授权的两种scope的区别说明</p></blockquote><ol><li><p>以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）</p></li><li><p>以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</p></li><li><p>用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p></li></ol><blockquote><p>关于特殊场景下的静默授权</p></blockquote><p>为什么我们的项目,使用的是snsapi_userinfo,也没有弹出授权?</p><ol><li><p>上面已经提到，对于以snsapi_base为scope的网页授权，就静默授权的，用户无感知；</p></li><li><p>对于已关注公众号的用户，如果用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是scope为snsapi_userinfo，也是静默授权，用户无感知。</p></li></ol><p>对于公众号授权步骤,分为四步</p><ol><li><p>引导用户进入授权页面同意授权，获取code</p></li><li><p>通过code换取网页授权access_token（与基础支持中的access_token不同）</p></li><li><p>如果需要，开发者可以刷新网页授权access_token，避免过期</p></li><li><p>通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）</p></li></ol><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>这里强调一下开发中可能会遇到的问题</p><ul><li>回调的链接问题</li></ul><ol><li><p>若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。</p></li><li><p>由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问</p></li><li><p>跳转回调redirect_uri，应当使用https链接来确保授权code的安全性。</p></li><li><p>回调的链接不支持 hash模式,需要做特殊处理</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let href &#x3D; &#39;&#39;;</span><br><span class="line">const w &#x3D; location.href.indexOf(&#39;?&#39;);</span><br><span class="line">const j &#x3D; location.href.indexOf(&#39;#&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理微信回调url, 重新获取code</span><br><span class="line">if (w !&#x3D;&#x3D; -1 &amp;&amp; j &gt; w) &#123;</span><br><span class="line">  href &#x3D; location.href.substr(0, w) + location.href.substr(j, location.href.length) + location.search.replace(&#x2F;\?&#x2F;, &quot;&amp;&quot;);</span><br><span class="line">  location.href &#x3D; href;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取access_token问题</li></ul><ol><li><p>通过code获取access_token,微信公众号配置IP白名单,才可以进行请求</p></li><li><p>由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起。</p></li></ol><h4 id="拉取用户信息-需scope为-snsapi-userinfo"><a href="#拉取用户信息-需scope为-snsapi-userinfo" class="headerlink" title="拉取用户信息(需scope为 snsapi_userinfo)"></a>拉取用户信息(需scope为 snsapi_userinfo)</h4><p>如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了。</p><p>到这里,公众号完成了基本的网页授权</p><h3 id="公众号使用微信JS-SDK"><a href="#公众号使用微信JS-SDK" class="headerlink" title="公众号使用微信JS-SDK"></a>公众号使用微信JS-SDK</h3><p>JSSDK使用步骤</p><h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。</p><p>备注：登录后可在“开发者中心”查看对应的接口权限。</p><h4 id="引入JS文件"><a href="#引入JS文件" class="headerlink" title="引入JS文件"></a>引入JS文件</h4><ol><li><p>在需要调用JS接口的页面引入如下JS文件，（支持https）：<a href="http://res.wx.qq.com/open/js/jweixin-1.6.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.6.0.js</a></p></li><li><p>也可以直接导入npm包<br>首先安装 weixin-js-sdk, 之后引入进来 import wx from ‘weixin-js-sdk’</p></li><li><p>也可以使用微信浏览器自带的方法(WeixinJSBridge)</p></li></ol><h4 id="通过config接口注入权限验证配置"><a href="#通过config接口注入权限验证配置" class="headerlink" title="通过config接口注入权限验证配置"></a>通过config接口注入权限验证配置</h4><p>所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">  debug: true, &#x2F;&#x2F; 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">  appId: &#39;&#39;, &#x2F;&#x2F; 必填，公众号的唯一标识</span><br><span class="line">  timestamp: , &#x2F;&#x2F; 必填，生成签名的时间戳</span><br><span class="line">  nonceStr: &#39;&#39;, &#x2F;&#x2F; 必填，生成签名的随机串</span><br><span class="line">  signature: &#39;&#39;,&#x2F;&#x2F; 必填，签名</span><br><span class="line">  jsApiList: [] &#x2F;&#x2F; 必填，需要使用的JS接口列表</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="通过ready接口处理成功验证"><a href="#通过ready接口处理成功验证" class="headerlink" title="通过ready接口处理成功验证"></a>通过ready接口处理成功验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.ready(function()&#123;</span><br><span class="line">  &#x2F;&#x2F; config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="通过error接口处理失败验证"><a href="#通过error接口处理失败验证" class="headerlink" title="通过error接口处理失败验证"></a>通过error接口处理失败验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.error(function(res)&#123;</span><br><span class="line">  &#x2F;&#x2F; config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>到这里,微信公众号的JS-SDK就可以正常使用了,分享功能,音频接口,指纹识别,微信支付等可以在其他的博客看到使用的详细方法,更多的可以看看官方文档</p><h3 id="小程序授权-微信小程序"><a href="#小程序授权-微信小程序" class="headerlink" title="小程序授权(微信小程序)"></a>小程序授权(微信小程序)</h3><p>在说到小程序之前,先说一下它和公众号的区别</p><p>网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作.</p><p>而小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。</p><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><p>各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的：</p><p>在 iOS、iPadOS 和 Mac OS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，环境有 iOS 14、iPad OS 14、Mac OS 11.4 等；<br>在 Android 上，小程序逻辑层的 javascript 代码运行在 V8 中，视图层是由基于 Mobile Chrome 内核的自研 XWeb 引擎来渲染的；<br>在 Windows 上，小程序逻辑层 javascript 和视图层 javascript 都是用 Chrome 内核；<br>在 开发工具上，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium Webview 来渲染的。</p><table><thead><tr><th>运行环境</th><th>逻辑层</th><th>渲染层</th></tr></thead><tbody><tr><td>iOS</td><td>JavaScriptCore</td><td>WKWebView</td></tr><tr><td>安卓</td><td>V8</td><td>chromium定制内核</td></tr><tr><td>小程序开发者工具</td><td>NWJS</td><td>Chrome WebView</td></tr></tbody></table><p>由于视图渲染的方式不一致,还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现</p><p>除了样式的差异,在js上也有一定的区别</p><h5 id="Promise-时序差异"><a href="#Promise-时序差异" class="headerlink" title="Promise 时序差异"></a>Promise 时序差异</h5><p>由于实现原因与 iOS JavaScriptCore 限制，iOS 环境下的 Promise 是一个使用 setTimeout 模拟的 Polyfill。这意味着 Promise 触发的任务为普通任务，而非微任务，进而导致 在 iOS 下的 Promise 时序会和标准存在差异。</p><blockquote><p>具体的宏任务和微任务的差别,这里不细讲了,博客的其他文章中有</p></blockquote><h4 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h4><p>回归正传,看看小程序的授权流程,上图</p><p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg" alt="登录流程时序"></p><p>微信小程序的登录比较简单,简单来说只有几步</p><ol><li>调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。</li><li>调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 、用户在微信开放平台帐号下的唯一标识UnionID 和 会话密钥 session_key。</li></ol><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>部分接口需要经过用户授权同意才能调用。我们把这些接口按使用范围分成多个scope，用户选择对scope来进行授权，当授权给一个 scope 之后，其对应的所有接口都可以直接使用。</p><table><thead><tr><th>scope</th><th>对应接口</th><th>描述</th></tr></thead><tbody><tr><td>scope.userInfo</td><td>wx.getUserInfo</td><td>用户信息</td></tr><tr><td>scope.userLocation</td><td>wx.getLocation, wx.chooseLocation</td><td>地理位置</td></tr><tr><td>scope.userLocationBackground</td><td>wx.startLocationUpdateBackground</td><td>后台定位</td></tr><tr><td>scope.werun</td><td>wx.getWeRunData</td><td>微信运动步数</td></tr><tr><td>scope.record</td><td>wx.startRecord</td><td>录音功能</td></tr><tr><td>scope.writePhotosAlbum</td><td>wx.saveImageToPhotosAlbum, wx.saveVideoToPhotosAlbum</td><td>保存到相册</td></tr><tr><td>scope.camera</td><td>camera 组件</td><td>保存到相册</td></tr></tbody></table><p>此类接口调用时：</p><ul><li>如果用户未接受，会弹窗询问用户，用户点击同意后方可调用接口；</li><li>如果用户已授权，可以直接调用接口；</li><li>如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口 fail 回调。请开发者兼容用户拒绝授权的场景。</li></ul><p>开发者可以使用 wx.getSetting 获取用户当前的授权状态。然后判断用户是否拒绝授权,弹窗二次提醒用户是否授权,开发者可以调用 wx.openSetting 打开设置界面，引导用户开启授权。</p><p><a href="https://developers.weixin.qq.com/community/develop/doc/000cea2305cc5047af5733de751008" target="_blank" rel="noopener">openSetting接口调整</a><br><a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserProfile.html#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">getUserInfo接口调整</a><br><a href="https://developers.weixin.qq.com/community/develop/doc/000aee91a98d206bc6dbe722b51801" target="_blank" rel="noopener">getLocation接口调整</a></p><blockquote><p>需要注意的是, getUserProfile获取用户昵称头像等,需要用户手动触发,每次调用都会弹窗</p></blockquote><h4 id="获取手机号"><a href="#获取手机号" class="headerlink" title="获取手机号"></a>获取手机号</h4><p>因为需要用户主动触发才能发起获取手机号接口，所以该功能不由 API 来调用，需用 button 组件的点击来触发。</p><p>需要将 button 组件 open-type 的值设置为 getPhoneNumber，当用户点击并同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据， 然后在第三方服务端结合 session_key 以及 app_id 进行解密获取手机号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;button open-type&#x3D;&quot;getPhoneNumber&quot; bindgetphonenumber&#x3D;&quot;getPhoneNumber&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">getPhoneNumber (e) &#123;</span><br><span class="line">  console.log(e.detail.errMsg)</span><br><span class="line">  console.log(e.detail.iv)</span><br><span class="line">  console.log(e.detail.encryptedData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取到的加密数据给到后端,获取手机号</span><br></pre></td></tr></table></figure><blockquote><p>在回调中调用 wx.login 登录，可能会刷新登录态。此时服务器使用 code 换取的 sessionKey 不是加密时使用的 sessionKey，导致解密失败。建议开发者提前进行 login；或者在回调中先使用 checkSession 进行登录态检查，避免 login 刷新登录态。</p></blockquote><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><p>上传图片,下载,地图等功能,需要服务器配置安全域名</p><blockquote><p>地图有的时候需要用到<code>https://apis.map.qq.com</code>,也要配置域名</p></blockquote><p>如果项目中有用到web-view组件,H5的链接需要配置业务域名,配置时校验文件需要放在域名的根目录</p><h4 id="服务器域名配置"><a href="#服务器域名配置" class="headerlink" title="服务器域名配置"></a>服务器域名配置</h4><p>服务器域名请在 「小程序后台-开发-开发设置-服务器域名」 中进行配置，配置时需要注意：</p><ul><li>域名只支持 https (wx.request、wx.uploadFile、wx.downloadFile) 和 wss (wx.connectSocket) 协议；</li><li>域名不能使用 IP 地址（小程序的局域网 IP 除外）或 localhost；</li><li>域名必须经过 ICP 备案；</li><li>出于安全考虑，api.weixin.qq.com 不能被配置为服务器域名，相关API也不能在小程序内调用。 开发者应将 AppSecret 保存到后台服务器中，通过服务器使用 getAccessToken 接口获取 access_token，并调用相关 API；</li><li>不支持配置父域名，使用子域名。</li></ul><h4 id="HTTPS-证书"><a href="#HTTPS-证书" class="headerlink" title="HTTPS 证书"></a>HTTPS 证书</h4><p>小程序必须使用 HTTPS/WSS 发起网络请求。请求时系统会对服务器域名使用的 HTTPS 证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议开发者按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。</p><p>对证书要求如下：</p><ul><li>HTTPS 证书必须有效；<ul><li>证书必须被系统信任，即根证书被已系统内置</li><li>部署 SSL 证书的网站域名必须与证书颁发的域名一致</li><li>证书必须在有效期内</li><li>证书的信任链必需完整（需要服务器配置）</li></ul></li><li>iOS 不支持自签名证书;</li><li>iOS 下证书必须满足苹果 App Transport Security (ATS) 的要求;</li><li>TLS 必须支持 1.2 及以上版本。部分旧 Android 机型还未支持 TLS 1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;</li><li>部分 CA 可能不被操作系统信任，请开发者在选择证书时注意小程序和各系统的相关通告。<ul><li>Chrome 56/57 内核对 WoSign、StartCom 证书限制周知</li></ul></li></ul><p>(…未完待续)</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;简单的介绍一下微信开发的一些注意事项&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="https://www.chensheng.group/2021/09/03/147-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://www.chensheng.group/2021/09/03/147-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2021-09-03T06:53:00.000Z</published>
    <updated>2021-09-03T06:56:04.124Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>节流与防抖就像重绘和回流一样重要,都是为了提高性能,一直以为博客里面已经写了,结果发现没有,现在补一下</p></blockquote><a id="more"></a><h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h3><p>函数防抖：在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</p><p>分解一下需求：</p><ul><li>持续触发不执行</li><li>不触发的一段时间之后再执行</li></ul><p>我们什么场景下会用到呢</p><p>举个例子,我们想要让搜索的输入框输入后,开始查询,调用后端的接口,但是直接监听input的change事件,每按一下键盘,就去调用接口了,但是这个时候,用户其实并没有输入完他的关键字,这个时候,就需要用到函数防抖了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数防抖的实现</span><br><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">  var timer &#x3D; null;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context &#x3D; this,</span><br><span class="line">    args &#x3D; arguments;</span><br><span class="line">    &#x2F;&#x2F; 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置定时器，使事件间隔指定事件后执行</span><br><span class="line">    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h3><p>函数节流：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</p><p>分解一下需求：</p><ul><li>持续触发并不会执行多次</li><li>到一定时间再去执行</li></ul><p>假设,刚刚的那个需求变了,产品发现有一些用户疯狂的敲键盘输入,但是我们的搜索列表就是为空,所以希望每隔一定的时候就要去调用接口,所以当我们监听input的change事件的时候,需要使用到函数节流了,持续触发不会执行,但是到了一定的时间就会开始执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数节流的实现;</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  var preTime &#x3D; Date.now();</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context &#x3D; this,</span><br><span class="line">    args &#x3D; arguments,</span><br><span class="line">    nowTime &#x3D; Date.now();</span><br><span class="line">    &#x2F;&#x2F; 如果两次时间间隔超过了指定时间，则执行函数。</span><br><span class="line">    if (nowTime - preTime &gt;&#x3D; delay) &#123;</span><br><span class="line">      preTime &#x3D; Date.now();</span><br><span class="line">      return fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p></blockquote><blockquote><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p></blockquote><p>以上就是我对防抖和节流的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;节流与防抖就像重绘和回流一样重要,都是为了提高性能,一直以为博客里面已经写了,结果发现没有,现在补一下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>css高频考题</title>
    <link href="https://www.chensheng.group/2021/09/01/146-css%E6%95%B4%E7%90%86/"/>
    <id>https://www.chensheng.group/2021/09/01/146-css%E6%95%B4%E7%90%86/</id>
    <published>2021-09-01T06:42:00.000Z</published>
    <updated>2021-09-03T06:53:58.157Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>整理了一下常见的css的问题</p></blockquote><a id="more"></a><h3 id="介绍一下标准的-CSS-的盒子模型"><a href="#介绍一下标准的-CSS-的盒子模型" class="headerlink" title="介绍一下标准的 CSS 的盒子模型"></a>介绍一下标准的 CSS 的盒子模型</h3><ul><li>有两种盒子模型：IE 盒模型（border-box）、W3C 标准盒模型（content-box）</li><li>盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分</li></ul><p>IE 盒模型和 W3C 标准盒模型的区别：</p><ul><li>W3C 标准盒模型：属性 width，height 只包含内容 content，不包含 border 和 padding</li><li>IE 盒模型：属性 width，height 包含 content、border 和 padding，指的是 content + padding + border。</li></ul><blockquote><p>如果将 box-sizing 设为 border-box 则用的是 IE 盒模型。</p></blockquote><h3 id="CSS-选择符有哪些"><a href="#CSS-选择符有哪些" class="headerlink" title="CSS 选择符有哪些?"></a>CSS 选择符有哪些?</h3><ol><li>id 选择器（#myid）</li><li>类选择器（.myclassname）</li><li>标签选择器（div,h1,p）</li><li>后代选择器（h1 p）</li><li>相邻后代选择器（子）选择器（ul&gt;li）</li><li>兄弟选择器（li~a）</li><li>相邻兄弟选择器（li+a）</li><li>属性选择器（a[rel=”external”]）</li><li>伪类选择器（a:hover,li:nth-child）</li><li>伪元素选择器（::before、::after）</li><li>通配符选择器（*）</li></ol><h3 id="CSS-中哪些属性可以继承"><a href="#CSS-中哪些属性可以继承" class="headerlink" title="CSS 中哪些属性可以继承"></a>CSS 中哪些属性可以继承</h3><ul><li><p>字体系列属性<br>font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</p></li><li><p>文本系列属性<br>text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color</p></li><li><p>表格布局属性<br>caption-sideborder-collapseempty-cells</p></li><li><p>列表属性<br>list-style-type、list-style-image、list-style-position、list-style</p></li><li><p>光标属性<br>cursor</p></li><li><p>元素可见性<br>visibility</p></li></ul><h3 id="CSS3-新增伪类有那些"><a href="#CSS3-新增伪类有那些" class="headerlink" title="CSS3 新增伪类有那些?"></a>CSS3 新增伪类有那些?</h3><ul><li>elem:nth-child(n)选中父元素下的第 n 个子元素，并且这个子元素的标签名为 elem，n可以接受具体的数值，也可以接受函数。</li><li>elem:nth-last-child(n)作用同上，不过是从后开始查找。</li><li>elem:last-child 选中最后一个子元素。</li><li>elem:only-child 如果 elem 是父元素下唯一的子元素，则选中之。</li><li>elem:nth-of-type(n)选中父元素下第 n 个 elem 类型元素，n 可以接受具体的数值，也可以接受函数。</li><li>elem:first-of-type 选中父元素下第一个 elem 类型元素。</li><li>elem:last-of-type 选中父元素下最后一个 elem 类型元素。</li><li>elem:only-of-type 如果父元素下的子元素只有一个 elem 类型元素，则选中该元素。</li><li>elem:empty 选中不包含子元素和内容的 elem 类型元素。</li><li>elem:target 选择当前活动的 elem 元素。</li><li>:not(elem)选择非 elem 元素的每个元素。</li><li>:enabled 控制表单控件的禁用状态。</li><li>:disabled 控制表单控件的禁用状态。</li><li>:checked 单选框或复选框被选中。</li></ul><h3 id="CSS3-有哪些新特性？"><a href="#CSS3-有哪些新特性？" class="headerlink" title="CSS3 有哪些新特性？"></a>CSS3 有哪些新特性？</h3><ul><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadow\Reflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>过渡 （transform）缩放，定位，倾斜，动画，多背景</li></ul><h3 id="解释一下-CSS3-的-Flexbox（弹性盒布局模型）"><a href="#解释一下-CSS3-的-Flexbox（弹性盒布局模型）" class="headerlink" title="解释一下 CSS3 的 Flexbox（弹性盒布局模型）"></a>解释一下 CSS3 的 Flexbox（弹性盒布局模型）</h3><p><a href="https://www.chensheng.group/2018/08/08/62-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E6%B7%B1%E5%85%A5/">弹性布局深入</a></p><h3 id="width-auto-和-width-100-的区别"><a href="#width-auto-和-width-100-的区别" class="headerlink" title="width:auto 和 width:100%的区别"></a>width:auto 和 width:100%的区别</h3><ul><li><p>width:100%会使元素 box 的宽度等于父元素的 contentbox 的宽度。</p></li><li><p>width:auto 会使元素撑满整个父元素，margin、border、padding、content 区域会自动分配水平空间。</p></li></ul><h3 id="BFC规范的理解-css中常见的兼容性问题-margin-重叠问题的理解-怎么让-Chrome-支持小于-12px-的文字"><a href="#BFC规范的理解-css中常见的兼容性问题-margin-重叠问题的理解-怎么让-Chrome-支持小于-12px-的文字" class="headerlink" title="BFC规范的理解?css中常见的兼容性问题?margin 重叠问题的理解?怎么让 Chrome 支持小于 12px 的文字?"></a>BFC规范的理解?css中常见的兼容性问题?margin 重叠问题的理解?怎么让 Chrome 支持小于 12px 的文字?</h3><p><a href="https://www.chensheng.group/2018/02/24/55-%E5%85%B3%E4%BA%8ECSS%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/">那些你不知道的CSS</a></p><h3 id="CSS-优化、提高性能的方法有哪些"><a href="#CSS-优化、提高性能的方法有哪些" class="headerlink" title="CSS 优化、提高性能的方法有哪些?"></a>CSS 优化、提高性能的方法有哪些?</h3><p>加载性能：</p><ol><li>css 压缩：将写好的 css 进行打包压缩，可以减少很多的体积。</li><li>css 单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bottom;margin-left:left;执行的效率更高。</li><li>减少使用@import,而建议使用 link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ol><p>选择器性能：</p><ol><li>关键选择器（keyselector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS 选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</li><li>如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</li><li>避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。</li><li>尽量少的去对标签进行选择，而是用 class。</li><li>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</li></ol><p>渲染性能：</p><ol><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少 css 文档体积。</li><li>属性值为 0 时，不加单位。</li><li>属性值为浮动小数 0.**，可以省略小数点之前的 0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import 前缀，它会影响 css 的加载速度。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>css 雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li><li>正确使用 display 的属性，由于 display 的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li><li>不滥用 web 字体。对于中文网站来说 WebFonts 可能很陌生，国外却很流行。webfonts通常体积庞大，而且一些浏览器在下载 webfonts 时会阻塞页面渲染损伤性能。</li></ol><p>可维护性、健壮性：</p><ol><li>将具有相同属性的样式抽离出来，整合并通过 class 在页面中进行使用，提高 css 的可维护性。</li><li>样式与内容分离：将 css 代码定义到外部 css 中。</li></ol><blockquote><p>上面的选择器性能的第一条,为什么CSS 选择符是从右到左进行匹配的 试想一下，如果采用从左至右的方式读取 CSS 规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配</p></blockquote><h3 id="在网页中应该使用奇数还是偶数的字体？为什么呢？"><a href="#在网页中应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="在网页中应该使用奇数还是偶数的字体？为什么呢？"></a>在网页中应该使用奇数还是偶数的字体？为什么呢？</h3><ol><li>偶数字号相对更容易和 web 设计的其他部分构成比例关系。比如：当我用了 14px 的正文字号，我可能会在一些地方用 14×0.5=7px 的 margin，在另一些地方用 14×1.5=21px 的标题字号。</li><li>浏览器缘故，低版本的浏览器 ie6 会把奇数字体强制转化为偶数，即 13px 渲染为 14px。</li><li>系统差别，早期的 Windows 里，中易宋体点阵只有 12 和 14、15、16px，唯独缺少 13px。</li></ol><h3 id="如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>如何修改 chrome 记住密码后自动填充表单的黄色背景？</h3><p>chrome 表单自动填充后，input 文本框的背景会变成黄色的，通过审查元素可以看到这是由于 chrome 会默认给自动填充的 input 表单加上 input:-webkit-autofill 私有属性，然后对其赋予以下样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  background-color:rgb(250,255,189)!important;</span><br><span class="line">  background-image:none!important;</span><br><span class="line">  color:rgb(0,0,0)!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 chrome 默认定义的 background-color，background-image，color 使用 important 是不能提高其优先级的，但是其他属性可使用</p><p>使用足够大的纯色内阴影来覆盖 input 输入框的黄色背景，处理如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill&#123;</span><br><span class="line">  -webkit-box-shadow: 000px 1000px white inset;</span><br><span class="line">  border: 1px solid #CCC !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="让页面里的字体变清晰，变细用 CSS 怎么做？"></a>让页面里的字体变清晰，变细用 CSS 怎么做？</h3><p>webkit 内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。</p><p>在 MacOS 测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设</p><h3 id="使用-rem-布局的优缺点"><a href="#使用-rem-布局的优缺点" class="headerlink" title="使用 rem 布局的优缺点"></a>使用 rem 布局的优缺点</h3><p>优点：<br>在屏幕分辨率千差万别的时代，只要将 rem 与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持 rem 了，兼容性也非常的好。</p><p>缺点：</p><ol><li>在奇葩的 dpr 设备上表现效果不太好，比如一些华为的高端机型用 rem 布局会出现错乱。</li><li>使用 iframe 引用也会出现问题。</li><li>rem 在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。</li></ol><p>(…未完待续)</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;整理了一下常见的css的问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://www.chensheng.group/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://www.chensheng.group/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>html高频考题</title>
    <link href="https://www.chensheng.group/2021/09/01/145-html%E6%95%B4%E7%90%86/"/>
    <id>https://www.chensheng.group/2021/09/01/145-html%E6%95%B4%E7%90%86/</id>
    <published>2021-09-01T06:33:00.000Z</published>
    <updated>2021-09-03T06:54:01.497Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>整理了一下常见的HTML的问题</p></blockquote><a id="more"></a><h3 id="DOCTYPE-的作用是什么"><a href="#DOCTYPE-的作用是什么" class="headerlink" title="DOCTYPE 的作用是什么?"></a>DOCTYPE 的作用是什么?</h3><!DOCTYPE><p>声明位于 HTML 文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。</p><p>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</p><h3 id="标准模式与兼容模式各有什么区别"><a href="#标准模式与兼容模式各有什么区别" class="headerlink" title="标准模式与兼容模式各有什么区别?"></a>标准模式与兼容模式各有什么区别?</h3><p>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。</p><p>在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</p><h3 id="页面导入样式时，使用-link-和-import-有什么区别"><a href="#页面导入样式时，使用-link-和-import-有什么区别" class="headerlink" title="页面导入样式时，使用 link 和 @import 有什么区别?"></a>页面导入样式时，使用 link 和 @import 有什么区别?</h3><ul><li>从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。</li><li>加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。</li><li>兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容性问题。</li><li>DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于DOM 方法是基于文档的，无法使用 @import 的方式插入样式。</li><li>link方式的样式的权重 高于@import的权重.</li></ul><h3 id="从敲入-URL-到渲染完成的整个过程"><a href="#从敲入-URL-到渲染完成的整个过程" class="headerlink" title="从敲入 URL 到渲染完成的整个过程"></a>从敲入 URL 到渲染完成的整个过程</h3><ul><li>用户输入 url 地址，浏览器根据域名寻找 IP 地址</li><li>浏览器向服务器发送 http 请求，如果服务器段返回以 301 之类的重定向，浏览器根据相应头中的 location 再次发送请求</li><li>服务器端接受请求，处理请求生成 html 代码，返回给浏览器，这时的 html 页面代码可能是经过压缩的</li><li>浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染</li><li>解析渲染该过程主要分为以下步骤：解析 HTML、构建 DOM 树、DOM 树与 CSS 样式进行附着构造呈现树</li><li>布局</li><li>绘制</li></ul><h3 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h3><ul><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</li><li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。</li></ul><blockquote><p>BOM 的核心是 window, window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</p></blockquote><h3 id="浏览器的渲染原理-渲染引擎"><a href="#浏览器的渲染原理-渲染引擎" class="headerlink" title="浏览器的渲染原理(渲染引擎)"></a>浏览器的渲染原理(渲染引擎)</h3><ul><li>首先解析收到的文档，根据文档定义构建一颗 DOM 树，DOM 树是由DOM 元素及属性节点组成的；</li><li>然后对 CSS 进行解析，生成 CSSOM 规则树；</li><li>根据 DOM 树和 CSSOM 规则树构建 Render Tree。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和DOM 对象相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情就是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li><li>布局阶段结束后是绘制阶段，比那里渲染树并调用对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ul><p>所有的 html 解析完成之后再去构建和布局 render tree。它是解析完一部分内容就显示一部分内容，同时可能还在网络下载其余内容。</p><h3 id="浏览器解析过程-JS-引擎"><a href="#浏览器解析过程-JS-引擎" class="headerlink" title="浏览器解析过程(JS 引擎)"></a>浏览器解析过程(JS 引擎)</h3><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p><p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p><h3 id="什么是重绘和回流"><a href="#什么是重绘和回流" class="headerlink" title="什么是重绘和回流?"></a>什么是重绘和回流?</h3><p>重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background color，我们将这样的操作称为重绘。<br>回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。</p><p>常见引起回流属性和方法:</p><blockquote><p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p></blockquote><ol><li>添加或者删除可见的 DOM 元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在 input 框中输入文字</li><li>浏览器窗口尺寸改变——resize 事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li><li>当你修改网页的默认字体时。</li></ol><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><h3 id="Canvas-和-SVG-有什么区别"><a href="#Canvas-和-SVG-有什么区别" class="headerlink" title="Canvas 和 SVG 有什么区别?"></a>Canvas 和 SVG 有什么区别?</h3><p>Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。</p><p>SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。</p><h3 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h3><ul><li>用户界面<ul><li>主进程</li><li>内核<ul><li>渲染引擎</li><li>JS 引擎<ul><li>执行栈</li></ul></li></ul></li><li>事件触发线程<ul><li>消息队列<ul><li>微任务</li><li>宏任务</li></ul></li></ul></li><li>网络异步线程</li><li>定时器线程</li></ul></li></ul><h3 id="常用的-meta-标签"><a href="#常用的-meta-标签" class="headerlink" title="常用的 meta 标签"></a>常用的 meta 标签</h3><p><a href="https://www.chensheng.group/2018/03/02/59-html5%E5%B8%B8%E7%94%A8%E7%9A%84meta%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93/">点击跳转</a></p><h3 id="disabled-和-readonly-的区别？"><a href="#disabled-和-readonly-的区别？" class="headerlink" title="disabled 和 readonly 的区别？"></a>disabled 和 readonly 的区别？</h3><ul><li>disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。</li><li>readonly 规定输入字段为只读。input 内容会随着表单提交。</li><li>无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value</li></ul><h3 id="扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"><a href="#扫描二维码登录网页是什么原理，前后两个事件是如何联系的？" class="headerlink" title="扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"></a>扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</h3><p>浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server 的帐号信息进行展示。并在客户端点击确认后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。</p><h3 id="get-请求传参长度的误区"><a href="#get-请求传参长度的误区" class="headerlink" title="get 请求传参长度的误区"></a>get 请求传参长度的误区</h3><p>误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</p><p>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。</p><ol><li>HTTP 协议未规定 GET 和 POST 的长度限制</li><li>GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li><li>不同的浏览器和 WEB 服务器，限制的最大长度不一样</li><li>要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度8182byte</li></ol><p>(…未完待续)</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;整理了一下常见的HTML的问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://www.chensheng.group/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://www.chensheng.group/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>axios在XP系统的兼容问题</title>
    <link href="https://www.chensheng.group/2021/09/01/144-axios%E5%9C%A8XP%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    <id>https://www.chensheng.group/2021/09/01/144-axios%E5%9C%A8XP%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</id>
    <published>2021-09-01T05:30:00.000Z</published>
    <updated>2022-05-27T06:32:04.265Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>vue-cli 使用 axios 兼容 xp</p></blockquote><a id="more"></a><p>项目需要兼容XP,控制台查看报错发现是 <code>promise is undefined</code>, 项目中调用接口使用的是axios, axios又是基于promise上</p><p>所以需要添加一些插件进行兼容</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>看到一篇博客说可以使用bluebird.js解决。直接在页面引入bluebird.js问题就解决了。</p><p><a href="https://fastly.jsdelivr.net/bluebird/latest/bluebird.js" target="_blank" rel="noopener">bluebird.js下载地址</a></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><code>npm install --save babel-polyfill</code></p><p>安装成功以后需要在main.js 中引入 babel-polyfill</p><p>一般会配置 webpack.base.config.js 中 entry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  context: path.resolve(__dirname, &#39;..&#x2F;&#39;),</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: [&quot;babel-polyfill&quot;, &quot;.&#x2F;src&#x2F;main.js&quot;] </span><br><span class="line">    &#x2F;&#x2F; app: &#39;.&#x2F;src&#x2F;main.js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞定……</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;vue-cli 使用 axios 兼容 xp&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用SSH上传部署</title>
    <link href="https://www.chensheng.group/2021/08/31/143-%E4%BD%BF%E7%94%A8SSH%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2/"/>
    <id>https://www.chensheng.group/2021/08/31/143-%E4%BD%BF%E7%94%A8SSH%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2/</id>
    <published>2021-08-31T10:12:00.000Z</published>
    <updated>2021-09-03T06:54:08.718Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>上传git或者coding时使用ssh</p></blockquote><a id="more"></a><p>因为太久没有上传博客了,所以提交代码的时候发现git报错了,查了一下百度,发现git已经不能使用账户和密码了,需要使用账户和token</p><p>嫌太麻烦了,所以统一使用ssh来上传部署</p><h3 id="获取电脑的ssh公钥"><a href="#获取电脑的ssh公钥" class="headerlink" title="获取电脑的ssh公钥"></a>获取电脑的ssh公钥</h3><p>打开 C盘/用户/.ssh/ 用文本编辑器打开 id_rsa.pub 文件（此处是生成公钥的默认名称，如果生成公钥时采用了其他名称，打开相对应的文件即可），复制全部内容。</p><h3 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h3><ul><li>登录 CODING ，点击右上角【个人设置】，选择菜单【SSH 公钥】，点击【新增公钥】按钮</li><li>将第一步中复制的内容填写到【公钥内容】一栏，公钥名称按需填写即可。</li><li>设定公钥有效期，可选择具体日期或设置永久有效。</li><li>点击【添加】，然后输入账户密码即可成功添加公钥。</li><li>完成后在命令行测试，首次建立链接会要求信任主机。命令 ssh -T <a href="mailto:git@e.coding.net">git@e.coding.net</a></li></ul><h4 id="添加部署公钥"><a href="#添加部署公钥" class="headerlink" title="添加部署公钥"></a>添加部署公钥</h4><ul><li>登录 CODING，进入目标项目，点击【代码仓库】-&gt; 【仓库设置】-&gt; 【部署公钥】-&gt;【新建部署公钥】</li><li>将第一步中复制的内容填写到【公钥内容】一栏，公钥名称自定义。</li><li>点击【新建】，然后输入账户密码即可成功添加部署公钥</li><li>部署公钥默认拥有该项目的只读权限，如果需要获取推送权限，请勾选部署公钥设置里的【授予推送权限】</li></ul><blockquote><p>配置好后,在仓库设置的基本设置里可以找到自己的SSH地址, SSH 协议的 Git 仓库地址示例所示：<a href="mailto:git@e.coding.net">git@e.coding.net</a>:team-name/project-name.git</p></blockquote><p><a href="https://help.coding.net/docs/project-settings/ssh.html" target="_blank" rel="noopener">coding官网配置ssh</a></p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>其他的配置都和coding一样,这里就不重复说明了,说一下git在哪里配置的</p><p><a href="https://img-blog.csdnimg.cn/20201223152106902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbGVuY2VfcGlub3Q=,size_16,color_FFFFFF,t_70#pic_center#pic_center" target="_blank" rel="noopener">gittu</a></p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>都OK了的话,在hexo的_config.yml写一下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 使用SSh公钥来配置</span><br><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: </span><br><span class="line">      github: git@github.com:name&#x2F;project.github.io.git</span><br><span class="line">      coding: git@e.coding.net:team-name&#x2F;project-name.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p>以上就是我对SSH上传部署的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;上传git或者coding时使用ssh&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>深入理解垃圾回收原理</title>
    <link href="https://www.chensheng.group/2021/08/30/142-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86/"/>
    <id>https://www.chensheng.group/2021/08/30/142-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-30T13:35:00.000Z</published>
    <updated>2021-09-03T06:54:12.698Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>前一阵子由于网站拿去ICP的备案,所以停了一段时间,现在备案下来了,我们来学习一下垃圾回收</p></blockquote><a id="more"></a><h3 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h3><p>垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要时，就应该予以释放，以让出内存。</p><p>直白点讲，就是程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量、函数等只有产生没有消亡的过程，那迟早内存有被完全占用的时候。</p><p>这个时候，不仅自己的程序无法正常运行，连其他程序也会受到影响。</p><p>所以，在计算机中，我们需要垃圾回收。需要注意的是，定义中的“自动”的意思是语言可以帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果操作失当，JavaScript 中依旧会出现内存溢出的情况。</p><h3 id="垃圾回收原理"><a href="#垃圾回收原理" class="headerlink" title="垃圾回收原理"></a>垃圾回收原理</h3><p>垃圾回收基于两个原理：</p><ul><li>考虑某个变量或对象在未来的程序运行中将不会被访问</li><li>向这些对象要求归还内存</li></ul><p>而这两个原理中，最主要的也是最艰难的部分就是找到“所分配的内存确实已经不再需要了”。</p><p>在解释这些之前,我们要先了解一下名词-GC</p><h3 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a>什么是GC</h3><p>GC可以理解为在追踪仍然使用的所有对象，并将其余对象标记为垃圾然后进行回收，这样的一个过程称之为GC，所有的GC系统可以从如下几个方面进行实现</p><ul><li>GC判断策略（例如引用计数，对象可达）</li><li>GC收集算法（标记清除法，标记清除整理法，标记复制清除法，分带法）</li><li>GC收集器（例如Serial，Parallel，CMS，G1）</li></ul><h3 id="V8垃圾回收策略"><a href="#V8垃圾回收策略" class="headerlink" title="V8垃圾回收策略"></a>V8垃圾回收策略</h3><p>V8的垃圾回收策略基于分代回收机制，该机制又基于<a href="https://www.memorymanagement.org/glossary/g.html#generational%20hypothesis" target="_blank" rel="noopener">世代假说</a>。该假说有两个特点：</p><ul><li>大部分新生对象倾向于早死；</li><li>不死的对象，会活得更久。</li></ul><p>基于这个理论，现代垃圾回收算法根据对象的存活时间将内存进行了分代，并对不同分代的内存采用不同的高效算法进行垃圾回收。</p><h3 id="V8的内存分代"><a href="#V8的内存分代" class="headerlink" title="V8的内存分代"></a>V8的内存分代</h3><p>在V8中，将内存分为了新生代（new space）和老生代（old space）。它们特点如下：</p><ul><li>新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。</li><li>老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。</li></ul><blockquote><p>V8堆的空间等于新生代空间加上老生代空间，默认设置下，64位系统的老生代大小为1400M，32位系统为700M。</p></blockquote><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="Stop-The-World-（全停顿）"><a href="#Stop-The-World-（全停顿）" class="headerlink" title="Stop The World （全停顿）"></a>Stop The World （全停顿）</h4><p>在介绍垃圾回收算法之前，我们先了解一下「全停顿」。垃圾回收算法在执行前，需要将应用逻辑暂停，执行完垃圾回收后再执行应用逻辑，这种行为称为 「全停顿」（Stop The World）</p><p>全停顿的目的，是为了解决应用逻辑与垃圾回收器看到的情况不一致的问题。举个例子，在自助餐厅吃饭，高高兴兴地取完食物回来时，结果发现自己餐具被服务员收走了。这里，服务员好比垃圾回收器，餐具就像是分配的对象，我们就是应用逻辑。在我们看来，只是将餐具临时放在桌上，但是服务员看来觉得你已经不需要使用了，因此就收走了。你与服务员对于同一个事物看到的情况是不一致，导致服务员做了与我们不期望的事情。因此，为避免应用逻辑与垃圾回收器看到的情况不一致，垃圾回收算法在执行时，需要停止应用逻辑。</p><h4 id="引用计数（reference-counting）"><a href="#引用计数（reference-counting）" class="headerlink" title="引用计数（reference counting）"></a>引用计数（reference counting）</h4><p>在V8回收之前,低版本 IE大多数用的是这种的方法</p><p>在内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。上例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj1 &#x3D; &#123; a: 1 &#125;; &#x2F;&#x2F; 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1 </span><br><span class="line">let obj2 &#x3D; obj1; &#x2F;&#x2F; A 的引用个数变为 2</span><br><span class="line"></span><br><span class="line">obj1 &#x3D; 0; &#x2F;&#x2F; A 的引用个数变为 1</span><br><span class="line">obj2 &#x3D; 0; &#x2F;&#x2F; A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了</span><br></pre></td></tr></table></figure><p>但是引用计数有个最大的问题： 循环引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">  let obj1 &#x3D; &#123;&#125;;</span><br><span class="line">  let obj2 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  obj1.a &#x3D; obj2; &#x2F;&#x2F; obj1 引用 obj2</span><br><span class="line">  obj2.a &#x3D; obj1; &#x2F;&#x2F; obj2 引用 obj1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。</p><p>要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。上面的例子可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1 &#x3D; null;</span><br><span class="line">obj2 &#x3D; null;</span><br></pre></td></tr></table></figure><p>这个方法被称为“解除引用”。</p><h4 id="Scavenge算法"><a href="#Scavenge算法" class="headerlink" title="Scavenge算法"></a>Scavenge算法</h4><p>在分代的基础上,新生代中的对象主要通过Scavenge算法进行垃圾回收,在Scavenge的具体 实现中,主要采用了Cheney算法</p><p>Cheney算法采用复制的方式进行垃圾回收。它将堆内存一分为二，每一部分空间称为 semispace。这两个空间，只有一个空间处于使用中，另一个则处于闲置。使用中的 semispace 称为 「From 空间」，闲置的 semispace 称为 「To 空间」。</p><p>过程如下: </p><ol><li>从 From 空间分配对象，若 semispace 被分配满，则执行 Scavenge 算法进行垃圾回收。</li><li>检查 From 空间的存活对象，若对象存活，则检查对象是否符合晋升条件，若符合条件则晋升到老生代，否则将对象从 From 空间复制到 To 空间。</li><li>若对象不存活，则释放不存活对象的空间。</li><li>完成复制后，将 From 空间与 To 空间进行角色翻转（flip）。</li></ol><p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/142-1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.jpg" alt="算法示意图"></p><h5 id="对象晋升"><a href="#对象晋升" class="headerlink" title="对象晋升"></a>对象晋升</h5><p>第二点提到的对象晋升,条件有两个: </p><ul><li>对象是否经历过Scavenge回收。</li><li>To 空间的内存使用占比是否超过限制(25%)。</li></ul><blockquote><p>Scavenge 算法的缺点是，它的算法机制决定了只能利用一半的内存空间。但是新生代中的对象生存周期短、存活对象少，进行对象复制的成本不是很高，因而非常适合这种场景。</p></blockquote><h4 id="标记-清除（mark-and-sweep）"><a href="#标记-清除（mark-and-sweep）" class="headerlink" title="标记-清除（mark and sweep）"></a>标记-清除（mark and sweep）</h4><p>这是 JavaScript 中最常见的垃圾回收方式</p><p>从 2012 年起，所有现代浏览器都使用了标记-清除的垃圾回收方法，除了低版本 IE…它们采用的是引用计数方法。</p><p>那什么叫标记清除呢？JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些活着的对象进行标记，这是标记阶段。清除阶段会对标记的对象会与内存中的对象进行比较，然后清除内存中那些没有标记的对象。</p><p>标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。</p><p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/142-2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.jpg.jpg" alt="算法示意图"></p><h4 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h4><p>在新生代中，由于存活对象少，垃圾回收效率高，全停顿时间短，造成的影响小。但是老生代中，存活对象多，垃圾回收时间长，全停顿造成的影响大。为了减少全停顿的时间，V8对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记。</p><blockquote><p>长时间的GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。从2011年起，v8就将「全暂停」标记换成了增量标记。改进后的标记方式，最大停顿时间减少到原来的1/6。</p></blockquote><p>以上就是我对垃圾回收的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;前一阵子由于网站拿去ICP的备案,所以停了一段时间,现在备案下来了,我们来学习一下垃圾回收&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>uniapp与webview之间的相互传值</title>
    <link href="https://www.chensheng.group/2021/04/19/141-uniapp%E4%B8%8Ewebview%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E4%BC%A0%E5%80%BC/"/>
    <id>https://www.chensheng.group/2021/04/19/141-uniapp%E4%B8%8Ewebview%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E4%BC%A0%E5%80%BC/</id>
    <published>2021-04-19T13:41:00.000Z</published>
    <updated>2021-06-20T14:05:13.752Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>在uniApp中,有时候我们需要外嵌一个H5在我们的webview中,那怎么让他们之前进行相互传值</p></blockquote><a id="more"></a><div class="note primary">            <p>以下代码都是在真机调试中测试的,有一些方法是只有uniapp运行到真机中才可以使用的</p>          </div><h3 id="引入的H5文件"><a href="#引入的H5文件" class="headerlink" title="引入的H5文件"></a>引入的H5文件</h3><p>这个H5的例子官方是已经有了的,需要注意的就是引入的<code>uni.webview.1.5.2.js</code></p><p>我不知道为什么引入外部cdn(<a href="https://js.cdn.aliyun.dcloud.net.cn/dev/uni-app/uni.webview.1.5.2.js" target="_blank" rel="noopener">https://js.cdn.aliyun.dcloud.net.cn/dev/uni-app/uni.webview.1.5.2.js</a>) 会失效,所以我都是将js下载下来,进行本地引入</p><p>H5的源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">.btn &#123;</span><br><span class="line">display: block;</span><br><span class="line">margin: 20px auto;</span><br><span class="line">padding: 5px;</span><br><span class="line">background-color: #007aff;</span><br><span class="line">border: 0;</span><br><span class="line">color: #ffffff;</span><br><span class="line">height: 40px;</span><br><span class="line">width: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btn-red &#123;</span><br><span class="line">background-color: #dd524d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btn-yellow &#123;</span><br><span class="line">background-color: #f0ad4e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.desc &#123;</span><br><span class="line">padding: 10px;</span><br><span class="line">color: #999999;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;desc&quot;&gt;web-view 组件加载本地 html 示例，仅在 App 环境下生效。点击下列按钮，跳转至其它页面。&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;mui-content&quot;&gt;</span><br><span class="line">        &lt;div id&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; capture&#x3D;&#39;camera&#39; accept&#x3D;&#39;image&#x2F;*&#39;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;btn-list&quot;&gt;</span><br><span class="line">&lt;button class&#x3D;&quot;btn&quot; type&#x3D;&quot;button&quot; data-action&#x3D;&quot;navigateTo&quot;&gt;navigateTo&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button class&#x3D;&quot;btn&quot; type&#x3D;&quot;button&quot; data-action&#x3D;&quot;redirectTo&quot;&gt;redirectTo&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button class&#x3D;&quot;btn&quot; type&#x3D;&quot;button&quot; data-action&#x3D;&quot;navigateBack&quot;&gt;navigateBack&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button class&#x3D;&quot;btn&quot; type&#x3D;&quot;button&quot; data-action&#x3D;&quot;reLaunch&quot;&gt;reLaunch&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button class&#x3D;&quot;btn&quot; type&#x3D;&quot;button&quot; data-action&#x3D;&quot;switchTab&quot;&gt;switchTab&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;desc&quot;&gt;网页向应用发送消息。注意：小程序端应用会在此页面后退时接收到消息。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;btn-list&quot;&gt;</span><br><span class="line">&lt;button class&#x3D;&quot;btn btn-red&quot; type&#x3D;&quot;button&quot; id&#x3D;&quot;postMessage&quot;&gt;postMessage&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- uni 的 SDK --&gt;</span><br><span class="line">&lt;!-- &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;js.cdn.aliyun.dcloud.net.cn&#x2F;dev&#x2F;uni-app&#x2F;uni.webview.1.5.2.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;uni.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">document.addEventListener(&#39;UniAppJSBridgeReady&#39;, function() &#123;</span><br><span class="line">document.querySelector(&#39;.btn-list&#39;).addEventListener(&#39;click&#39;, function(evt) &#123;</span><br><span class="line">var target &#x3D; evt.target;</span><br><span class="line">if (target.tagName &#x3D;&#x3D;&#x3D; &#39;BUTTON&#39;) &#123;</span><br><span class="line">var action &#x3D; target.getAttribute(&#39;data-action&#39;);</span><br><span class="line">switch (action) &#123;</span><br><span class="line">case &#39;switchTab&#39;:</span><br><span class="line">uni.switchTab(&#123;</span><br><span class="line">url: &#39;&#x2F;pages&#x2F;tabBar&#x2F;API&#x2F;API&#39;</span><br><span class="line">&#125;);</span><br><span class="line">break;</span><br><span class="line">case &#39;reLaunch&#39;:</span><br><span class="line">uni.reLaunch(&#123;</span><br><span class="line">url: &#39;&#x2F;pages&#x2F;tabBar&#x2F;API&#x2F;API&#39;</span><br><span class="line">&#125;);</span><br><span class="line">break;</span><br><span class="line">case &#39;navigateBack&#39;:</span><br><span class="line">uni.navigateBack(&#123;</span><br><span class="line">delta: 1</span><br><span class="line">&#125;);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">uni[action](&#123;</span><br><span class="line">url: &#39;&#x2F;pages&#x2F;component&#x2F;button&#x2F;button&#39;</span><br><span class="line">&#125;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">document.querySelector(&quot;#postMessage&quot;).addEventListener(&#39;click&#39;, function() &#123;</span><br><span class="line">uni.postMessage(&#123;</span><br><span class="line">data: &#123;</span><br><span class="line">action: &#39;message&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line">      function ajaxRequest(a)&#123;</span><br><span class="line">        alert(&#39;接收到的参数: &#39;, a);</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="H5-发送数据到-uniapp"><a href="#H5-发送数据到-uniapp" class="headerlink" title="H5 发送数据到 uniapp"></a>H5 发送数据到 uniapp</h3><ul><li>H5使用uni.postMessage发送数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uni.postMessage(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    action: &#39;message&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>webview使用@message进行监听</li></ul><p>具体源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;web-view ref&#x3D;&#39;webview&#39; src&#x3D;&quot;&#x2F;hybrid&#x2F;html&#x2F;local.html&quot;@message&#x3D;&quot;handleMessage&quot; &gt;&lt;&#x2F;web-view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleMessage(evt) &#123;</span><br><span class="line">      console.log(&#39;接收到的消息：&#39; + JSON.stringify(evt.detail.data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>H5页面的postMessage就是向uniapp发送消息</p><div class="note info">            <p>需要注意的是这里的src引入,我这里引入的是本地文件,所以跟着官方的文档走,放在<code>/hybrid/html/</code>的路径下</p>          </div><h3 id="uniapp-发送数据到-H5"><a href="#uniapp-发送数据到-H5" class="headerlink" title="uniapp 发送数据到 H5"></a>uniapp 发送数据到 H5</h3><p>百度上大部分的答案都是 通过url就可以向H5进行传参 </p><p>这种当然也可以,在H5中,再去获取url中的参数值,但是这种方法只能用在第一次</p><p>接下来后续应该怎么传递参数呢</p><blockquote><p>获取到这个webview的元素,然后就可以使用evalJS方法了</p></blockquote><p>但是这一步卡了我很久</p><p>因为百度到的都是<code>this.$mp.page.$getAppWebview()</code>这样的方法</p><p>但是 uniapp编译app时使用的都是webview,this.$mp.page.$getAppWebview()获取的是父webview. 所以一直没有evalJS方法</p><p>需要打点<code>.children()[0];</code>获取到子级,才是当前的webview</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const webview &#x3D; this.$mp.page.$getAppWebview().children()[0]; </span><br><span class="line">var name &#x3D; &#39;mike&#39;;</span><br><span class="line">webview.evalJS(&quot;ajaxRequest(&#39;&quot; + name + &quot;&#39;)&quot;);</span><br></pre></td></tr></table></figure><p>然后使用<code>evalJS</code>去调用方法就行</p><div class="note warning">            <p>注意evalJS方法里的 单引号 和 双引号</p>          </div><p>在H5中,只要有对应的方法就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function ajaxRequest(a)&#123;</span><br><span class="line">  alert(&#39;接收到的参数: &#39;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取当前的webview,也可以使用下面这种方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var pages &#x3D; getCurrentPages();  </span><br><span class="line">var page &#x3D; pages[pages.length - 1];  </span><br><span class="line">var webview &#x3D; page.$getAppWebview(); &#x2F;&#x2F;页面栈最顶层就是当前webview</span><br></pre></td></tr></table></figure><div class="note warning">            <p>getCurrentPages() 方法是 uniapp 中自带的</p>          </div><p>以上就是我对uniapp与webview之间的相互传值的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;在uniApp中,有时候我们需要外嵌一个H5在我们的webview中,那怎么让他们之前进行相互传值&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="uniApp" scheme="https://www.chensheng.group/categories/uniApp/"/>
    
    
      <category term="uniApp" scheme="https://www.chensheng.group/tags/uniApp/"/>
    
  </entry>
  
  <entry>
    <title>coding配置腾讯云证书</title>
    <link href="https://www.chensheng.group/2021/02/11/139-coding%E9%85%8D%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/"/>
    <id>https://www.chensheng.group/2021/02/11/139-coding%E9%85%8D%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/</id>
    <published>2021-02-11T06:57:00.000Z</published>
    <updated>2021-02-11T07:12:50.136Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>小小的记录,以免以后忘记了</p></blockquote><a id="more"></a><p>今天写完博客,发现网站的证书过期了,以往都是coding每次免费3个月的证书,但是现在coding和腾讯云合作了,要用腾讯云的证书了</p><ol><li><p>首先在coding中静态网站上看看自定义域名是否通过,因为coding的整体升级,于是CNAME指向也改了,我的域名是在阿里云上的,所以需要在阿里云的域名解析中重新添加</p></li><li><p>通过后就可以去申请腾讯云的证书了,他有免费一年的证书,可以找一找,然后填写一下资料,自己的域名和邮箱</p></li><li><p>第二步验证的方式使用DNS验证,同样的,在阿里云的域名解析中添加验证</p></li><li><p>成功后就会签发证书,就可以进行部署了</p></li><li><p>部署的时候选择腾讯云托管证书,在证书列表中选择刚刚签发的证书,回源协议选择HTTP或者HTTPS都可以</p></li><li><p>腾讯云证书部署成功后,在第一步的coding的静态网站中重新部署一下你的网站,这样就成功了(我最后一步一直没有重新部署,所以我一直以为我的证书部署失败了)</p></li><li><p>中途如果有部署失败的,应该是你的域名也指向了github,先把指向github的给暂停</p></li></ol><p>至此,博客的证书又可以白嫖一年了</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;小小的记录,以免以后忘记了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="SSL证书" scheme="https://www.chensheng.group/categories/SSL%E8%AF%81%E4%B9%A6/"/>
    
    
      <category term="SSL证书" scheme="https://www.chensheng.group/tags/SSL%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>关于CSS的一些事(2)</title>
    <link href="https://www.chensheng.group/2021/02/11/140-%E5%85%B3%E4%BA%8ECSS%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B(2)/"/>
    <id>https://www.chensheng.group/2021/02/11/140-%E5%85%B3%E4%BA%8ECSS%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B(2)/</id>
    <published>2021-02-11T06:57:00.000Z</published>
    <updated>2021-09-03T06:54:25.575Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>记录一些实用的CSS</p></blockquote><a id="more"></a><h3 id="全屏灰色（特殊日期使用）"><a href="#全屏灰色（特殊日期使用）" class="headerlink" title="全屏灰色（特殊日期使用）"></a>全屏灰色（特殊日期使用）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.filter &#123;</span><br><span class="line">  -webkit-filter: grayscale(100%); &#x2F;* webkit *&#x2F;</span><br><span class="line">  -moz-filter: grayscale(100%); &#x2F;*firefox*&#x2F;</span><br><span class="line">  -ms-filter: grayscale(100%); &#x2F;*ie9*&#x2F;</span><br><span class="line">  -o-filter: grayscale(100%); &#x2F;*opera*&#x2F;</span><br><span class="line">  filter: grayscale(100%);</span><br><span class="line">  filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale&#x3D;1); &#x2F;*ie*&#x2F;</span><br><span class="line">  filter: gray; &#x2F;*ie9- *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;html class&#x3D;&quot;filter&quot;&gt;</span><br><span class="line">  &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;cdn.pixabay.com&#x2F;photo&#x2F;2015&#x2F;04&#x2F;20&#x2F;17&#x2F;01&#x2F;flower-731830_960_720.jpg&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="卡券贴"><a href="#卡券贴" class="headerlink" title="卡券贴"></a>卡券贴</h3><p>在CSS3当中，background添加了background-size属性，控制背景图片的大小，配合background-position属性，可以在一个背景下面展示多张图片。</p><p>卡券贴的核心是使用透明白色径向渐变radial-gradient，分别让4张背景图中的左下角、右下角、右上角和左下角出现缺省，再利用drop-shadow实现元素阴影，从而达到效果。</p><p>radial-gradient语法如下：</p><blockquote><p>radial-gradient(shape size at position, start-color, …, last-color)</p></blockquote><p><img src="https://pic2.zhimg.com/80/v2-0e2b43fad0beebc5c13b3c7983b5ca45_720w.jpg" alt="属性说明"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.coupon&#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 80px;</span><br><span class="line">  background: radial-gradient(circle at right bottom, transparent 10px, #ffffff 0) top right &#x2F; 50% 40px no-repeat,</span><br><span class="line">    radial-gradient(circle at left bottom, transparent 10px, #ffffff 0) top left &#x2F; 50% 40px no-repeat,</span><br><span class="line">    radial-gradient(circle at right top, transparent 10px, #ffffff 0) bottom right &#x2F; 50% 40px no-repeat,</span><br><span class="line">    radial-gradient(circle at left top, transparent 10px, #ffffff 0) bottom left &#x2F; 50% 40px no-repeat;</span><br><span class="line">  filter: drop-shadow(3px 3px 3px #c5c5c5);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;coupon&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="文本溢出自动省略号"><a href="#文本溢出自动省略号" class="headerlink" title="文本溢出自动省略号"></a>文本溢出自动省略号</h3><p>这个在项目中经常用到,但是一直都记不住</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.ellipsis &#123;</span><br><span class="line">  width: 500px;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;ellipsis&quot;&gt;</span><br><span class="line">  明月几时有，把酒问青天。不知天上宫阙，今夕是何年。我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间。</span><br><span class="line">  转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="记录其他的好的链接"><a href="#记录其他的好的链接" class="headerlink" title="记录其他的好的链接"></a>记录其他的好的链接</h3><p>大神的作品,转载知乎</p><p><a href="https://zhuanlan.zhihu.com/p/158672754" target="_blank" rel="noopener">戳我跳转</a></p><p>总是记不住,但是要用到的样式 </p><p><a href="https://zhuanlan.zhihu.com/p/231014167" target="_blank" rel="noopener">戳我跳转</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;记录一些实用的CSS&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://www.chensheng.group/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://www.chensheng.group/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>vue源码学习-diff算法原理</title>
    <link href="https://www.chensheng.group/2021/02/11/138-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-diff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <id>https://www.chensheng.group/2021/02/11/138-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-diff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</id>
    <published>2021-02-11T03:33:00.000Z</published>
    <updated>2021-02-11T06:57:50.417Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>今天就是除夕了,也只有放假才有时间写一写博客,把欠下的博客都补上</p></blockquote><a id="more"></a><p>diff算法是我们在学习vue时经常听到的,像什么vue异步更新DOM,虚拟DOM的变化,都和diff算法有关,那什么是diff算法,他的作用又是什么呢</p><h3 id="diff算法的时间复杂度"><a href="#diff算法的时间复杂度" class="headerlink" title="diff算法的时间复杂度"></a>diff算法的时间复杂度</h3><p> 两个树的完全的 diff 算法是一个时间复杂度为 O(n3) , Vue 进行了优化·O(n3) 复杂度的问题转换成 O(n) 复杂度的问题(只比较同级不考虑跨级问题)  在前端当中， 你很少会跨越层级地移动Dom元素。 所 以 Virtual Dom只会对同一个层级的元素进行对比。</p><h3 id="diff算法原理"><a href="#diff算法原理" class="headerlink" title="diff算法原理"></a>diff算法原理</h3><blockquote><p>简单的来说,diff算法是为了比较新的DOM树和旧的DOM树,以此来算出,哪些DOM可以复用,新增哪些DOM,移除哪些DOM,优化DOM树的渲染</p></blockquote><p>自己总结的原理大概是这样的: </p><ol><li>目的: 比较 <code>新的树</code> 和 <code>旧的树</code></li></ol><blockquote><p>在新的树和旧的树头部插入指针, 尾部也插入指针, 进行双指针循环遍历比较</p></blockquote><ol start="2"><li>如何进行比较: </li></ol><p>假设,旧的DOM树和新的DOM树开头相同,指针从开头比较(针对元素新增在末尾,前面相同的DOM元素可以复用)<br>如果开头不一样的话,指针从尾部开始比较(针对元素新增在开头,后面相同的DOM元素可以复用)<br>如果尾部也不一样,会比较新的头和旧的尾(针对末尾的DOM元素移动到了开头)<br>要是也不一样,比较新的尾和旧的头(针对开始的DOM元素移动到了末尾)<br>都不一样,从开头开始遍历(从头开始遍历父级节点和子级节点)</p><p>详细的图片在底下,可以比较图片进行理解</p><ol start="3"><li>如何循环遍历: </li></ol><p>首先同级比较, 在比较子节点</p><blockquote><p>同级比较: 也就是父节点和父节点比较,子节点和子节点比较</p></blockquote><p>如果父级节点相同,再比较子节点</p><p>比较的时候,是这样判断的: </p><ul><li>新的有,旧的也有,使用旧的</li><li>新的有,旧的没有,插入新的</li><li>新的没有,旧的有,删除旧的</li><li>当比较父级的时候,判断子节点是否存在也是这样判断的,都存在的情况下,进行深入递归遍历</li></ul><p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/138-diff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="示例图片"></p><p>看看图片中的最后一条</p><p>假设 旧的数据为 ABCD , 新的数据为 CDME</p><p>由于都不满足比较的四点基本判断,所以直接从开头开始遍历</p><ol><li>首先判断新的DOM树的第一个’C’,发现旧的有,移动到第一个</li><li>然后判断新的DOM树的第二个’D’,发现旧的有,移动到第二个</li><li>再判断’M’和’E’,发现都没有,直接插入</li><li>最后将AB直接删除</li></ol><blockquote><p>这就是为什么v-for要用Key,不加的话会使用上面的diff算法进行暴力比对</p></blockquote><p>知道了大致的流程,我们再去源码中看看具体的代码是怎么实现的(源码的位置在core/vdom/patch.js中)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">const oldCh &#x3D; oldVnode.children &#x2F;&#x2F; 老的儿子 </span><br><span class="line">const ch &#x3D; vnode.children &#x2F;&#x2F; 新的儿子 </span><br><span class="line">if (isUndef(vnode.text)) &#123;</span><br><span class="line">  if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; &#x2F;&#x2F; 比较孩子        </span><br><span class="line">    if (oldCh !&#x3D;&#x3D; ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">  &#125; else if (isDef(ch)) &#123; &#x2F;&#x2F; 新的儿子有 老的没有        </span><br><span class="line">    if (isDef(oldVnode.text)) &#123;</span><br><span class="line">      nodeOps.setTextContent(elm, &#39;&#39;) &#x2F;&#x2F; 将老的清空   </span><br><span class="line">      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125; else if (isDef(oldCh)) &#123; &#x2F;&#x2F; 如果老的有新的没有 就删除        </span><br><span class="line">    removeVnodes(oldCh, 0, oldCh.length - 1)</span><br><span class="line">  &#125; else if (isDef(oldVnode.text)) &#123; &#x2F;&#x2F; 老的有文本 新的没文本</span><br><span class="line">    nodeOps.setTextContent(elm, &#39;&#39;) &#x2F;&#x2F; 将老的清空    </span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (oldVnode.text !&#x3D;&#x3D; vnode.text) &#123; &#x2F;&#x2F; 文本不相同替换   </span><br><span class="line">  nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">  let oldStartIdx &#x3D; 0</span><br><span class="line">  let newStartIdx &#x3D; 0</span><br><span class="line">  let oldEndIdx &#x3D; oldCh.length - 1</span><br><span class="line">  let oldStartVnode &#x3D; oldCh[0]</span><br><span class="line">  let oldEndVnode &#x3D; oldCh[oldEndIdx]</span><br><span class="line">  let newEndIdx &#x3D; newCh.length - 1</span><br><span class="line">  let newStartVnode &#x3D; newCh[0]</span><br><span class="line">  let newEndVnode &#x3D; newCh[newEndIdx]</span><br><span class="line">  let oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line">  &#x2F;&#x2F; removeOnly is a special flag used only by &lt;transition-group&gt;    </span><br><span class="line">  &#x2F;&#x2F; to ensure removed elements stay in correct relative positions    </span><br><span class="line">  &#x2F;&#x2F; during leaving transitions    </span><br><span class="line">  const canMove &#x3D; !removeOnly</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">    checkDuplicateKeys(newCh)</span><br><span class="line">  &#125;</span><br><span class="line">  while (oldStartIdx &lt;&#x3D; oldEndIdx &amp;&amp; newStartIdx &lt;&#x3D; newEndIdx) &#123;</span><br><span class="line">    if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode &#x3D; oldCh[++oldStartIdx] &#x2F;&#x2F; Vnode has been moved left     </span><br><span class="line">    &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode &#x3D; oldCh[++</span><br><span class="line">        oldStartIdx] newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode &#x3D; oldCh[--oldEndIdx] newEndVnode &#x3D;</span><br><span class="line">        newCh[--newEndIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; &#x2F;&#x2F; Vnode moved right        </span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(</span><br><span class="line">          parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode &#x3D; oldCh[++oldStartIdx] newEndVnode &#x3D;</span><br><span class="line">        newCh[--newEndIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; &#x2F;&#x2F; Vnode moved left        </span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(</span><br><span class="line">        parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode &#x3D; oldCh[--oldEndIdx] newStartVnode &#x3D; newCh[++</span><br><span class="line">        newStartIdx]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      if (isUndef(oldKeyToIdx)) oldKeyToIdx &#x3D; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld &#x3D; isDef(</span><br><span class="line">        newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx,</span><br><span class="line">        oldEndIdx) if (isUndef(idxInOld)) &#123; &#x2F;&#x2F; New element          </span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnodeToMove &#x3D; oldCh[idxInOld]</span><br><span class="line">        if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] &#x3D; undefined canMove &amp;&amp;</span><br><span class="line">            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; same key but different element. treat as new element           </span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm &#x3D; isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh,</span><br><span class="line">      newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125;</span><br><span class="line">  a</span><br><span class="line">  else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodes(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是我对diff算法的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;今天就是除夕了,也只有放假才有时间写一写博客,把欠下的博客都补上&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://www.chensheng.group/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://www.chensheng.group/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码学习-模板编译原理</title>
    <link href="https://www.chensheng.group/2020/11/08/137-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <id>https://www.chensheng.group/2020/11/08/137-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</id>
    <published>2020-11-08T07:26:00.000Z</published>
    <updated>2020-11-08T13:29:23.629Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>由于之前发生了一些事情,并且公司的项目也很赶,碰巧孩子出生了,所以忙的不可开交,,很久没有更新博客了,今天有时间,把欠下的博客都补上</p></blockquote><a id="more"></a><p>我们在学习Vue的时候,一直都说虚拟DOM,虚拟DOM,那么,什么是虚拟DOM,虚拟DOM又是怎么生成的呢?</p><p>虚拟DOM的生成大致上是分为这么几步的:</p><ol><li><p>template 通过正则转化为ast树</p></li><li><p>ast树通过codegen方法,转化为render函数</p></li><li><p>render函数,内部调用_c方法,( _c方法就是创建el) 转化为虚拟dom</p></li></ol><blockquote><p>用一个对象来描述一个DOM元素,这就是虚拟DOM</p></blockquote><p>知道了大致的流程,我们再去源码中看看具体的代码是怎么实现的(源码的位置在scr/compiler/index.js中)</p><p>首先,创建了一个编译器(createCompilerCreator),传入了一个 bsaeCompile函数,这个函数描述了模板是怎么转化成render函数的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function baseCompile(template: string, options: CompilerOptions) &#123;</span><br><span class="line">  const ast &#x3D; parse(template.trim(), options) &#x2F;&#x2F; 1.将模板转化成ast语法树  </span><br><span class="line">  if (options.optimize !&#x3D;&#x3D; false) &#123; &#x2F;&#x2F; 2.优化树    </span><br><span class="line">    optimize(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  const code &#x3D; generate(ast, options) &#x2F;&#x2F; 3.生成树  </span><br><span class="line">  return &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vue的源码看起来有点乱,上百度找了大神整理好的,看看bsaeCompile展开后,还做了哪些操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">const ncname &#x3D; &#96;[a-zA-Z_][\\-\\.0-9_a-zA-Z]*&#96;;</span><br><span class="line">const qnameCapture &#x3D; &#96;((?:$&#123;ncname&#125;\\:)?$&#123;ncname&#125;)&#96;;</span><br><span class="line">const startTagOpen &#x3D; new RegExp(&#96;^&lt;$&#123;qnameCapture&#125;&#96;); &#x2F;&#x2F; 标签开头的正则 捕获的内容是 标签名 </span><br><span class="line">const endTag &#x3D; new RegExp(&#96;^&lt;\\&#x2F;$&#123;qnameCapture&#125;[^&gt;]*&gt;&#96;); &#x2F;&#x2F; 匹配标签结尾的  &lt;&#x2F;div&gt; </span><br><span class="line">const attribute &#x3D; &#x2F;^\s*([^\s&quot;&#39;&lt;&gt;\&#x2F;&#x3D;]+)(?:\s*(&#x3D;)\s*(?:&quot;([^&quot;]*)&quot;+|&#39;([^&#39;]*)&#39;+| ([^\s&quot;&#39;&#x3D;&lt;&gt;&#96;]+)))?&#x2F;; &#x2F;&#x2F; 匹配属性的 </span><br><span class="line">const startTagClose &#x3D; &#x2F;^\s*(\&#x2F;?)&gt;&#x2F;; &#x2F;&#x2F; 匹配标签结束的  &gt; </span><br><span class="line">let root;</span><br><span class="line">let currentParent;</span><br><span class="line">let stack &#x3D; []</span><br><span class="line"></span><br><span class="line">function createASTElement(tagName, attrs) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    tag: tagName,</span><br><span class="line">    type: 1,</span><br><span class="line">    children: [],</span><br><span class="line">    attrs,</span><br><span class="line">    parent: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function start(tagName, attrs) &#123;</span><br><span class="line">  let element &#x3D; createASTElement(tagName, attrs);</span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    root &#x3D; element;</span><br><span class="line">  &#125;</span><br><span class="line">  currentParent &#x3D; element;</span><br><span class="line">  stack.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function chars(text) &#123;</span><br><span class="line">  currentParent.children.push(&#123;</span><br><span class="line">    type: 3,</span><br><span class="line">    text</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function end(tagName) &#123;</span><br><span class="line">  const element &#x3D; stack[stack.length - 1];</span><br><span class="line">  stack.length--;</span><br><span class="line">  currentParent &#x3D; stack[stack.length - 1];</span><br><span class="line">  if (currentParent) &#123;</span><br><span class="line">    element.parent &#x3D; currentParent;</span><br><span class="line">    currentParent.children.push(element)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function parseHTML(html) &#123;</span><br><span class="line">  while (html) &#123;</span><br><span class="line">    let textEnd &#x3D; html.indexOf(&#39;&lt;&#39;);</span><br><span class="line">    if (textEnd &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      const startTagMatch &#x3D; parseStartTag();</span><br><span class="line">      if (startTagMatch) &#123;</span><br><span class="line">        start(startTagMatch.tagName, startTagMatch.attrs);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      const endTagMatch &#x3D; html.match(endTag);</span><br><span class="line">      if (endTagMatch) &#123;</span><br><span class="line">        advance(endTagMatch[0].length);</span><br><span class="line">        end(endTagMatch[1])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let text;</span><br><span class="line">    if (textEnd &gt;&#x3D; 0) &#123;</span><br><span class="line">      text &#x3D; html.substring(0, textEnd)</span><br><span class="line">    &#125;</span><br><span class="line">    if (text) &#123;</span><br><span class="line">      advance(text.length);</span><br><span class="line">      chars(text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function advance(n) &#123;</span><br><span class="line">    html &#x3D; html.substring(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function parseStartTag() &#123;</span><br><span class="line">    const start &#x3D; html.match(startTagOpen);</span><br><span class="line">    if (start) &#123;</span><br><span class="line">      const match &#x3D; &#123;</span><br><span class="line">        tagName: start[1],</span><br><span class="line">        attrs: []</span><br><span class="line">      &#125;</span><br><span class="line">      advance(start[0].length);</span><br><span class="line">      let attr, end</span><br><span class="line">      while (!(end &#x3D; html.match(startTagClose)) &amp;&amp; (attr &#x3D; html.match(attribute))) &#123;</span><br><span class="line">        advance(attr[0].length);</span><br><span class="line">        match.attrs.push(&#123;</span><br><span class="line">          name: attr[1],</span><br><span class="line">          value: attr[3]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      if (end) &#123;</span><br><span class="line">        advance(end[0].length);</span><br><span class="line">        return match</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 生成语法树 </span><br><span class="line">parseHTML(&#96;&lt;div id&#x3D;&quot;container&quot;&gt;&lt;p&gt;hello&lt;span&gt;zf&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&#96;);</span><br><span class="line"></span><br><span class="line">function gen(node) &#123;</span><br><span class="line">  if (node.type &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    return generate(node);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &#96;_v($&#123;JSON.stringify(node.text)&#125;)&#96;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genChildren(el) &#123;</span><br><span class="line">  const children &#x3D; el.children;</span><br><span class="line">  if (el.children) &#123;</span><br><span class="line">    return &#96;[$&#123;children.map(c&#x3D;&gt;gen(c)).join(&#39;,&#39;)&#125;]&#96;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genProps(attrs) &#123;</span><br><span class="line">  let str &#x3D; &#39;&#39;;</span><br><span class="line">  for (let i &#x3D; 0; i &lt; attrs.length; i++) &#123;</span><br><span class="line">    let attr &#x3D; attrs[i];</span><br><span class="line">    str +&#x3D; &#96;$&#123;attr.name&#125;:$&#123;attr.value&#125;,&#96;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#96;&#123;attrs:&#123;$&#123;str.slice(0,-1)&#125;&#125;&#125;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function generate(el) &#123;</span><br><span class="line">  let children &#x3D; genChildren(el);</span><br><span class="line">  let code &#x3D; &#96;_c(&#39;$&#123;el.tag&#125;&#39;$&#123;el.attrs.length?&#96;,$&#123;genProps(el.attrs)&#125;&#96;:&#39;&#39;&#125;$&#123;children? &#96;,$&#123;children&#125;&#96;:&#39;&#39;&#125;)&#96;;</span><br><span class="line">  return code;</span><br><span class="line">&#125; &#x2F;&#x2F; 根据语法树生成新的代码 </span><br><span class="line">let code &#x3D; generate(root);</span><br><span class="line">let render &#x3D; &#96;with(this)&#123;return $&#123;code&#125;&#125;&#96;;</span><br><span class="line">&#x2F;&#x2F; 包装成函数 </span><br><span class="line">let renderFn &#x3D; new Function(render);</span><br><span class="line">console.log(renderFn.toString());</span><br></pre></td></tr></table></figure><p>假设我们的template里面写了这个 <code>&lt;div id=&quot;container&quot;&gt;&lt;p&gt;hello&lt;span&gt;zf&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;</code></p><p>通过parseHTML函数,循环遍历里面的每一个字符串,判断是否为’&lt;’</p><blockquote><p>每次循环判断完之后,都会删除对应的长度</p></blockquote><p>匹配到了<code>&lt;div</code>后,生成一个对象,将’div’放入了tagName中,可能div会有属性,也生成一个attrs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 就是上面代码中的这一段 --&gt;</span><br><span class="line">const match &#x3D; &#123;</span><br><span class="line">  tagName: start[1],</span><br><span class="line">  attrs: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后会继续循环匹配,看看是否是 ‘&gt;’ 关闭标签,如果不是的话,继续循环</p><p>循环到了是一个 <code>id=&quot;container&quot;</code>,根据正则来判断是否是属性,放入了<code>attrs</code>中</p><p>再次循环匹配到是一个 ‘&gt;’ 关闭标签,返回这个对象</p><p>这时候字符串已经剩下这样的了 <code>&lt;p&gt;hello&lt;span&gt;zf&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;</code>, 前面的<code>&lt;div id=&quot;container&quot;&gt;</code> 都已经判断处理完了</p><p>再一次判断到是’&lt;’后,重复上面的操作</p><p>不一样的是,p标签中是一个’hello’字符串,通过正则判断后,是将这个hello传入chars中,代码中也有,就不写出来了</p><p>通过这样一步一步的循环遍历判断,最终会生成一个完整的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: &quot;div&quot;</span><br><span class="line">  type: 1,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    tag: &quot;p&quot;</span><br><span class="line">    type: 1,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      type: 3</span><br><span class="line">      text: &quot;hello&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      tag: &quot;span&quot;</span><br><span class="line">      type: 1,</span><br><span class="line">      children: [&#123;</span><br><span class="line">        type: 3</span><br><span class="line">        text: &quot;zf&quot;</span><br><span class="line">      &#125;],</span><br><span class="line">      attrs: [],</span><br><span class="line">      parent: &#39;&#39; &#x2F;&#x2F; 父级</span><br><span class="line">    &#125;],</span><br><span class="line">    attrs: [],</span><br><span class="line">    parent: &#39;&#39; &#x2F;&#x2F; 父级</span><br><span class="line">  &#125;],</span><br><span class="line">  attrs: [&#123;</span><br><span class="line">    name: &quot;id&quot;</span><br><span class="line">    value: &quot;container&quot;</span><br><span class="line">  &#125;],</span><br><span class="line">  parent: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以用一个对象来描述一个DOM元素</p><p>以上就是我对vue模板编译的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;由于之前发生了一些事情,并且公司的项目也很赶,碰巧孩子出生了,所以忙的不可开交,,很久没有更新博客了,今天有时间,把欠下的博客都补上&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://www.chensheng.group/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://www.chensheng.group/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用Valine评论</title>
    <link href="https://www.chensheng.group/2020/07/29/136-hexo%E4%BD%BF%E7%94%A8Valine%E8%AF%84%E8%AE%BA/"/>
    <id>https://www.chensheng.group/2020/07/29/136-hexo%E4%BD%BF%E7%94%A8Valine%E8%AF%84%E8%AE%BA/</id>
    <published>2020-07-29T13:19:00.000Z</published>
    <updated>2021-09-03T06:54:41.233Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>关于这个评论系统,前前后后换了三四个,今天又换了一个,哎,评论又要被清空了</p></blockquote><a id="more"></a><p>最早使用的是来必力的,还不错,就是有点卡顿,还需要登录,后来不知道怎么回事,用不来了,就换了一个 </p><p>之后就换成了畅言,也是一个不错的评论系统,但是会给博客塞一些广告,一气之下,又换了一个</p><p>换成了git官方的一个插件,gitalk,可以在git仓库中看到评论,但是也是需要git登录之后才可以评论</p><p>于是换成了现在的Valine</p><p>Valine用的是LeanCloud作为数据,所以我们需要先打开LeanCloud去注册LeanCloud并创建一个开发版应用（免费）</p><p><a href="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener">戳我戳我,一键跳转</a></p><p>之后在LeanCloud -&gt; 存储 -&gt; 创建Class -&gt; 无限制的Class, class名称为：Comment</p><p>在LeanCloud-设置-把除数据存储其他选项都关闭。</p><p>然后再底下的安全域名中添加域名</p><p>之后在Next模板下的_config.yml搜索Valine进行填写appid和appkey</p><p>OK了,大功告成,就是这么简单,图我就不放出来了,相信大家都能找得到</p><p>感叹代码的进步,换评论系统一次比一次简单了,当初换个畅言评论,折腾了许久,又要备案,又要审核</p><p>哪里不懂的就在评论中提出来,我会不定时的看一看</p>]]></content>
    
    <summary type="html">
    
      &lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;关于这个评论系统,前前后后换了三四个,今天又换了一个,哎,评论又要被清空了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://www.chensheng.group/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://www.chensheng.group/tags/hexo/"/>
    
  </entry>
  
</feed>
