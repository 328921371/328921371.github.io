<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>javaScript 数据类型</title>
    <url>/2016/07/11/01-javaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>接触javaScript有一段时间了,今天来讲一下javaScript中的数据类型都有哪些</p>
</blockquote>
<a id="more"></a>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>javaScript 中有六大数据类型:</p>
<ul>
<li>object   (对象)</li>
<li>number   (数字)</li>
<li>string   (字符串)</li>
<li>blooean  (布尔)</li>
<li>Null     (空)</li>
<li>undefined(未定义)</li>
</ul>
<p>其中 javaScript还分为了基本数据类型和引用类型,在这里不详细的展开,我在接下来的博客中会进行详细的讲述</p>
<h3 id="数据类型的隐式转化"><a href="#数据类型的隐式转化" class="headerlink" title="数据类型的隐式转化"></a>数据类型的隐式转化</h3><p>javaScript中的隐式转化也是很有趣的一个地方,打个比方,我定义了一个字符串的变量,<br>再定义一个Number类型的变量 ,进行比较,结果却是true</p>
<pre><code>var a = &apos;123&apos; ;

var b = 123;

a == b //true</code></pre><p>这是因为javaScript执行时将String转化为了Number类型,再进行判断,这样的隐式转化还有很多,<br>布尔类型转化Number都是可以的</p>
<pre><code>true == 1;
false == 0;</code></pre><p>隐式转化还有个值得注意的地方在于 + 号 与 - 号</p>
<pre><code>var a = &apos;100&apos;,
var b = 50

a + b // 10050
a - b // 50</code></pre><p>这是因为,在执行 + 号的时候, 变量a为字符串类型,所以执行的字符串的拼接,但是在js的代码中,-被认定<br>为减法运算,所以会自动将变量a转化为Number类型,并进行运算</p>
<h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>包装对象这一特性在javaScript中也是值得一提的,大家都知道对象是可以进行打点调用或赋值的,那字符串可以吗,<br>我们可以做一个测试</p>
<pre><code>var a = &quot;string&quot;;
console.log(a.t = 3); // 3
console.log(a.t); // undefined</code></pre><p>正所谓在H5中,一切皆为对象,把一个基本类型尝试用对象的方式使用它的时候,javascript会把这些基本类型转化为对应的包装类型对象完成这样一个操作以后，这个临时对象会被销毁掉。所以a.t赋值3了以后,再去输出a.t值是undefined。</p>
<h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p>typeof 和 instanceof 都可以进行类型检测,typeof就不进行细讲了,来说一下instanceof</p>
<p>它基于原型链操作。obj instanceof Object。</p>
<p>左边的操作数为对象，不是就返回false,右操作数必须是函数对象或者函数构造器,因为只有函数才有prototype这个属性,不是会爆出typeError异常。</p>
<p>原理：判断左边的左操作数的对象的原型链上是否有右边这个构造函数的prototype属性。原型链和构造函数我在后面会<br>进行细讲</p>
<p>注意一个坑:不同window或iframe之间的对象类型检测不能使用instanceof！</p>
<h3 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h3><p>我这里简单的介绍一下常用的类型转化</p>
<ol>
<li><p>将字符串类型转化为number的类型<br> str = Number(str);</p>
</li>
<li><p>number类型转化为string类型<br> a = a.toString()<br> a =    String(a)</p>
</li>
<li><p>布尔类型转化为number<br> var y = false;<br> y = Number(y);</p>
</li>
<li><p>把数字格式化为指定的长度;会四舍五入<br> i = i.toPrecision(3)</p>
</li>
<li><p>将数字转化为字符串,保留几位小数,不够的用0补位<br> i = i.toFixed(1);</p>
</li>
</ol>
<p>前端会经常进行数据的交互和处理,所以Number的转化是用到最多的,这里详细的介绍一下</p>
<p>Number()函数的转换规则如下：</p>
<ul>
<li><p>如果是Boolean值，true和false将分别被替换为1和0</p>
</li>
<li><p>如果是数字值，只是简单的传入和返回</p>
</li>
<li><p>如果是null值，返回0</p>
</li>
<li><p>如果是undefined，返回NaN</p>
</li>
<li><p>如果是字符串，遵循下列规则：</p>
<ul>
<li><p>如果字符串中只包含数字，则将其转换为十进制数值，即”1“会变成1，”123“会变成123，而”011“会变成11（前导的0被忽略）</p>
</li>
<li><p>如果字符串中包含有效的浮点格式，如”1.1“，则将其转换为对应的浮点数（同样，也会忽略前导0）</p>
</li>
<li><p>如果字符串中包含有效的十六进制格式，例如”0xf“，则将其转换为相同大小的十进制整数值</p>
</li>
<li><p>如果字符串是空的，则将其转换为0</p>
</li>
<li><p>如果字符串中包含除了上述格式之外的字符，则将其转换为NaN</p>
</li>
<li><p>如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再依次按照前面的规则转换返回的字符串值。</p>
</li>
</ul>
</li>
</ul>
<p>javaScript 的数据类型就讲到这里了,如果有错误,欢迎各位大牛指出,感激不尽</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>引用对象的复制</title>
    <url>/2016/09/11/02-%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>之前讲到了javaScript的类型分为基本类型和引用类型,今天分享一下我的学习心得,引用类型应该怎样正确的复制</p>
</blockquote>
<a id="more"></a>

<h3 id="javaScript-变量类型"><a href="#javaScript-变量类型" class="headerlink" title="javaScript 变量类型"></a>javaScript 变量类型</h3><p>之前学习的过程中有提到过javascript的变量类型分为 基本类型和引用类型,这两个具体有什么区别了?</p>
<p>基本类型:存放在栈中，基本类型直接储存的是数值</p>
<p>引用类型：存放在堆中，引用类型储存的是数据的内存地址(我们拿到手的变量其实就是一个指针)</p>
<h3 id="变量复制的问题"><a href="#变量复制的问题" class="headerlink" title="变量复制的问题"></a>变量复制的问题</h3><p>只是讲概念性的东西并不能真正的了解到 基本类型 和 引用类型在使用上面的区别,我做一个简单的例子,变量的复制</p>
<p>变量的复制分为两种情况：基本类型的复制 和 引用类型的复制</p>
<h4 id="基本类型的复制"><a href="#基本类型的复制" class="headerlink" title="基本类型的复制:"></a>基本类型的复制:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>这里我们会发现,将a的值赋值给b后再修改b的值,并不会影响a的值,一切使用正常.</p>
<h4 id="引用类型的复制"><a href="#引用类型的复制" class="headerlink" title="引用类型的复制:"></a>引用类型的复制:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">	name:&#39;张三&#39;</span><br><span class="line">&#125;</span><br><span class="line">var obj2 &#x3D; obj1;</span><br><span class="line"></span><br><span class="line">obj2.name &#x3D; &#39;李四&#39;;</span><br><span class="line"></span><br><span class="line">console.log(obj1.name); &#x2F;&#x2F; 李四</span><br><span class="line">console.log(obj2.name); &#x2F;&#x2F; 李四</span><br></pre></td></tr></table></figure>

<p>我们会很奇怪的发现,明明修改的是obj2的值,为什么obj1的值也会发生改变,这就是之前所说的,引用类型储存的是数据的内存地址</p>
<p>通过上面的讨论，得到了两个结论 :</p>
<ol>
<li>基本类型是直接操作 值</li>
<li>引用类型直接操作的是 : 内存地址</li>
</ol>
<p>那要如何解决引用类型复制的问题了??</p>
<h3 id="工厂模式与构造函数"><a href="#工厂模式与构造函数" class="headerlink" title="工厂模式与构造函数"></a>工厂模式与构造函数</h3><p>解决引用类型复制的问题可以通过两种方法,工厂模式与构造函数</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式,顾名思义就是类似于工厂的生产模式,分为三大步</p>
<ol>
<li><p>原型 – var obj = new Object();</p>
</li>
<li><p>加工 – obj.属性或方法</p>
</li>
<li><p>出厂 – return obj;</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	obj.name = name;</span><br><span class="line">	obj.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'你好'</span> )</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = createObject(<span class="string">'对象1'</span>);</span><br><span class="line"><span class="keyword">var</span> obj2 = createObject(<span class="string">'对象2'</span>);</span><br></pre></td></tr></table></figure>

<p>这时候再去修改 obj2 , obj1就不会发生改变了,有几个地方需要注意的(踩了一个大坑):</p>
<p>我们再创建一个 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = &#123;</span><br><span class="line">	name:<span class="string">'狗'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先,obj.fun 的这个方法中,不要去使用obj.name,因为在js中,一个对象的方法可以被其他的对象所调用,<br>可以通过call、apple 就能实现,如果这里写obj.name,那么obj1.fun.call(dog);输出的结果仍然是obj1的信息,<br>所以应该使用this,这里的this指向调用该方法的本身,谁调用就是谁</p>
<p>call、apple 具体的使用下次再说,这里只是作为了解</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ol>
<li><p>默认函数首字母大写</p>
</li>
<li><p>构造函数并没有显示返回任何东西。new 操作符会自动创建给定的类型并返回他们，当调用构造函数时，new会自动创建this对象，且类型就是构造函数类型。</p>
</li>
<li><p>也可以在构造函数中显示调用return.如果返回的值是一个对象，它会代替新创建的对象实例返回。如果返回的值是一个原始类型，它会被忽略，新创建的实例会被返回。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'你好'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> People(<span class="string">'小明'</span>);</span><br></pre></td></tr></table></figure>

<p>这样是一个基本的构造函数,一样可以解决引用对象的复制问题,但是像fun这样的函数,相同的属性容易占内存,所以写在公共的区域: 原型(protoType)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">People.prototype.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name + <span class="string">': 汪汪汪!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样数据就存在protoType里，调用是可以直接打点调用, 原型(protoType) 之后再和大家分享</p>
<p>以上就是个人的学习心得,感谢各位大神指出错误和不足</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>数据类型</tag>
        <tag>构造函数</tag>
        <tag>对象复制</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与构造函数的继承</title>
    <url>/2016/09/15/03-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>构造函数 与 原型 一直是继承的一个重点,原型也是javaScript的一个特色 , 今天和大家分享一下构造函数的继承,以及函数中原型的概念</p>
</blockquote>
<a id="more"></a>

<h3 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h3><p>在说构造函数之前,我们先来探讨一下我们之前博客中提到的原型, 什么是原型?</p>
<p>在JavaScript中,通过原型可以实现对象的属性继承,这时候就有一个问题,我们没有定义原型,原型是怎么来的?<br>之前说过,在H5中,一切皆为对象,所以函数也是一种对象,javascript默认的给函数一个属性——prototype。<br>这个prototype的属性值是一个对象（属性的集合，再次强调！）,默认的只有一个叫做constructor的属性,指向这个函数本身。</p>
<p>注意这个prototype属性,这是只有函数才拥有的,其他的对象也有原型使用的是(<em>proto</em>)</p>
<h3 id="原型上填写共有的属性和方法"><a href="#原型上填写共有的属性和方法" class="headerlink" title="原型上填写共有的属性和方法"></a>原型上填写共有的属性和方法</h3><p>共有的属性和方法都放在原型里,这样不会占用太多的内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function Dog(name)&#123;</span><br><span class="line">	this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;对这个构造函数的原型进行重新定义,把原来的去掉,注意:会把构造函数一起去掉</span><br><span class="line">Dog.prototype &#x3D; &#123;</span><br><span class="line">	family:&quot;金毛&quot;,</span><br><span class="line">	jiao:function ()&#123;</span><br><span class="line">		alert(this.name + &#39;汪汪汪&#39;);</span><br><span class="line">	&#125;,</span><br><span class="line">	construction:Dog</span><br><span class="line">	&#x2F;&#x2F;因为原型中缺少呢一个构造函数,所以我们自己加</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Dog.prototype.construction &#x3D; Dog; 这样也可以添加构造函数</span><br></pre></td></tr></table></figure>

<p>这样就实现了在原型上填写共有的属性和方法,当然,原型也有他自己的缺点:</p>
<blockquote>
<p>修改一个地方，任何一个基于该构造函数的对象都会发生改变,所以原型不能进行值的传递</p>
</blockquote>
<h4 id="原型的小知识点"><a href="#原型的小知识点" class="headerlink" title="原型的小知识点"></a>原型的小知识点</h4><p>关于对象调用属性和方法的顺序,先在自身对象(构造函数)中去找,一直往上,找到直接调用;</p>
<p>isPrototypeOf() 判断原型和对象之间的关系<br>hasOwnProperty() 对象和属性,方法 之间是否存在关系,该属性,方法 必须是自身的(原型中的不算)</p>
<h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3><p>继承: 基类(父类)—-&gt;派生类,拓展类(子类)<br>特点: 不仅可以有自己的属性和方法,而且还可以拥有父类的所有属性和方法.并且可以增加自己新的属性和方法</p>
<p>构造函数的继承我把它称之为三步曲:</p>
<p>第一步：构造函数的继承<br>第二步:原型的继承<br>第三步:自身构造函数的创建</p>
<p>我们来看一个例子,假设我有个Animal这个类,并且我想让Dog类来继承它,应该怎么实现?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;先创建一个构造函数(这个构造函数作为父类)</span><br><span class="line">function Animal(family)&#123;</span><br><span class="line">	this.family &#x3D; family;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;给构造函数的原型加入属性(为了验证子类是否可以继承父类)</span><br><span class="line">Animal.prototype.leg &#x3D;4;</span><br><span class="line"></span><br><span class="line">function Dog(family,name)&#123;</span><br><span class="line">&#x2F;&#x2F;第一步：构造函数的继承(使用.call来继承构造函数)</span><br><span class="line">	Animal.call(this,family);</span><br><span class="line">	this.name &#x3D; name; &#x2F;&#x2F;这是声明子类私有的属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二步:原型的继承，这里将Dog的原型全部替换成Animal的原型,注意:构造函数会被删除</span><br><span class="line"></span><br><span class="line">Dog.prototype &#x3D; Object.create(Animal.prototype);</span><br><span class="line"></span><br><span class="line">&#x2F;* Object.create(Animal.prototype)创建出来的是一个空的对象,并且空对象的原型是Animal的原型</span><br><span class="line">所以我们就可以把空的对象作为Dog的原型	*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第三步:Dog构造函数的创建</span><br><span class="line">Dog.prototype.constructor &#x3D; Dog;</span><br></pre></td></tr></table></figure>

<p>到这里,就将原型和属性全部继承,在第一步中使用到的call,我简单的说明一下</p>
<h3 id="apply-和-call方法的区别"><a href="#apply-和-call方法的区别" class="headerlink" title="apply 和 call方法的区别"></a>apply 和 call方法的区别</h3><p>call,apply都是属于function.prototype 的一个方法<br>call,apply 作用就是借用别人的方法来调用，就像在调用自己的方法一样</p>
<p>相同点：两个方法产生的作用是完全一样的<br>不同的：方法传递的参数不同</p>
<p>举个简单的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function print (a,b,c,d)&#123;</span><br><span class="line">	alert(a + b + c + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function example(a,b,c,d)&#123;</span><br><span class="line"></span><br><span class="line">	print.call(this,a,b,c,d);&#x2F;&#x2F;用call方式借用print,参数是打散传递的</span><br><span class="line"></span><br><span class="line">	print.apply(this,arguments);</span><br><span class="line">	&#x2F;&#x2F;用apply方式借用print，参数作为一个数组传递的,这里用的是JavaScript方法内本身有的arguments数组</span><br><span class="line"></span><br><span class="line">	print.apply(this,[a,b,c,d]);</span><br><span class="line">	&#x2F;&#x2F;这样也可以</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ES6的继承"><a href="#ES6的继承" class="headerlink" title="ES6的继承"></a>ES6的继承</h3><p>现在来看看另外一种继承方式,ES6的继承</p>
<p>一、ES6的新继承方法</p>
<p>假设我有个People的父类,想要创建一个Man的子类去继承People</p>
<p>extends :  继承的关键字，这里相当于Man这个构造函数继承了People</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Man extends People&#123;</span><br><span class="line"></span><br><span class="line">	constructor(name,age,sex)&#123;</span><br><span class="line">		&#x2F;&#x2F; super : 就相当于会自动去执行 People 的构造函数,继承父类</span><br><span class="line">		super(name,age);</span><br><span class="line"></span><br><span class="line">		this.sex &#x3D; sex;&#x2F;&#x2F; 新增,扩展自己的属性</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;这里是Man这个构造函数的新方法</span><br><span class="line">	playMJ()&#123;</span><br><span class="line">		console.log(this.name + &#39;正在运动&#39;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var man &#x3D; new Man(&#39;小黄&#39;,18,&#39;男&#39;);&#x2F;&#x2F;这里实例化的man，可以调用People的方法</span><br></pre></td></tr></table></figure>

<p>ES6 的构造函数用法还是很简单的,注意extends 与 super 的用法</p>
<p>以上就是我对构造函数的继承及原型的一些理解,不足之处还望提出,感激不尽</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>构造函数</tag>
        <tag>原型</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链</title>
    <url>/2016/09/20/04-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>在之前的博客中有分享过原型的概念，但是绝对原型和原型链还是容易混淆，所以再深入的研究一下</p>
</blockquote>
<a id="more"></a>

<h3 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h3><p>在说构造函数之前,我们先来探讨一下我们之前博客中提到的原型, 什么是原型?</p>
<p>在JavaScript中,通过原型可以实现对象的属性继承,这时候就有一个问题,我们没有定义原型,原型是怎么来的?<br>之前说过,在H5中,一切皆为对象,所以函数也是一种对象,javascript默认的给函数一个属性——prototype。<br>这个prototype的属性值是一个对象（属性的集合，再次强调！）,默认的只有一个叫做constructor的属性,指向这个函数本身。</p>
<p>注意这个prototype属性,这是只有函数才拥有的,其他的对象也有原型使用的是(<em>proto</em>)</p>
<h3 id="prototype-与-proto-的区别"><a href="#prototype-与-proto-的区别" class="headerlink" title="prototype 与 proto 的区别"></a>prototype 与 <em>proto</em> 的区别</h3><p>就像之前说的一样， prototype是函数才有的属性，而_proto_是每个对象都有的属性，但_proto_不是一个规范的属性，只是部分的浏览器实现了此属性</p>
<p>我举个简单的例子：</p>
<pre><code>Person（这是一个构造函数）  --- prototype---&gt;  Person.prototype（原型）

person（构造函数初始化的对象）--- _proto_ ---&gt; Person.prototype（原型）</code></pre><p>这就是prototype与_proto_不同的用法</p>
<h3 id="原型链的概念"><a href="#原型链的概念" class="headerlink" title="原型链的概念"></a>原型链的概念</h3><p>为什么会产生原型链？是因为原型本身也是一个对象，它也有自身的_proto_属性，这样的链式结构，就组成了一个原型链，并且最终会指向Null</p>
<p>其实只要弄懂_proto_属性指向谁，原型链就很好理解了</p>
<p>这里附上一个小demo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var A &#x3D; function()&#123;&#125;;</span><br><span class="line">var a &#x3D; new A();</span><br><span class="line">console.log(a.__proto__); &#x2F;&#x2F;A &#123;&#125;（即构造器function A 的原型对象）</span><br><span class="line">console.log(a.__proto__.__proto__); &#x2F;&#x2F;Object &#123;&#125;（即构造器function Object 的原型对象）</span><br><span class="line">console.log(a.__proto__.__proto__.__proto__); &#x2F;&#x2F;null</span><br></pre></td></tr></table></figure>

<p>以上就是我对原型与原型链的一些理解,不足之处希望大牛们多提一些意见,感激不尽</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>This的指向问题与闭包</title>
    <url>/2016/09/24/05-This%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>This的指向问题一直是JavaScript的一个容易混淆的地方，闭包与this的结合更是让人头晕，现在和大家分享一下我的学习过程</p>
</blockquote>
<a id="more"></a>

<h3 id="This的用法"><a href="#This的用法" class="headerlink" title="This的用法"></a>This的用法</h3><p>总结起来比较常用的在三个地方</p>
<h4 id="全局中"><a href="#全局中" class="headerlink" title="全局中"></a>全局中</h4><p>全局中，函数的调用，this基本都是指向window</p>
<h4 id="点击事件中"><a href="#点击事件中" class="headerlink" title="点击事件中"></a>点击事件中</h4><p>在点击事件中，this 指向的是当前触发事件的元素对象</p>
<h4 id="构造函数中"><a href="#构造函数中" class="headerlink" title="构造函数中"></a>构造函数中</h4><p>在构造函数中，this 表示的是正在初始化的对象本身</p>
<p>举个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name:<span class="string">'小强'</span>,</span><br><span class="line">	age: <span class="number">20</span>,</span><br><span class="line">	run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = obj.run;</span><br><span class="line">fun();<span class="comment">//这样子调用，this指向的是window</span></span><br><span class="line">obj.run();<span class="comment">//这样调用，this指向的是obj</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的作用有两个：让外部访问函数内部的变量、另一个就是让这些变量的值始终保持在内存中。</p>
<p>实现的方法,在函数的内部在声明一个函数,返回这个函数,就可以获取到外部的变量，举个简单的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function f1()&#123;</span><br><span class="line">  var n&#x3D;999;</span><br><span class="line">  nAdd&#x3D;function()&#123;n+&#x3D;1&#125;</span><br><span class="line">  function f2()&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result&#x3D;f1();</span><br><span class="line">result(); &#x2F;&#x2F; 999</span><br><span class="line">nAdd();</span><br><span class="line">result(); &#x2F;&#x2F; 1000</span><br></pre></td></tr></table></figure>

<p>也就是说，当内部函数的作用域，被外部引用时，就创建了该内部函数的闭包，如果内部函数引用了位于外部函数的变量，当外部函数调用完毕后，这些变量在内存中不会被释放，因为闭包需要他们</p>
<p>有两个比较经典的关于this的指向与闭包的小demo，也和大家分享一下，如果知道了原理，this的指向就不再困扰你了</p>
<blockquote>
<p>第一题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var object &#x3D; &#123;</span><br><span class="line">	name:&quot;My Object&quot;,</span><br><span class="line">	getNameFunc: function() &#123;</span><br><span class="line">		return function() &#123;</span><br><span class="line">			return this;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(object.getNameFunc()());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var name &#x3D; &quot;The Window&quot;;</span><br><span class="line">var object &#x3D; &#123;</span><br><span class="line">	name: &quot;My Object&quot;,</span><br><span class="line">	getNameFunc: function() &#123;</span><br><span class="line">		var that &#x3D; this;</span><br><span class="line">		return function() &#123;</span><br><span class="line">			return that.name;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(object.getNameFunc()());</span><br></pre></td></tr></table></figure>

<p>以上就是我对this指向的一些理解,不足之处希望大牛们多提一些意见,感激不尽</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>this</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript对象合并</title>
    <url>/2016/10/05/06-JavaScript%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>javaScript的对象合并也是一个比较重要的知识点，分为浅复制和深复制，现在和大家分享一下我的学习过程</p>
</blockquote>
<a id="more"></a>

<h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h3><p>在之前的博客中有提到过，由于对象赋值是实际上赋值地址，所以赋值后修改新对象，会导致原来的对象也被修改举个简单的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function externalCopy(original,current)&#123;</span><br><span class="line">	for(var i in original)&#123;</span><br><span class="line">		current[i] &#x3D; original[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3><p>解决这种问题常用的有两种方法</p>
<p>第一种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function deepCopy(original, current) &#123;&#x2F;&#x2F;这里传递两个对象，被复制的，复制的</span><br><span class="line">	for(var i in original)&#123;&#x2F;&#x2F;遍历要复制的对象</span><br><span class="line">		if(typeof original[i] &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;&#x2F;&#x2F;判断是否为引用类型</span><br><span class="line">			&#x2F;&#x2F;引用类型的话，数组就给一个新的[]，这样指向新地址，对象给&#123;&#125;</span><br><span class="line">			current[i] &#x3D; (Object.prototype.toString.call(original[i]) &#x3D;&#x3D;&#x3D; &quot;[object Array]&quot;) ? [] : &#123;&#125;;</span><br><span class="line">			&#x2F;&#x2F;这时候重新调用本身，也就是递归函数，将[]或&#123;&#125;传入到current这个参数，</span><br><span class="line">			&#x2F;&#x2F;original在上面重新循环，这时候循环的是他的属性值，实现值的复制</span><br><span class="line">			deepCopy(original[i], current[i]);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			&#x2F;&#x2F;基本类型直接复制</span><br><span class="line">			current[i] &#x3D; original[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  return current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种使用 $.extend()进行深复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var newobj &#x3D; $.extend(true,&#123;&#125;, obj1, obj2);</span><br></pre></td></tr></table></figure>

<p>以上就是我对对象复制的一些理解,不足之处希望大牛们多提一些意见,感激不尽</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>对象合并</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数组去重</title>
    <url>/2016/10/23/07-JavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>javaScript的数组去重有很多种方法，我分享一下我学习过程中的小demo</p>
</blockquote>
<a id="more"></a>

<p>原理比较简单，我直接在下面贴出例子</p>
<p>假设有一个arr1的数组</p>
<h3 id="去重代码"><a href="#去重代码" class="headerlink" title="去重代码"></a>去重代码</h3><p>第一种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function way1() &#123;</span><br><span class="line">   var newArr &#x3D; [];&#x2F;&#x2F;创建新数组</span><br><span class="line">   for(var i &#x3D; 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">		if(newArr.indexOf(arr1[i]) &#x3D;&#x3D; -1) &#123;&#x2F;&#x2F;判断是否有这个值</span><br><span class="line">			newArr.push(arr1[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(newArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">way2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> arr2 = arr1.sort();	<span class="comment">//对数组排序</span></span><br><span class="line">   <span class="keyword">var</span> res = [];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr2.length;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr2[i] !== res[res.length<span class="number">-1</span>])&#123;</span><br><span class="line">       res.push(arr2[i]);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setObj = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">	setObj.add(arr1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr4 = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> setObj)&#123;</span><br><span class="line">	arr4.push(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function way4(arr)&#123;</span><br><span class="line">   var res &#x3D;[];</span><br><span class="line">   var obj &#x3D; &#123;&#125;;</span><br><span class="line">   for(var i&#x3D;0;i&lt;arr1.length;i++)&#123;</span><br><span class="line">     if(!obj[arr1[i]])&#123;</span><br><span class="line">       res.push(arr1[i]);</span><br><span class="line">       obj[arr1[i]] &#x3D; 1;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function way5()&#123;</span><br><span class="line">   var arr&#x3D;[];</span><br><span class="line">   for(var i &#x3D; 0;i&lt;arr1.length;i++)&#123;</span><br><span class="line">     &#x2F;&#x2F;判断当前位置的数字首次出现的位置是不是当前的位置</span><br><span class="line">     if(arr1.indexOf(arr1[i]) &#x3D;&#x3D; i)&#123;</span><br><span class="line">       arr.push(arr1[i])</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(arr)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>第六种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function way6() &#123;</span><br><span class="line">   var r &#x3D; [];</span><br><span class="line">   for (var i &#x3D; 0;i &lt; arr1.length; i++) &#123;</span><br><span class="line">     for (var j &#x3D; i + 1; j &lt; arr1.length; j++)&#123;</span><br><span class="line">       if (arr1[i] &#x3D;&#x3D;&#x3D; arr1[j]) j &#x3D; ++i;</span><br><span class="line">     &#125;</span><br><span class="line">     r.push(arr1[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(r);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="去重原理"><a href="#去重原理" class="headerlink" title="去重原理"></a>去重原理</h3><p>我简单的说一下具体的原理</p>
<p>第一种:</p>
<p>创建一个空数组arr<br>用for循环<br>判断 arr indexOf (这里是要判断的数组的元素) == -1<br>如果是,就push进去</p>
<p>第二种:</p>
<p>先排序<br>    arr2[i] !== res[res.length-1]<br>判断前后是否一致<br>这里的res是新数组</p>
<p>第三种:</p>
<p>创建一个集合,将数组所有的都加入到集合中<br>    setObj.add(arr1[i]);</p>
<p>第四种:</p>
<p>创建空的[]和{}<br>将数组值当做{}的键<br>判断对象上是否有键<br>没有的话就在空数组push</p>
<p>第五种:</p>
<p>判断当前位置的数字首次出现的位置是不是当前的位置<br>    arr1.indexOf(arr1[i]) == i</p>
<p>第六种:</p>
<p>两个for循环进行判断<br>假如有个数组[1,2,5,2,4,3,1];</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr1.length; i++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr1.length; j++)&#123;</span><br><span class="line">       	<span class="keyword">if</span> (arr1[i] === arr1[j]) j = ++i;</span><br><span class="line">       &#125;</span><br><span class="line">       r.push(arr1[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遇到一样的数值时，就跳过判断下一个，没有的话第二个for循环会执行结束<br>这样就可以push进去了..[5,2,4,3,1]</p>
<p>以上就是我对数组去重的一些理解,不足之处希望大牛们多提一些意见,感激不尽</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title>artTemplate的基本语法</title>
    <url>/2016/10/30/08-template%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>比较了几款前端模版引擎，还是选择介绍一下artTemplate，它是前端用来渲染页面的，使用方便以及性能卓越，关于它的介绍以及性能大家可以移步<a href="http://cdc.tencent.com/?p=5723。" target="_blank" rel="noopener">http://cdc.tencent.com/?p=5723。</a></p>
</blockquote>
<a id="more"></a>

<p>我这里分享一下artTemplate基本的使用步骤（需要一定的NodeJs的基础，否则看的很吃力）</p>
<h3 id="artTemplate的使用步骤"><a href="#artTemplate的使用步骤" class="headerlink" title="artTemplate的使用步骤"></a>artTemplate的使用步骤</h3><h4 id="创建一个模板"><a href="#创建一个模板" class="headerlink" title="创建一个模板"></a>创建一个模板</h4><ol>
<li>创建模板需要使用script标签，并且 type要设置成text/html</li>
<li>创建模板是 script 标签必须设置id，才能使用模板</li>
<li>双花括号 表示引用模板数据对象，或者 template 内置的语法关键字</li>
</ol>
<h4 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> htmlstr = template(<span class="string">'templ'</span>, data);</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = htmlstr;</span><br></pre></td></tr></table></figure>

<p>参数1：需要使用的模板的ID<br>参数2：套用模板需要使用的数据（data是要传入的数据）</p>
<h3 id="模板套模板"><a href="#模板套模板" class="headerlink" title="模板套模板"></a>模板套模板</h3><p>artTemplate支持模板中再嵌套一个模板，使用 include ‘templ2’ value</p>
<h3 id="服务器端的模板"><a href="#服务器端的模板" class="headerlink" title="服务器端的模板"></a>服务器端的模板</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="built_in">require</span>(<span class="string">"art-template"</span>);</span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'如果没有index.html，就会执行这个接口'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//__dirname 为当前服务器的目录</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"绝对路径为： "</span> + __dirname);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//template 第一个参数是模板的路径，是绝对路径， 第二个参数是需要渲染的数据</span></span><br><span class="line"><span class="keyword">var</span> htmlStr = template(__dirname + <span class="string">'/tem/art1'</span>,data);<span class="comment">//这里将文件的html删掉,系统会默认寻找.art文件</span></span><br><span class="line"></span><br><span class="line">res.status(<span class="number">200</span>).send(htmlStr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>还有一种渲染的方法是较为简单的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> render = <span class="built_in">require</span>(<span class="string">'./views/art2'</span>)<span class="comment">//导入 art2 这里的render就是一个渲染的函数</span></span><br><span class="line"><span class="keyword">var</span> htmlStr = render(data)<span class="comment">//把数据当做参数传入进去，将数据渲染到模块上</span></span><br><span class="line">res.status(<span class="number">200</span>).send(htmlStr);</span><br></pre></td></tr></table></figure>

<p>以上就是我对artTemplate的理解，因为也在学习中，所以总结的不是很到位，希望大家有好的博客也可以和我分享</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>express请求处理管线</title>
    <url>/2016/11/15/09-express%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E7%AE%A1%E7%BA%BF/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>express是一个简洁而灵活的 node.js Web应用框架，这个要介绍起来太多了，现在的Node是越来越火了，今天就分享一下express请求处理管线的基本使用</p>
</blockquote>
<a id="more"></a>

<p>Node的代码及安装配置我就不贴出来了，这里将主要代码给分享一下</p>
<p>为什么要用到管线？研究问题通常要带着目的去研究，管线的作用是什么？简单的来说，javaScript的代码是以此执行的，在请求数据或其他工作时，有时候是需要依赖性的，所以管线的作用就体现出来了，通常是在请求之前，先执行管线中代码，再执行之后的代码，在工作中经常用在判断cookie的存在</p>
<h3 id="基本的管线处理"><a href="#基本的管线处理" class="headerlink" title="基本的管线处理"></a>基本的管线处理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求处理管线中的一个函数</span></span><br><span class="line"><span class="comment">// req: 请求对象    res：响应对象</span></span><br><span class="line"><span class="comment">// next : 下一个等待处理请求的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstFun</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(req.query);</span><br><span class="line">	<span class="comment">// 当前函数中的所有内容执行完后，可以进行回调下一个处理函数</span></span><br><span class="line">	next();</span><br><span class="line">&#125;</span><br><span class="line">多个函数可以写入数组中</span><br><span class="line">app.get(<span class="string">'/'</span>,[firstFun,secondFun],<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'请求成功了...'</span>);</span><br><span class="line">	res.send(<span class="string">'收到来自 / 的请求'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="处理请求响应数据的乱码问题"><a href="#处理请求响应数据的乱码问题" class="headerlink" title="处理请求响应数据的乱码问题"></a>处理请求响应数据的乱码问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">charSet</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// res.set()  设置响应头</span></span><br><span class="line">	<span class="comment">// res.set('头字段','值')    设置单一的响应头</span></span><br><span class="line">	<span class="comment">// res.set(&#123;'头字段': '值','头字段': '值'...&#125;) 批量设置响应头</span></span><br><span class="line">	<span class="comment">// Content-type ：设置响应数据内容类型，并且同时制定了编码格式(防止乱码)</span></span><br><span class="line">	res.set(<span class="string">'Content-type'</span>,<span class="string">'text/html;charset=utf-8'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'通用功能，设置响应头编码问题'</span>);</span><br><span class="line"></span><br><span class="line">	next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.use() ： 可以在默认处理管线(所有请求接口的处理管线)中</span></span><br><span class="line"><span class="comment">// 添加一个回调函数，每次请求都会先来执行默认管线中的回调</span></span><br><span class="line"><span class="comment">// 函数，然后再执行各自接口的处理管线中的回调函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(charSet);<span class="comment">//重点:!!!!!!!</span></span><br></pre></td></tr></table></figure>

<p>app.use(charSet)千万要记得写，踩了一次坑</p>
<h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/index/:age'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 获取参数的方法</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> name = req.query.name;</span><br><span class="line">	<span class="keyword">var</span> age = req.query.age;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后台获取客户端数据的方法</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *  1. 获取 url 中 ? 后面的参数 key=value</span></span><br><span class="line"><span class="comment">	 * 		get 请求的时候url后面的参数获取</span></span><br><span class="line"><span class="comment">	 *      通过 ： req.query.key</span></span><br><span class="line"><span class="comment">	 *  2. 获取请求体中的数据(通过 post 请求的时候才能这样做)</span></span><br><span class="line"><span class="comment">	 *     比如： req.body.key</span></span><br><span class="line"><span class="comment">	 * 	   如果是用 urlencoded 编码 就用 body-parser 模块</span></span><br><span class="line"><span class="comment">	 *     如果是用 mutipart/form-data 需要用 multer 模块</span></span><br><span class="line"><span class="comment">	 *  3. 获取请求头里面的数据</span></span><br><span class="line"><span class="comment">	 *     比如 req.get(key)</span></span><br><span class="line"><span class="comment">	 *  4. 获取 cookie 中的数据</span></span><br><span class="line"><span class="comment">	 *     比如 req.cookies.key 需要引入 cookie-parser</span></span><br><span class="line"><span class="comment">	 *  5. 获取 url 路径中的数据</span></span><br><span class="line"><span class="comment">	 *     比如 req.params.key</span></span><br><span class="line"><span class="comment">	 *     这种获取数据的方法在请求的时候需要这样去写 ： /index/20(数值)</span></span><br><span class="line"><span class="comment">	 *     将参数写在 path 中相对于把参数写到 ? 后面，更加</span></span><br><span class="line"><span class="comment">	 *     容易被用户和浏览器引擎识别，又被称为  友好的 url</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(req.params.age);</span><br><span class="line"></span><br><span class="line">	res.send(<span class="string">'收到来自 index 的请求'</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上就是我对express-请求处理管线的理解，因为也在学习中，所以总结的不是很到位，希望大家有好的博客也可以和我分享</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的流程</title>
    <url>/2016/12/02/10-webpack%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>最近开始学习webpack打包工具，和大家分享一下webpack的具体流程</p>
</blockquote>
<a id="more"></a>


<h3 id="Webpack是什么"><a href="#Webpack是什么" class="headerlink" title="Webpack是什么?"></a>Webpack是什么?</h3><ol>
<li><p>一个打包工具: 将所有的资源都打包成一个js文件</p>
</li>
<li><p>一个模块加载工具</p>
</li>
<li><p>将各种资源都可以当做模块来处理</p>
</li>
</ol>
<h3 id="对于模块的组织-通常有以下几种方法"><a href="#对于模块的组织-通常有以下几种方法" class="headerlink" title="对于模块的组织,通常有以下几种方法"></a>对于模块的组织,通常有以下几种方法</h3><ol>
<li><p>通过书写在不同文件中,使用 script 标签进行加载</p>
</li>
<li><p>通过CommonJS文件加载,如: nodeJS 就使用这种方式</p>
</li>
<li><p>AMD 进行加载, require.js 使用的就是这种方式</p>
</li>
<li><p>ES6模块 通过import export</p>
</li>
</ol>
<h3 id="Webpack的特点是什么"><a href="#Webpack的特点是什么" class="headerlink" title="Webpack的特点是什么?"></a>Webpack的特点是什么?</h3><ol>
<li><p>Webpack 是 以 CommonJS 的形式来进行编写脚本的,但是对 AMD / CMD 的支持也很全面的,方便<br>旧项目进行代码迁移</p>
</li>
<li><p>能被模块化的不仅仅是JS了</p>
</li>
<li><p>开发便捷,能够替代部分grunt/gulp 的工作, 比如 打包,压缩,混淆,图片转base64 等</p>
</li>
<li><p>扩展性强,插件机制完善</p>
</li>
</ol>
<blockquote>
<p>名词解释:<br>AMD 即异步模块加载机制,完整描述了模块的定义，依赖关系，引用关系以及加载机制<br>作为一个规范，只需定义其语法API，而不关心其实现。AMD规范简单到只有一个API，即define函数</p>
</blockquote>
<blockquote>
<p>CMD 命令行(Command Processor) 一般指命令提示符,命令提示符是在操作系统中，提示进行命令输入的一种工作提示符。</p>
</blockquote>
<blockquote>
<p>CommonJS 是一种规范，NodeJS是这种规范的实现。CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API<br>在兼容CommonJS的系统中，你可以实用JavaScript程序开发：</p>
</blockquote>
<h3 id="Webpack的安装"><a href="#Webpack的安装" class="headerlink" title="Webpack的安装"></a>Webpack的安装</h3><p>全局安装一个webpack</p>
<pre><code>npm install -g webpack</code></pre><h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><h4 id="生成-js-命令-将哪个js打包成哪个js"><a href="#生成-js-命令-将哪个js打包成哪个js" class="headerlink" title="生成 js 命令(将哪个js打包成哪个js)"></a>生成 js 命令(将哪个js打包成哪个js)</h4><blockquote>
<p>webpack ./entry.js bundle.js</p>
</blockquote>
<h4 id="将css-打包-成-js–需要安装-加载器-css加载器-与-style加载器"><a href="#将css-打包-成-js–需要安装-加载器-css加载器-与-style加载器" class="headerlink" title="将css 打包 成 js–需要安装 加载器(css加载器 与 style加载器)"></a>将css 打包 成 js–需要安装 加载器(css加载器 与 style加载器)</h4><p>并安装插件<br>npm install css-loader<br>npm install style-loader </p>
<pre><code>注意: 这里需要在入口文件导入css , require(&apos;style-loader!css-loader!./style.css&apos;);</code></pre><p>同样执行 webpack ./entry.js bundle.js</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li><p>配置文件名为: webpack.config.js 默认会找这个文件</p>
</li>
<li><p>打包命令 webpack</p>
</li>
</ol>
<blockquote>
<p>附上基本的 webpack.config.js 配置</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./entry.js'</span>,	<span class="comment">//	配置入口文件 (入口文件中可以导入其他js或css文件)(var content = require('./content.js') 和 require('./style.css');)</span></span><br><span class="line"></span><br><span class="line">    output: &#123;	<span class="comment">//	配置保存的路径</span></span><br><span class="line">        </span><br><span class="line">        path: __dirname,	<span class="comment">// 文件路径,__dirname 代表当前目录,当前文件所在的路径</span></span><br><span class="line">        </span><br><span class="line">        filename: <span class="string">'bundle.js'</span>	<span class="comment">// 打包后的文件名</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">module</span>: &#123;	<span class="comment">//模块部分</span></span><br><span class="line">    	</span><br><span class="line">        loaders: [	<span class="comment">// 加载器 可以配置多个</span></span><br><span class="line">            &#123;</span><br><span class="line">            	</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,	<span class="comment">//匹配以 .css 结尾的文件</span></span><br><span class="line">                </span><br><span class="line">                loaders: <span class="string">'style-loader!css-loader'</span>	<span class="comment">//指定加载的</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 配置web-dev-server</span></span><br><span class="line">		<span class="comment">// 第一种：iframe模式 顶部带一个黑条</span></span><br><span class="line">			<span class="comment">// 第二种：inline模块  不带黑条 true</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">	    inline: <span class="literal">false</span> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="服务器相关配置"><a href="#服务器相关配置" class="headerlink" title="服务器相关配置"></a>服务器相关配置</h3><blockquote>
<p>作用:  当文件发送变化时,会自动执行重新生成文件</p>
</blockquote>
<p>全局安装:<br>npm install webpack-dev-server -g</p>
<p>本地安装<br>npm install webpack-dev-server</p>
<p>服务器运行(会生成 127.0.0.1:8080– 打开就可以看到了)<br>webpack-dev-server</p>
<h3 id="ES6-转化-ES5"><a href="#ES6-转化-ES5" class="headerlink" title="ES6 转化 ES5"></a>ES6 转化 ES5</h3><h4 id="创建个文件夹，初始化一下，首先全局安装webpack"><a href="#创建个文件夹，初始化一下，首先全局安装webpack" class="headerlink" title="创建个文件夹，初始化一下，首先全局安装webpack"></a>创建个文件夹，初始化一下，首先全局安装webpack</h4><h4 id="安装babel"><a href="#安装babel" class="headerlink" title="安装babel"></a>安装babel</h4><pre><code>npm install --save-dev babel-core babel-preset-es2015  
npm install --save-dev babel-loader  </code></pre><h4 id="创建一个文件app-js，里面写入现在浏览器不全支持的es6代码"><a href="#创建一个文件app-js，里面写入现在浏览器不全支持的es6代码" class="headerlink" title="创建一个文件app.js，里面写入现在浏览器不全支持的es6代码"></a>创建一个文件app.js，里面写入现在浏览器不全支持的es6代码</h4><pre><code>let a = 111;  
let b = 222;  
var xxx = (c,d) =&gt; c*d;  
console.log(xxx(a,b));  </code></pre><h4 id="创建webpack配置文件"><a href="#创建webpack配置文件" class="headerlink" title="创建webpack配置文件"></a>创建webpack配置文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./app.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname,</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;  </span><br><span class="line">        loaders: [&#123;  </span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,  </span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,  </span><br><span class="line">            loader: <span class="string">'babel-loader'</span> ,</span><br><span class="line">            query: &#123;</span><br><span class="line">                presets: [<span class="string">'es2015'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>entry和output都是通用的配置，与ES6无关，这里不展开。<br>重点在loaders配置，loader和query一定要配置test配置指定了哪些是ES6代码,<br>可以指定一个文件夹,则所有源代码一定要放在该文件夹下,<br>或者用一个 正则表达式指定哪些是ES6代码。只有ES6代码，才会编译。</p>
</blockquote>
<h4 id="运行-webpack"><a href="#运行-webpack" class="headerlink" title="运行 webpack"></a>运行 webpack</h4><p>出现下面这些指令则运行成功</p>
<pre><code>function(module, exports) {  

&quot;use strict&quot;;  

var a = 111;  
var b = 222;  
var xxx = function xxx(c, d) {  
  return c * d;  
};  
console.log(xxx(a, b));  </code></pre><p>以上是webpack的基本流程，如果有不对的地方，欢迎提出，谢谢</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>大神们的惊人作品</title>
    <url>/2019/09/26/100-%E4%BC%98%E7%A7%80%E7%9A%84css%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>本篇是我的第一百篇博客,分享一下之前收藏的大神们的优秀作品,从中学习</p>
</blockquote>
<a id="more"></a>

<p>这个代码是我在逛知乎的时候,看到别人贴的代码</p>
<p>纯CSS实现，具有渐变倒影和3D旋转效果的栅栏动画，他的实现方式是：利用10个div元素创建10个栅条，接着再复制整份div元素，并创建一个渐变遮罩形成渐变效果，以此作为栅栏的倒影。</p>
<p><img src="https://pic2.zhimg.com/v2-1fe3a788dcbe790bd1f5d37ddab969d5_b.webp" alt="动态图"></p>
<h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;loader&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;loader loader--reflect&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Document defaults</span><br><span class="line"> *&#x2F;</span><br><span class="line">body &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  background-color: #eee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">  -webkit-box-sizing: border-box;</span><br><span class="line">     -moz-box-sizing: border-box;</span><br><span class="line">          box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* The loader container *&#x2F;</span><br><span class="line">.loader &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  </span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  </span><br><span class="line">  margin-top: -100px;</span><br><span class="line">  margin-left: -100px;</span><br><span class="line">  </span><br><span class="line">  perspective: 1000px;</span><br><span class="line">  transform-style: preserv3d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.loader--reflect &#123;</span><br><span class="line">  margin-top: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.loader--reflect:after &#123;</span><br><span class="line">  content: &#39;&#39;;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: -25%;</span><br><span class="line">  </span><br><span class="line">  width: 150%;</span><br><span class="line">  height: 110%;</span><br><span class="line">  </span><br><span class="line">  background: linear-gradient(0deg, rgba(238, 238, 238, 1), rgba(238, 238, 238, 1) 20%, rgba(238, 238, 238, 0.3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* The bar *&#x2F;</span><br><span class="line">.bar &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line"></span><br><span class="line">  width: 20px;</span><br><span class="line">  height: 100px;</span><br><span class="line"></span><br><span class="line">  background-color: #1e3f57;</span><br><span class="line">  </span><br><span class="line">  transform: scaleY(0);</span><br><span class="line">  transform-style: preserve3d;</span><br><span class="line"></span><br><span class="line">  animation: bar 3s cubic-bezier(.81,.04,.4,.7) infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bar:nth-child(2) &#123;</span><br><span class="line">  left: 20px;</span><br><span class="line">  </span><br><span class="line">  background-color: #264a63;</span><br><span class="line">  </span><br><span class="line">  animation-delay: 50ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bar:nth-child(3) &#123;</span><br><span class="line">  left: 40px;</span><br><span class="line">  </span><br><span class="line">  background-color: #2d566f;</span><br><span class="line">  </span><br><span class="line">  animation-delay: 100ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bar:nth-child(4) &#123;</span><br><span class="line">  left: 60px;</span><br><span class="line">  </span><br><span class="line">  background-color: #35617a;</span><br><span class="line">  </span><br><span class="line">  animation-delay: 150ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bar:nth-child(5) &#123;</span><br><span class="line">  left: 80px;</span><br><span class="line">  </span><br><span class="line">  background-color: #3d6d86;</span><br><span class="line">  </span><br><span class="line">  animation-delay: 200ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bar:nth-child(6) &#123;</span><br><span class="line">  left: 100px;</span><br><span class="line">  </span><br><span class="line">  background-color: #447892;</span><br><span class="line">  </span><br><span class="line">  animation-delay: 250ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bar:nth-child(7) &#123;</span><br><span class="line">  left: 120px;</span><br><span class="line">  </span><br><span class="line">  background-color: #4c849e;</span><br><span class="line">  </span><br><span class="line">  animation-delay: 300ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bar:nth-child(8) &#123;</span><br><span class="line">  left: 140px;</span><br><span class="line">  </span><br><span class="line">  background-color: #548fa9;</span><br><span class="line">  </span><br><span class="line">  animation-delay: 350ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bar:nth-child(9) &#123;</span><br><span class="line">  left: 160px;</span><br><span class="line">  </span><br><span class="line">  background-color: #5c9bb5;</span><br><span class="line">  </span><br><span class="line">  animation-delay: 400ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bar:nth-child(10) &#123;</span><br><span class="line">  left: 180px;</span><br><span class="line">  </span><br><span class="line">  background-color: #63a6c1;</span><br><span class="line">  </span><br><span class="line">  animation-delay: 450ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.loader--reflect .bar &#123;</span><br><span class="line">  animation-name: bar-reflect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes bar &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: rotateZ(-180deg) rotateX(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">  75%,100% &#123;</span><br><span class="line">    transform: rotateZ(0) rotateX(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes bar-reflect &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: rotateZ(180deg) rotateX(360deg);</span><br><span class="line">  &#125;</span><br><span class="line">  75%,100% &#123;</span><br><span class="line">    transform: rotateZ(0) rotateX(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>git上还有许多纯css实现的神作,以后再继续分享</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pano2vr创建VR全景</title>
    <url>/2019/09/26/101-%E5%88%B6%E4%BD%9CVR%E5%85%A8%E6%99%AF/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>一个有趣的小软件,可以自动生成VR全景,全当一个demo玩一玩</p>
</blockquote>
<a id="more"></a>

<p>本篇转载<a href="https://blog.csdn.net/QQ408896436/article/details/60767037" target="_blank" rel="noopener">链接</a></p>
<p>效果预览 –&gt; <a href="http://csingg.coding.me/VRquanjing/timg.html" target="_blank" rel="noopener">戳我戳我</a></p>
<h3 id="下载安装pano2vr"><a href="#下载安装pano2vr" class="headerlink" title="下载安装pano2vr"></a>下载安装pano2vr</h3><p>首先下载一个pano2vr</p>
<p>下载好了打开软件,选择一张全景图放入</p>
<p>全景图可以去百度找一下</p>
<h3 id="设定参数"><a href="#设定参数" class="headerlink" title="设定参数"></a>设定参数</h3><p>选择html5后，点击旁边的增加按钮,设定一些参数</p>
<p><img src="https://img-blog.csdn.net/20170307162218486?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUVE0MDg4OTY0MzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="图片地址"></p>
<p>立方体和图像质量的值越大，生成的图片越清晰。（立方体面积尺寸最大是2880）</p>
<p><img src="https://img-blog.csdn.net/20170307162235658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUVE0MDg4OTY0MzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="图片地址"></p>
<p>按上图操作</p>
<p><img src="https://img-blog.csdn.net/20170307162254236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUVE0MDg4OTY0MzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="图片地址"></p>
<p>打上勾。意思是全屏展示 和 开启陀螺仪，最后点击确定按钮则会弹出一个框,点击是,然后选择输出目录则会开始生成文件。vr就生成好了</p>
<h3 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h3><p>程序刚开始运行的时候，会有一个灰色的矩形在左上角,修改:</p>
<p><code>#container canvas{width: 100%; height: 100%;}</code></p>
<p>好了,VR就讲到这里了,全靠工具生成,自己并不会写,没办法,菜…</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透</title>
    <url>/2019/09/29/102-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>介绍一下一个内网穿透外网的软件,挺好用的</p>
</blockquote>
<a id="more"></a>

<p>先上一下<a href="https://natapp.cn" target="_blank" rel="noopener">官网地址</a></p>
<ol>
<li><p>先下载一个客户端</p>
</li>
<li><p>上官网注册一个账号后登陆</p>
</li>
<li><p>购买一个免费隧道</p>
</li>
<li><p>将你要配置映射出去的端口号什么的设置一下</p>
</li>
<li><p>复制一下<code>authtoken</code>,然后打开刚刚下载的客户端文件,里面有一个config文件,替换一下<code>authtoken</code></p>
</li>
<li><p>双击运行.exe文件</p>
</li>
</ol>
<h3 id="vue-cli中使用"><a href="#vue-cli中使用" class="headerlink" title="vue-cli中使用"></a>vue-cli中使用</h3><p>webpack-dev-server出于安全考虑，默认检查hostname，如果hostname不是配置内的，将中断访问。</p>
<p>所以需要配置一下,添加 <code>--disableHostCheck=true</code> 作用是关闭 host 检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;webpack-dev-server --disableHostCheck&#x3D;true --inline --progress --config build&#x2F;webpack.dev.conf.js&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;npm run dev&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;node build&#x2F;build.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>vue-cli 3.0中就添加以下代码到vue.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    disableHostCheck: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子我们就可以不通过部署服务器,让别人通过外网访问我们的页面了</p>
<p>以上就是我对NATAPP的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建个人博客</title>
    <url>/2019/09/30/103-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>一直没有去介绍hexo,久而久之自己也有点忘记当初的步骤了,今天回顾以下其他大佬的文章,做一个记录</p>
</blockquote>
<a id="more"></a>

<p>网上关于Hexo的教程其实已经有挺多了,我也是选取了几篇文章,再结合自己的记忆,写下这边文章</p>
<p>首先先看看准备工作</p>
<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ol>
<li>搭建Node.js</li>
</ol>
<p><a href="https://nodejs.org/download/release/v8.9.4/" target="_blank" rel="noopener">node下载地址</a></p>
<p><code>版本号需要改成自己想要的版本</code></p>
<p>安装好了之后,cmd打开,<code>node -v</code> 看看有没有版本号</p>
<ol start="2">
<li>配置Git环境</li>
</ol>
<p>安装地址<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">戳我</a>,打开一路确定安装就可以了</p>
<p>安装好了之后,cmd打开,<code>git --version</code> 看看有没有版本号</p>
<ol start="3">
<li>gitHub账户的配置</li>
</ol>
<p>注册一个gitHub,填写完邮箱之后要去邮件确认一下,不然没办法使用page服务</p>
<p>登陆之后，点击页面右上角的加号，选择New repository, 新建一个仓库</p>
<p>之后进入代码库创建页面：</p>
<p>在Repository name下填写yourname.github.io,这个yourname就是你想写什么写什么了</p>
<p>然后我们继续配置page服务,在Settings里面,向下滚动,有一个GitHub Pages,点击那个都是英文的按钮,Github会自动替你创建出一个pages的页面,你的yourname.github.io就可以正常访问了</p>
<p>除了gitHub,我们还可以部署在coding上,步骤也都是一样的</p>
<p>好了,开始正式的安装hexo</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>创建一个文件夹,cd到这个文件夹里面,开始搭建脚手架</p>
<p><code>npm install hexo-cli -g</code></p>
<p>继续 <code>npm install hexo -g</code></p>
<p>然后 <code>hexo -v</code>一下</p>
<p>看到下图的图片,就说明安装成功了</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/103-hexo.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="版本图片"></p>
<h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>既然安装好了脚手架,现在开始初始化一下</p>
<p><code>hexo init</code> 之后再 <code>npm install</code></p>
<p>感觉怎么和搭建vue-cli一样……</p>
<p>继续操作 <code>hexo g</code></p>
<p>然后可以启动啦 <code>hexo s</code>,命令行会提示<code>INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p>
<p>我们打开本地的<code>http://0.0.0.0:4000</code>就可以看到页面了</p>
<h3 id="hexo同步git"><a href="#hexo同步git" class="headerlink" title="hexo同步git"></a>hexo同步git</h3><ol>
<li>设置Git的user name和email：(如果是第一次的话)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;csing&quot;</span><br><span class="line">git config --global user.email &quot;328911111@qq.com&quot;</span><br></pre></td></tr></table></figure>

<p>这里记得替换成自己的</p>
<ol start="2">
<li>生成密钥</li>
</ol>
<p><code>ssh-keygen -t rsa -C &quot;gdutxiaoxu@163.com&quot;</code></p>
<p>接着配置一下 Deployment</p>
<p>在_config.yml文件中，找到Deployment，然后按照如下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname&#x2F;yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>repo 替换成自己的</p>
<h3 id="创建md文件"><a href="#创建md文件" class="headerlink" title="创建md文件"></a>创建md文件</h3><p>cmd中输入命令 <code>hexo new post &quot;text&quot;</code></p>
<p>在 <code>F:\blog\source\ _posts 将会看到 text.md</code></p>
<p>用MarDown语法就可以开始写博客啦</p>
<p>然后就是发布了</p>
<p>发布之前先安装<code>npm install hexo-deployer-git --save</code></p>
<p>然后直接<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> 意思就是清理,生成,部署</p>
<p>如果报错提示有<code>publickey</code>字眼,就是ssh公钥没有配置好了</p>
<h3 id="配置Next主体"><a href="#配置Next主体" class="headerlink" title="配置Next主体"></a>配置Next主体</h3><p>我的主体用的是Next,简约大方</p>
<p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p>
<p>为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。</p>
<ol>
<li>下载next主题文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd 你的文件夹</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启用主题</li>
</ol>
<p>打开站点配置文件 ,修改 <code>theme: next</code></p>
<ol start="3">
<li>主题配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes # 三种布局</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<p>默认有三种布局方式,选择一种去掉#注释即可</p>
<ol start="4">
<li>配置语言</li>
</ol>
<p>站点配置文件 ,修改 <code>language: zh-Hans</code>,简体中文</p>
<ol start="5">
<li>设置 菜单</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu: # 菜单栏设置</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure>

<p>因为默认是英文,如果有新增的,我们需要去配置文件改成相应的中文 打开<code>languages/zh-Hans.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  schedule: 日程表</span><br><span class="line">  sitemap: 站点地图</span><br><span class="line">  commonweal: 公益404</span><br></pre></td></tr></table></figure>

<p>至于菜单图标,可要可不要,看个人喜好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu_icons: # 菜单项图标</span><br><span class="line">  enable: true</span><br><span class="line">  #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome</span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  schedule: calendar</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  sitemap: sitemap</span><br><span class="line">  commonweal: heartbeat</span><br></pre></td></tr></table></figure>

<p>需要注意的是,标签和分类的页面需要hexo生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags 生成标签页 路径</span><br><span class="line">hexo new page categories  生成分类页面</span><br></pre></td></tr></table></figure>

<p>主题差不多介绍完了,更多的去我接下来的链接中找,接下来说说SEO的优化</p>
<h3 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h3><p>emmmm….我自己的博客在百度的SEO优化也不是很好,感觉并没有什么资格讲这个,等以后再说吧</p>
<h3 id="记录一下hexo的命令"><a href="#记录一下hexo的命令" class="headerlink" title="记录一下hexo的命令"></a>记录一下hexo的命令</h3><p>以下转载至<a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">这里</a><br>想要看全部配置的<a href="https://blog.csdn.net/lemonxq/article/details/72676005" target="_blank" rel="noopener">戳这里</a><br>优化next主题的<a href="https://www.jianshu.com/p/9f0e90cc32c2" target="_blank" rel="noopener">戳这里</a></p>
<h4 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h4><p>npm install hexo -g #安装<br>npm update hexo -g #升级<br>hexo init #初始化</p>
<h4 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h4><p>hexo n “我的博客” == hexo new “我的博客” #新建文章<br>hexo p == hexo publish<br>hexo g == hexo generate#生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy#部署</p>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP</p>
<p>hexo clean #清除缓存 网页正常情况下可以忽略此条命令<br>hexo g #生成静态网页<br>hexo d #开始部署</p>
<h4 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h4><p>hexo generate #使用 Hexo 生成静态文件快速而且简单<br>hexo generate –watch #监视文件变动</p>
<h4 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h4><p>两个命令的作用是相同的<br>hexo generate –deploy<br>hexo deploy –generate</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue随笔记录</title>
    <url>/2019/10/09/104-Vue%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>顺手记录一下Vue的知识点</p>
</blockquote>
<a id="more"></a>

<p>都是从各个大佬的博客从看到的,东拼西凑…理论知识还是有用的</p>
<h3 id="SPA-单页面的理解，它的优缺点分别是什么？"><a href="#SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="SPA 单页面的理解，它的优缺点分别是什么？"></a>SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p>优点：</p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>基于上面一点，SPA 相对对服务器压力小；</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>
<p>缺点：</p>
<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>
<h3 id="怎样理解-Vue-的单向数据流？"><a href="#怎样理解-Vue-的单向数据流？" class="headerlink" title="怎样理解 Vue 的单向数据流？"></a>怎样理解 Vue 的单向数据流？</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。<br>有两种常见的试图改变一个 prop 的情形 :</p>
<ol>
<li>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props: [&#39;initialCounter&#39;],</span><br><span class="line"> data: function () &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">     counter: this.initialCounter</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props: [&#39;size&#39;],</span><br><span class="line"> computed: &#123; </span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">     return this.size.trim().toLowerCase() </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<ul>
<li><p>加载渲染过程<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
</li>
<li><p>子组件更新过程<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
</li>
<li><p>父组件更新过程<br>父 beforeUpdate -&gt; 父 updated</p>
</li>
<li><p>销毁过程<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
</li>
</ul>
<h3 id="v-model-的原理"><a href="#v-model-的原理" class="headerlink" title="v-model 的原理"></a>v-model 的原理</h3><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<p>以 input 表单元素为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input v-model&#x3D;&#39;something&#39;&gt;</span><br><span class="line">    </span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line">&lt;input v-bind:value&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something &#x3D; $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>当在input元素中使用v-model实现双数据绑定，其实就是在输入的时候触发元素的input事件，通过这个语法糖，也能够实现父子组件数据的双向绑定，代码如下：</p>
<p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ModelChild v-model&#x3D;&quot;message&quot;&gt;&lt;&#x2F;ModelChild&gt;</span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click&#x3D;&quot;test1&quot;&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props:&#123;</span><br><span class="line">      value: Number</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      test1()&#123;</span><br><span class="line">        this.$emit(&#39;input&#39;, this.value + 1)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>通过v-bind把父组件的数据绑定到了子组件的props属性中，而在props上默认用value取值，然后通过$emit触发事件input，因为v-model绑定的事件是input，故在子组件上触发了父组件的input事件，通过触发事件来进行传值，实现了父子组件数据的双向绑定，相对于直接使用v-bind以及自定义事件代码量有所减少。</p>
<h3 id="Vue-是如何实现数据双向绑定的"><a href="#Vue-是如何实现数据双向绑定的" class="headerlink" title="Vue 是如何实现数据双向绑定的"></a>Vue 是如何实现数据双向绑定的</h3><ul>
<li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li>
<li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li>
</ul>
<p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p>
<ul>
<li><p>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</p>
</li>
<li><p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p>
</li>
<li><p>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p>
</li>
<li><p>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/1/16c4a3ce0bcb0d91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片"></p>
<p>至于对象和数组,源码是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])  &#x2F;&#x2F; observe 功能为监测数据的变化</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 对属性进行递归遍历</span><br><span class="line">   *&#x2F;</span><br><span class="line">  let childOb &#x3D; !shallow &amp;&amp; observe(val) &#x2F;&#x2F; observe 功能为监测数据的变化</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Vue 框架通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p>
</blockquote>
<h3 id="虚拟-DOM-实现原理"><a href="#虚拟-DOM-实现原理" class="headerlink" title="虚拟 DOM 实现原理"></a>虚拟 DOM 实现原理</h3><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<ul>
<li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li>
<li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li>
<li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li>
</ul>
<p>先到这里,日后再补充,告辞</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>PM2学习记录</title>
    <url>/2019/10/09/105-PM2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p>
</blockquote>
<a id="more"></a>

<p>先上一个<a href="http://pm2.keymetrics.io/docs/usage/quick-start/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="PM2-的主要特性"><a href="#PM2-的主要特性" class="headerlink" title="PM2 的主要特性"></a>PM2 的主要特性</h3><ul>
<li>内建负载均衡（使用 Node cluster 集群模块）</li>
<li>后台运行</li>
<li>0 秒停机重载，我理解大概意思是维护升级的时候不需要停机.</li>
<li>具有 Ubuntu 和 CentOS 的启动脚本</li>
<li>停止不稳定的进程（避免无限循环）</li>
<li>控制台检测</li>
<li>提供 HTTP API</li>
<li>远程控制和实时的接口 API ( Nodejs 模块,允许和 PM2 进程管理器交互 )</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>npm install -g pm2</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>参数说明：</p>
<ul>
<li><p>–watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。</p>
</li>
<li><p>-i –instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。</p>
</li>
<li><p>–ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如–ignore-watch=”test node_modules “some scripts””</p>
</li>
<li><p>-n –name：应用的名称。查看应用信息的时候可以用到。</p>
</li>
<li><p>-o –output <path>：标准输出日志文件的路径。</p>
</li>
<li><p>-e –error <path>：错误输出日志文件的路径。</p>
</li>
<li><p>–interpreter <interpreter>：the interpreter pm2 should use for executing app (bash, python…)。比如你用的coffee script来编写应用。</p>
</li>
<li><p>$ pm2 logs 显示所有进程日志</p>
</li>
<li><p>$ pm2 stop all 停止所有进程</p>
</li>
<li><p>$ pm2 restart all 重启所有进程</p>
</li>
<li><p>$ pm2 reload all 0秒停机重载进程 (用于 NETWORKED 进程)</p>
</li>
<li><p>$ pm2 stop 0 停止指定的进程</p>
</li>
<li><p>$ pm2 restart 0 重启指定的进程</p>
</li>
<li><p>$ pm2 startup 产生 init 脚本 保持进程活着</p>
</li>
<li><p>$ pm2 web 运行健壮的 computer API endpoint (<a href="http://localhost:9615" target="_blank" rel="noopener">http://localhost:9615</a>)</p>
</li>
<li><p>$ pm2 delete 0 杀死指定的进程</p>
</li>
<li><p>$ pm2 delete all 杀死全部进程</p>
</li>
</ul>
<p>运行进程的不同方式：</p>
<ul>
<li>$ pm2 start app.js -i max 根据有效CPU数目启动最大进程数目</li>
<li>$ pm2 start app.js -i 3 启动3个进程</li>
<li>$ pm2 start app.js -x 用fork模式启动 app.js 而不是使用 cluster</li>
<li>$ pm2 start app.js -x – -a 23 用fork模式启动 app.js 并且传递参数 (-a 23)</li>
<li>$ pm2 start app.js –name serverone 启动一个进程并把它命名为 serverone</li>
<li>$ pm2 stop serverone 停止 serverone 进程</li>
<li>$ pm2 start app.json 启动进程, 在 app.json里设置选项</li>
<li>$ pm2 start app.js -i max – -a 23 在–之后给 app.js 传递参数</li>
<li>$ pm2 start app.js -i max -e err.log -o out.log 启动 并 生成一个配置文件</li>
</ul>
<p>更多的命令可以上官网看</p>
]]></content>
      <categories>
        <category>PM2</category>
      </categories>
      <tags>
        <tag>PM2</tag>
      </tags>
  </entry>
  <entry>
    <title>JS高频考题分享</title>
    <url>/2019/10/10/106-JS%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Javascript的一些题目无非就是靠this的指向,但是有一些是真的十分容易混淆</p>
</blockquote>
<a id="more"></a>

<p>抄录知乎的<a href="https://zhuanlan.zhihu.com/p/77406355" target="_blank" rel="noopener">地址</a></p>
<h3 id="运算符和this指向"><a href="#运算符和this指向" class="headerlink" title=", = 运算符和this指向"></a>, = 运算符和this指向</h3><p>废话不多说,直接上题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var out &#x3D; 25,</span><br><span class="line">   inner &#x3D; &#123;</span><br><span class="line">        out: 20,</span><br><span class="line">        func: function () &#123;</span><br><span class="line">            var out &#x3D; 30;</span><br><span class="line">            return this.out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">console.log((inner.func, inner.func)());</span><br><span class="line">console.log(inner.func());</span><br><span class="line">console.log((inner.func)());</span><br><span class="line">console.log((inner.func &#x3D; inner.func)());</span><br></pre></td></tr></table></figure>

<p>结果：25，20，20，25</p>
<p>代码解析：这道题的考点分两个</p>
<p>作用域</p>
<ol>
<li>运算符（赋值预算，逗号运算）</li>
<li>先看第一个输出：25，因为 ( inner.func, inner.func ) 是进行逗号运算符，逗号运算符就是运算前面的 ”,“ 返回最后一个，举个栗子</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var i &#x3D; 0, j &#x3D; 1, k &#x3D; 2;</span><br><span class="line">console.log((i++, j++, k)) &#x2F;&#x2F; 返回的是 k 的值 2 ，如果写成 k++ 的话  这里返回的就是 3</span><br><span class="line">console.log(i); &#x2F;&#x2F; 1</span><br><span class="line">console.log(j); &#x2F;&#x2F; 2</span><br><span class="line">console.log(k); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>回到原题 ( inner.func, inner.func ) 就是返回 inner.func ，而 inner.func 只是一个匿名函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function () &#123;</span><br><span class="line">    var out &#x3D; 30;</span><br><span class="line">    return this.out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且这个匿名函数是属于 window 的，则变成了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var out &#x3D; 30;</span><br><span class="line">    return this.out;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>此刻的 this =&gt; window</p>
<p>所以 out 是 25。</p>
<p>第二和第三个 console.log 的作用域都是 inner，也就是他们执行的其实是 inner.func(); inner 作用域中是有 out 变量的，所以结果是 20。</p>
<p>第四个 console.log 考查的是一个等号运算 inner.func = inner.func ，其实返回的是运算的结果， 举个栗子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 2, b &#x3D; 3;</span><br><span class="line">console.log(a &#x3D; b) &#x2F;&#x2F; 输出的是 3</span><br></pre></td></tr></table></figure>

<p>所以 inner.func = inner.func 返回的也是一个匿名函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function () &#123;</span><br><span class="line">    var out &#x3D; 30;</span><br><span class="line">    return this.out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此刻，道理就和第一个 console.log 一样了，输出的结果是 25。</p>
<h3 id="从敲入-URL-到渲染完成的整个过程"><a href="#从敲入-URL-到渲染完成的整个过程" class="headerlink" title="从敲入 URL 到渲染完成的整个过程"></a>从敲入 URL 到渲染完成的整个过程</h3><ul>
<li>用户输入 url 地址，浏览器根据域名寻找 IP 地址</li>
<li>浏览器向服务器发送 http 请求，如果服务器段返回以 301 之类的重定向，浏览器根据相应头中的 location 再次发送请求</li>
<li>服务器端接受请求，处理请求生成 html 代码，返回给浏览器，这时的 html 页面代码可能是经过压缩的</li>
<li>浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染</li>
<li>解析渲染该过程主要分为以下步骤：解析 HTML、构建 DOM 树、DOM 树与 CSS 样式进行附着构造呈现树</li>
<li>布局</li>
<li>绘制</li>
</ul>
<p><a href="https://juejin.im/post/5b9ba9c15188255c8320fe27" target="_blank" rel="noopener">详细的在这里</a></p>
<h3 id="JS-识别不同浏览器信息"><a href="#JS-识别不同浏览器信息" class="headerlink" title="JS 识别不同浏览器信息"></a>JS 识别不同浏览器信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myBrowser() &#123;</span><br><span class="line">  var userAgent &#x3D; navigator.userAgent; &#x2F;&#x2F;取得浏览器的userAgent字符串  </span><br><span class="line">  var isOpera &#x3D; userAgent.indexOf(&quot;Opera&quot;) &gt; -1;</span><br><span class="line">  if (isOpera) &#123;</span><br><span class="line">    return &quot;Opera&quot;</span><br><span class="line">  &#125;; &#x2F;&#x2F;判断是否Opera浏览器  </span><br><span class="line">  if (userAgent.indexOf(&quot;Firefox&quot;) &gt; -1) &#123;</span><br><span class="line">    return &quot;Firefox&quot;;</span><br><span class="line">  &#125;  &#x2F;&#x2F;判断是否Firefox浏览器  </span><br><span class="line">  if (userAgent.indexOf(&quot;Chrome&quot;) &gt; -1) &#123;</span><br><span class="line">    return &quot;Chrome&quot;;</span><br><span class="line">  &#125;   &#x2F;&#x2F;判断是否Google浏览器  </span><br><span class="line">  if (userAgent.indexOf(&quot;Safari&quot;) &gt; -1) &#123;</span><br><span class="line">    return &quot;Safari&quot;;</span><br><span class="line">  &#125; &#x2F;&#x2F;判断是否Safari浏览器  </span><br><span class="line">  if (userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera) &#123;</span><br><span class="line">    return &quot;IE&quot;;</span><br><span class="line">  &#125;; &#x2F;&#x2F;判断是否IE浏览器  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哪些常见操作会造成内存泄漏"><a href="#哪些常见操作会造成内存泄漏" class="headerlink" title="哪些常见操作会造成内存泄漏"></a>哪些常见操作会造成内存泄漏</h3><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</p>
<p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>
<p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。</p>
<h3 id="new-操作符具体干了什么呢"><a href="#new-操作符具体干了什么呢" class="headerlink" title="new 操作符具体干了什么呢"></a>new 操作符具体干了什么呢</h3><ul>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>
<li>属性和方法被加入到 this 引用的对象中。</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li>
</ul>
<h3 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h3><p>如果你需要合并两个数组的话，可以使用 Array.concat()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array1 &#x3D; [1, 2, 3];</span><br><span class="line">var array2 &#x3D; [4, 5, 6];</span><br><span class="line">console.log(array1.concat(array2)); &#x2F;&#x2F; [1,2,3,4,5,6];</span><br></pre></td></tr></table></figure>

<p>然而，这个函数并不适用于合并大的数组，因为它需要创建一个新的数组，而这会消耗很多内存。</p>
<p>这时，你可以使用 Array.push.apply(arr1, arr2) 来代替创建新的数组，它可以把第二个数组合并到第一个中，从而较少内存消耗。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array1 &#x3D; [1, 2, 3];</span><br><span class="line">var array2 &#x3D; [4, 5, 6];</span><br><span class="line">console.log(array1.push.apply(array1, array2)); &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<h3 id="Promise-的队列与-setTimeout-的队列有何关联-？"><a href="#Promise-的队列与-setTimeout-的队列有何关联-？" class="headerlink" title="Promise 的队列与 setTimeout 的队列有何关联 ？"></a>Promise 的队列与 setTimeout 的队列有何关联 ？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function()&#123; console.log(4) &#125;, 0);</span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    for( var i &#x3D; 0 ; i &lt; 10000 ; i++ )&#123;</span><br><span class="line">        i &#x3D;&#x3D; 9999 &amp;&amp; resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(3);</span><br></pre></td></tr></table></figure>

<p>为什么结果是：1, 2, 3, 5, 4；而不是：1, 2, 3, 4, 5 ？</p>
<p>js 里面有宏任务（macrotask）和微任务（microtask）。</p>
<p>因为 setTimeout 是属于 macrotask 的，而整个 script 也是属于一个 macrotask，promise.then 回调是 microtask，执行过程大概如下：</p>
<ul>
<li>由于整个 script 也属于一个 macrotask，由于会先执行 macrotask 中的第一个任务，再加上 promise 构造函数因为是同步的，所以会先打印出 1 和 2；</li>
<li>然后继续同步执行末尾的 console.log(3) 打印出 3；</li>
<li>此时 setTimeout 被推进到 macrotask 队列中， promise.then 回调被推进到 microtask 队列中；</li>
<li>由于在第一步中已经执行完了第一个 macrotask ，所以接下来会顺序执行所有的 microtask，也就是 promise.then 的回调函数，从而打印出 5；</li>
<li>microtask 队列中的任务已经执行完毕，继续执行剩下的 macrotask 队列中的任务，也就是 setTimeout，所以打印出 4。</li>
</ul>
<h3 id="TCP-三次握手和四次挥手的理解"><a href="#TCP-三次握手和四次挥手的理解" class="headerlink" title="TCP 三次握手和四次挥手的理解"></a>TCP 三次握手和四次挥手的理解</h3><p><img src="https://pic2.zhimg.com/80/v2-d72350318adbfb3694510f8e2877c6b1_hd.png" alt="直接上图"></p>
<p><a href="https://juejin.im/post/5c078058f265da611c26c235" target="_blank" rel="noopener">更详细的</a></p>
<h3 id="找出字符串中出现最多的字符"><a href="#找出字符串中出现最多的字符" class="headerlink" title="找出字符串中出现最多的字符"></a>找出字符串中出现最多的字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &#39;abaasdffggghhjjkkgfddsssss3444343&#39;;</span><br><span class="line">&#x2F;&#x2F; 1.将字符串转换成数组</span><br><span class="line">var newArr &#x3D; str.split(&quot;&quot;);</span><br><span class="line">&#x2F;&#x2F; 2.创建一个对象</span><br><span class="line">var json &#x3D; &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F; 3. 所有字母出现的次数，判断对象中是否存在数组中的值，如果存在值 +1，不存在赋值为 1</span><br><span class="line">for(var i &#x3D; 0; i &lt; newArr.length; i++)&#123;</span><br><span class="line">  &#x2F;&#x2F; 类似：json : &#123; ‘a’: 3, ’b’: 1 &#125;</span><br><span class="line">  if(json[newArr[i]])&#123;</span><br><span class="line">    json[newArr[i]] +&#x3D;1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    json[newArr[i]] &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 4 定义两个变量存储字符值，字符出现的字数</span><br><span class="line">var num &#x3D; 0 ; &#x2F;&#x2F;次数</span><br><span class="line">var element &#x3D; &quot;&quot;; &#x2F;&#x2F;最多的项</span><br><span class="line">for(var k in json)&#123;</span><br><span class="line">   if(json[k] &gt; num)&#123;</span><br><span class="line">    num &#x3D; json[k];</span><br><span class="line">    element &#x3D; k ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;出现次数：&quot;+num +&quot;最多的字符：&quot;+ element);</span><br></pre></td></tr></table></figure>

<h3 id="alert-1-amp-amp-2-和-alert-1-0-的结果是-？"><a href="#alert-1-amp-amp-2-和-alert-1-0-的结果是-？" class="headerlink" title="alert(1 &amp;&amp; 2) 和 alert(1 || 0) 的结果是 ？"></a>alert(1 &amp;&amp; 2) 和 alert(1 || 0) 的结果是 ？</h3><p>alert(1 &amp;&amp;2 ) 的结果是 2</p>
<ul>
<li>只要 “&amp;&amp;” 前面是 false，无论 “&amp;&amp;” 后面是 true 还是 false，结果都将返 “&amp;&amp;” 前面的值;</li>
<li>只要 “&amp;&amp;” 前面是 true，无论 “&amp;&amp;” 后面是 true 还是 false，结果都将返 “&amp;&amp;” 后面的值;</li>
</ul>
<p>alert(0 || 1) 的结果是 1</p>
<ul>
<li>只要 “||” 前面为 false，不管 “||” 后面是 true 还是 false，都返回 “||” 后面的值。</li>
<li>只要 “||” 前面为 true，不管 “||” 后面是 true 还是 false，都返回 “||” 前面的值。</li>
</ul>
<blockquote>
<p>只要记住 0 与 任何数都是 0，其他反推。</p>
</blockquote>
<p>感谢各位大佬的无私分享</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>H5打包ios</title>
    <url>/2019/10/12/107-H5%E6%89%93%E5%8C%85ios/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>打包成Android就不说了,直接打包安卓就好了,没有那么复杂,但是ios就不一样了</p>
</blockquote>
<a id="more"></a>

<p>我用的IDE是HBuilder,自带打包功能,以这个为例</p>
<ol>
<li><p>首先要先注册一个苹果账号,怎么注册就不说了</p>
</li>
<li><p>下载Appuploader,申请免费的证书和描述文件,这一步非常重要</p>
</li>
</ol>
<p>这个是<a href="http://www.applicationloader.net/" target="_blank" rel="noopener">官网</a></p>
<p>下载好之后,文档里面有教程</p>
<h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><ol>
<li>打开Appuploader，用普通苹果账号登录</li>
<li>登录上去有个提示不用管、叉掉，选择Certification</li>
<li>点击右下角+ADD，选择第一项 ios App development(第三个就是直接发布到appstroe)，输入名称（英文随意）、邮箱（随意）、密码后面打包ipa时要用到，要记住，123之类密码的就行。</li>
<li>点击p12 File下载保存.p12 证书文件</li>
</ol>
<h3 id="申请ios描述文件"><a href="#申请ios描述文件" class="headerlink" title="申请ios描述文件"></a>申请ios描述文件</h3><ol>
<li><p>返回软件，选择Profiles</p>
</li>
<li><p>点击右下角+ADD，先选择添加Add appid 应用标识符、输入appid，格式是com.com.com这样子的，中间有两个点。</p>
<p>像我开始输入的com.ceshi.ceshi出现错误提示，格式虽然没错，但有报错，尝试修改下不报错就行了。</p>
<p>后面我改下如com.fen.tian，如此就ok，appid在打包ipa时要填写，记好。</p>
</li>
<li><p>下一步添加用来测试的手机了，先获取UUID。使用 iPhone 或 iPad 扫码选择自带的浏览器safari浏览器打开二维码里的链接，即可快速获取 UDID或者连接苹果手机助手获取到。</p>
<p>这个一长串的就是设备的UUID</p>
<p>04bff1010f1656cde7d60g560d7d897e2821dc88</p>
<p>获取到UUID、点击Add Device，复制上去，输入设备名称，点击ok。</p>
<p>可以添加多个</p>
</li>
</ol>
<p>4、添加好设备后，叉掉，重新点击右下角的+ADD，选择第一项 ios App development。选择刚创建的appid  如com.fen.tian，勾选关联第一步创建的ios证书p12，选择要测试的设备，可多选。输入名称，点击ok创建。</p>
<p>5、点击Download下载保存.mobileprovision，描述文件。</p>
<h3 id="打包ipa"><a href="#打包ipa" class="headerlink" title="打包ipa"></a>打包ipa</h3><ol>
<li><p>打开HBuilder工具，选择完工的项目，点击发行，选择发行为原生安装包。</p>
</li>
<li><p>选择iOS打包，支持的设备类型，使用苹果证书，填写AppID（刚创建的那个com.fen.tian），</p>
<p>上传之前创建的iOS证书.p12及配置文件.mobileprovision并输入创建ios证书p12时设置的密码，点击打包。</p>
</li>
<li><p>打包成功后，下载保存ipa，这个ipa包就能进行测试或上传App Store了。</p>
</li>
</ol>
<h3 id="安装ipa"><a href="#安装ipa" class="headerlink" title="安装ipa"></a>安装ipa</h3><ol>
<li><p>下载爱思苹果助手，连接上手机，苹果官方的iTunes助手安装不了，不要用这个。</p>
<p>点击应用游戏，点击导入安装，选择刚打包的ipa包。</p>
</li>
<li><p>ipa将自动安装，类型是越狱版，安装成功后显示个人正版，因为是个人ios证书打包，没上架App Store。</p>
</li>
<li><p>安装成功了第一次启动应用会出现如下提示，用测试证书或者企业证书打包的ipa都会这样，需要设置一下。</p>
<p>点击设置、进入通用，下拉选择描述文件和设备管理。</p>
</li>
<li><p>点击开发者应用下面出现的账号，信任，然后就能启动应用，不在出现提示。</p>
</li>
</ol>
<blockquote>
<p>后期经过测试,只能安装三台ios手机…多了不支持,想要正式上架的话,就用交了钱的苹果账号就行</p>
</blockquote>
]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>github的部署</title>
    <url>/2019/11/13/108-%E9%83%A8%E7%BD%B2github/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>GitHub很早之前就已经写过了命令,但是有些小伙伴问我具体的流程,在这里做这记录</p>
</blockquote>
<a id="more"></a>

<ol>
<li><p>首先 进入Github首页，点击New repository新建一个项目,填写相应的数据就好了</p>
</li>
<li><p>然后 Clone or dowload会出现一个地址，复制这个地址。(旧项目同理)</p>
</li>
<li><p>把github上面的仓库克隆到本地,命令可以在之前的博客中找到</p>
</li>
</ol>
<blockquote>
<p>git clone <a href="mailto:git@github.com">git@github.com</a>:328921371/cs.git</p>
</blockquote>
<ol start="4">
<li><p>克隆后进入文件夹,当命令行那边的文件目录出现master</p>
</li>
<li><p>git add . （注：别忘记后面的）</p>
</li>
<li><p>git commit  -m  “提交信息” （注释）</p>
</li>
<li><p>git push -u origin master （将内容推送到远程仓库里，第一次要加-u,此步骤需要你输入帐号和密码）</p>
</li>
</ol>
<p>到这里,代码就部署到github上面了,更多的操作命令搜索我之前的博客<a href="http://www.chensheng.group/2016/12/20/12-git的使用/">戳这里</a></p>
<p>以上就是我对github的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue转PDF模糊问题</title>
    <url>/2019/12/09/109-Vue%E8%BD%ACPDF%E6%A8%A1%E7%B3%8A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>很早之前就写了html转PDF的博客了,今天来说一下模糊的问题</p>
</blockquote>
<a id="more"></a>

<p>首先 先安装插件,然后引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save html2canvas </span><br><span class="line">npm install jspdf --save</span><br><span class="line"></span><br><span class="line">import html2Canvas from &#39;html2canvas&#39;</span><br><span class="line">import JsPDF from &#39;jspdf&#39;</span><br></pre></td></tr></table></figure>

<p>接下来的写法和html基本一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PDF() &#123;</span><br><span class="line">  let title &#x3D; this.titleName;</span><br><span class="line">  let dom &#x3D; document.querySelector(&#39;#printPage&#39;)</span><br><span class="line">  </span><br><span class="line">  let width &#x3D; dom.offsetWidth</span><br><span class="line">  let height &#x3D; dom.offsetHeight</span><br><span class="line">  </span><br><span class="line">  let canvas &#x3D; document.createElement(&quot;canvas&quot;)</span><br><span class="line">  let scale &#x3D; 2</span><br><span class="line">  </span><br><span class="line">  canvas.width &#x3D; width * scale; &#x2F;&#x2F;定义canvas 宽度 * 缩放</span><br><span class="line">  canvas.height &#x3D; height * scale ; &#x2F;&#x2F;定义canvas高度 *缩放</span><br><span class="line">  canvas.style.width &#x3D; width * scale + &quot;px&quot;;</span><br><span class="line">  canvas.style.height &#x3D; height * scale + &quot;px&quot;;</span><br><span class="line">  </span><br><span class="line">  canvas.getContext(&quot;2d&quot;).scale(scale, scale); &#x2F;&#x2F;获取context,设置scale</span><br><span class="line">  </span><br><span class="line">  var opts &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;allowTaint: true, &#x2F;&#x2F;允许污染</span><br><span class="line">    taintTest: false, &#x2F;&#x2F;在渲染前测试图片</span><br><span class="line">    background: &quot;#fff&quot;,</span><br><span class="line">    scale: 1,</span><br><span class="line">    canvas: canvas,</span><br><span class="line">    width: width, &#x2F;&#x2F;dom 原始宽度</span><br><span class="line">    height: height,</span><br><span class="line">    useCORS: true, &#x2F;&#x2F; 【重要】开启跨域配置</span><br><span class="line">    &#x2F;&#x2F;logging: true, &#x2F;&#x2F;日志开关，便于查看html2canvas的内部执行流程</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  html2Canvas(dom, opts).then((canvas)&#x3D;&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    var context &#x3D; canvas.getContext(&#39;2d&#39;);</span><br><span class="line">    &#x2F;&#x2F; 【重要】关闭抗锯齿</span><br><span class="line">    context.mozImageSmoothingEnabled &#x3D; false;</span><br><span class="line">    context.webkitImageSmoothingEnabled &#x3D; false;</span><br><span class="line">    context.msImageSmoothingEnabled &#x3D; false;</span><br><span class="line">    context.imageSmoothingEnabled &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    let contentWidth &#x3D; canvas.width</span><br><span class="line">    let contentHeight &#x3D; canvas.height</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;未生成pdf的html页面高度</span><br><span class="line">    let leftHeight &#x3D; contentHeight</span><br><span class="line">    &#x2F;&#x2F;页面偏移</span><br><span class="line">    let position &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;a4纸的尺寸[595.28,841.89]，html页面生成的canvas在pdf中图片的宽高</span><br><span class="line">    if(this.direction &#x3D;&#x3D; &#39;纵&#39;)&#123;</span><br><span class="line">      &#x2F;&#x2F;一页pdf显示html页面生成的canvas高度;</span><br><span class="line">      var pageHeight &#x3D; contentWidth &#x2F; 592.28 * 841.89</span><br><span class="line">      var imgWidth &#x3D; 595.28</span><br><span class="line">      var imgHeight &#x3D; 592.28 &#x2F; contentWidth * contentHeight</span><br><span class="line">      var pathAway &#x3D; &#39;p&#39;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      var pageHeight &#x3D; contentWidth &#x2F; 841.89  * 592.28; &#x2F;&#x2F; 横向</span><br><span class="line">      var imgWidth &#x3D; 841.89;  &#x2F;&#x2F; 横向</span><br><span class="line">      var imgHeight &#x3D; 841.89&#x2F;contentWidth * contentHeight; &#x2F;&#x2F; 横向</span><br><span class="line">      var pathAway &#x3D; &#39;l&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let pageData &#x3D; canvas.toDataURL(&#39;image&#x2F;jpeg&#39;, 1.0)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;p：纵向，l为横向 a4：纸张大小，默认是a4;</span><br><span class="line">    let PDF &#x3D; new JsPDF(pathAway, &#39;pt&#39;, &#39;a4&#39;)</span><br><span class="line">    &#x2F;&#x2F;有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)</span><br><span class="line">    &#x2F;&#x2F;当内容未超过pdf一页显示的范围，无需分页</span><br><span class="line">    if (leftHeight &lt; pageHeight) &#123;</span><br><span class="line">      PDF.addImage(pageData, &#39;JPEG&#39;, 0, 0, imgWidth, imgHeight)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      while (leftHeight &gt; 0) &#123;</span><br><span class="line">        PDF.addImage(pageData, &#39;JPEG&#39;, 0, position, imgWidth, imgHeight)</span><br><span class="line">        leftHeight -&#x3D; pageHeight</span><br><span class="line">        &#x2F;&#x2F; position -&#x3D; 841.89</span><br><span class="line">        position -&#x3D; 592.28 &#x2F;&#x2F; 横向</span><br><span class="line">        &#x2F;&#x2F;避免添加空白页</span><br><span class="line">        if (leftHeight &gt; 0) &#123;</span><br><span class="line">          PDF.addPage()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PDF.save(title + &#39;.pdf&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将需要转化为PDF的内容设定一个id</p>
<p>对于模糊的问题,做法和大家一样,先扩大两倍,再缩小</p>
<p>还有设定就是横向打印还是纵向打印,这些都是看具体需求的</p>
<p>以上就是我对PDF模糊问题的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 的安装与使用</title>
    <url>/2016/12/10/11-MongoDB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>最近准备研究一下非关系型数据库 MongoDB,其实官网等一下介绍的也挺详细的,我在这里介绍一下 MongoDB的安装及基本的使用,还有安装在win10系统上踩过的坑</p>
</blockquote>
<a id="more"></a>

<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载就到官网上下载就可以了<a href="https://www.mongodb.com/download-center#community" target="_blank" rel="noopener">MongoDB下载地址</a></p>
<h3 id="配置mongoDB数据库"><a href="#配置mongoDB数据库" class="headerlink" title="配置mongoDB数据库"></a>配置mongoDB数据库</h3><p>先安装之前下载好的mongoDB.根据提示选择安装就可以了</p>
<p>启动数据库</p>
<ul>
<li>创建一个文件夹，作为数据库存放目录(文件夹位置不限),推荐放在bin目录底下，比较好找.</li>
<li>打开cmd,cd到mongoDB/bin中。</li>
<li>执行 mongod.exe –dbpath “数据库目录（该目录为第一项创建的目录）”  端口号：27017</li>
</ul>
<p>连接数据库。(需要打开windows自带服务功能：.netframework)</p>
<p>mongo.exe是mongoDB自带的数据库连接查看工具.使用mongo.exe可以自动连接mongo数据库。</p>
<p>使用mongo数据库</p>
<ul>
<li>打开新的终端窗口，原窗口不要关闭</li>
<li>cd到bin目录中去</li>
<li>执行mongo命令，可以直接连接mongo数据库</li>
</ul>
<p>到这里就可以在你的命令行中使用MongoDB数据库啦</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol>
<li><p>show dbs 查看数据库</p>
</li>
<li><p>use h5-7  使用数据库，如果没有就新建并且切换</p>
</li>
<li><p>db.dorpDatabase() 删除数据库–前提是先进入当前的数据库中</p>
</li>
<li><p>db.createCollection(“test”) 创建表，这个命令不常用(也可以通过 db.表名.insert() 使用表时，如果不存在，会创建)</p>
</li>
<li><p>show collections  展示表</p>
</li>
<li><p>db.people.insert({name:’小黄’})  创建表，并且插入一条数据</p>
</li>
<li><p>db.people.save({name:’小黄’}) 这样也可以插入数据</p>
</li>
<li><p>db.people.find() 查询某个表中所有数据</p>
</li>
<li><p>db.people.count() 查询条数</p>
</li>
<li><p>db.people.find({age:25}) 插入查询条件</p>
</li>
<li><p>db.people.find({age:{$lt:25}}) 查询大于(gt)或者小于</p>
</li>
<li><p>db.people.find({age:{$lte:25}}) 查询大于等于($gte)或者小于等于</p>
</li>
<li><p>db.people.find({age:{$ne:25}}) 除了他本身的</p>
</li>
<li><p>db.people.find({age:22,name:’小黑’}) 查询符合所有条件的数据</p>
</li>
<li><p>db.people.find({$or:[{age:22},{name:’小黄’}]});查询符合任意一个条件的数据</p>
</li>
<li><p>查询条件支持正则表达式：</p>
<p>db.people.find({name:/四/})             查找姓名包含：四 的人</p>
<p>db.people.find({name:/^张/})            查找姓 张 的人</p>
<p>db.people.find({name:/^张.$/})          查找姓 张 的人并且不能以空格结束</p>
<p>db.people.find({},{name:1,_id:0})       只查找name这一列（field）</p>
</li>
<li><p>db.people.sort({排序的键:1或-1}) 把查询结果按照某个字段进行排序。1为升序，-1为降序</p>
</li>
<li><p>db.people.find().sort({age:1}).limit(n)  从查询结果中取前n条数据。</p>
</li>
<li><p>db.people.find().sort({age:1}).skip(n)  跳过(删除)查询结果中前n条数据。</p>
</li>
<li><p>db.people.find().skip(n).limit(n) 可以实现从第几条开始，往后查多少条。</p>
</li>
<li><p>db.people.update({查询条件},{$set:{修改内容}})  </p>
<p>例:把姓名为：小黄 的年龄改为：18    </p>
<p>db.people.update({name:’小黄’},{age:18})  不太理想 这样只能修改age一个值</p>
<p>db.people.update({name:’小黄’},{$set:{age:18}})  可以采用，可以添加多个对象进行修改</p>
</li>
<li><p>db.people.remove({查询条件})</p>
<p>db.people.remove({name:’张三’}) //删除表中满足条件的数据。</p>
<p>db.people.remove({_id:ObjectId(“5805c346574a5365e955ecd9”)})  //一般用id删除数据，更加精确和准确</p>
</li>
</ol>
<h3 id="使用代码控制数据库"><a href="#使用代码控制数据库" class="headerlink" title="使用代码控制数据库"></a>使用代码控制数据库</h3><p>之前讲的都是在命令行对数据库进行操作,那么如何在代码js页中链接数据库进行数据处理呢?</p>
<p>首先先导入导入 mongoose 模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br></pre></td></tr></table></figure>

<p>然后设置链接数据库地址，csing为数据库的名字，没有这个数据库就会自动创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://localhost:27017/csing'</span>);</span><br></pre></td></tr></table></figure>

<p>开始链接数据库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = mongoose.connection;</span><br></pre></td></tr></table></figure>

<p>监听数据库链接的状态：成功 ：open 失败：error</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.on(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'数据库链接成功'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">db.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'数据库链接失败'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>获取schema对象(图表结构对象)，这里的Schema是一个构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Schema = mongoose.Schema;</span><br></pre></td></tr></table></figure>

<p>创建一个数据结构(参数1：集合的结构  参数2：集合的名字,参数1中需要什么值，就传入什么值)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">name:<span class="built_in">String</span>,</span><br><span class="line">psw:<span class="built_in">Number</span></span><br><span class="line">&#125;,&#123;<span class="attr">collection</span>:<span class="string">'cssss'</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>根据数据集合 userSchema, 获取一行数据的构造函数<br>var User = mongoose.model(‘csing’,userSchema);</p>
<p>以下是增删改查的操作:</p>
<h4 id="增加"><a href="#增加" class="headerlink" title="增加:"></a>增加:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/add'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> user = <span class="keyword">new</span> User(&#123;<span class="attr">name</span>:req.query.name,<span class="attr">age</span>:req.query.age&#125;)<span class="comment">//根据 User 构造函数 ，创建一个 user 对象</span></span><br><span class="line">	<span class="comment">//有数据了，但是没有保存，下一步要保存</span></span><br><span class="line">	user.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,data,status</span>)</span>&#123;<span class="comment">//status 1 为成功</span></span><br><span class="line">		<span class="keyword">if</span>(!err)&#123;</span><br><span class="line">			res.send(<span class="string">'保存成功'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			res.send(<span class="string">'保存失败'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询:"></a>查询:</h4><p>查询有两种方法 find()findOne()</p>
<p>User.find({这里的括号写查询的条件})  只要满足条件，都能查到</p>
<p>User.findOne()只查找一个，从第一个开始找，找到一个就结束</p>
<p>模糊查询 通过name：{$regex:关键字}实现模糊查询 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/select'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(req.query.name)&#123; <span class="comment">//有条件查询，如果需要什么条件，可以在最后打点</span></span><br><span class="line">		User.find(&#123;<span class="attr">name</span>:req.query.name&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!err &amp;&amp; data.length&gt;<span class="number">0</span>)&#123;	<span class="comment">//这里一定要主要，err不一定报错 ，所以建议用data.length&gt;0</span></span><br><span class="line">				res.send(data);<span class="comment">//查询成功</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		User.find(<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;<span class="comment">//无条件插件，查询出全部内容</span></span><br><span class="line">			<span class="keyword">if</span>(!err)&#123;</span><br><span class="line">				res.send(data);<span class="comment">//查询成功</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改:"></a>修改:</h4><p>multi: 是否修改多条 true为全部修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/update'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//将名字为req.query.name 的     age  改为 req.query.age</span></span><br><span class="line">	User.update(&#123;<span class="attr">name</span>: req.query.name&#125;, &#123;<span class="attr">age</span>: req.query.age&#125;, &#123;<span class="attr">multi</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!err) &#123;<span class="comment">//如果数据库中没有修改的值，加上判断	</span></span><br><span class="line">			<span class="keyword">if</span>(result.nModified &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				res.send(<span class="string">'修改成功'</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				res.send(<span class="string">'修改的值一致'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			res.send(<span class="string">'修改失败'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>假设我们删除年龄最大的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/remove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	User.find(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;<span class="comment">//第一步 先找到年龄最大的</span></span><br><span class="line">		<span class="keyword">var</span> obj = data[<span class="number">0</span>]<span class="comment">//找到最大的，获取到数组的第一个</span></span><br><span class="line">		User.remove(&#123;</span><br><span class="line">			_id: obj._id</span><br><span class="line">		&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!err) &#123;</span><br><span class="line">				res.send(<span class="string">'删除年龄最大的成果'</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;).sort(&#123;</span><br><span class="line">		age: <span class="number">-1</span></span><br><span class="line">	&#125;).limit(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上就是数据库基本的增删改查的操作了,如有错误,欢迎各位大牛指出</p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>表格导出Excel和打印</title>
    <url>/2019/12/09/110-%E8%A1%A8%E6%A0%BC%E5%AF%BC%E5%87%BAExcel%E5%92%8C%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>上一篇说到了转PDF格式,今天说一下表格的打印和导出</p>
</blockquote>
<a id="more"></a>

<p>先说一下导出到Excel</p>
<p>首先安装相关依赖 <code>npm install --save xlsx file-saver</code></p>
<p>然后导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import FileSaver from &#39;file-saver&#39;</span><br><span class="line">import XLSX from &#39;xlsx&#39;</span><br></pre></td></tr></table></figure>

<p>可以开始使用了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daochu() &#123;</span><br><span class="line">  let name &#x3D; this.titleName + &#39;.xlsx&#39;</span><br><span class="line">  var xlsxParam &#x3D; &#123; raw: true &#125;;&#x2F;&#x2F;转换成excel时，使用原始的格式</span><br><span class="line">  &#x2F;* generate workbook object from table *&#x2F;</span><br><span class="line">  var wb &#x3D; XLSX.utils.table_to_book(document.querySelector(&#39;#out-table&#39;),xlsxParam)</span><br><span class="line">  &#x2F;* get binary string as output *&#x2F;</span><br><span class="line">  var wbout &#x3D; XLSX.write(wb, &#123;</span><br><span class="line">    bookType: &#39;xlsx&#39;,</span><br><span class="line">    bookSST: true,</span><br><span class="line">    type: &#39;array&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">  try &#123;</span><br><span class="line">    FileSaver.saveAs(new Blob([wbout], &#123;</span><br><span class="line">      type: &#39;application&#x2F;octet-stream;charset&#x3D;utf-8&#39;</span><br><span class="line">    &#125;), name)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    if (typeof console !&#x3D;&#x3D; &#39;undefined&#39;) console.log(e, wbout)</span><br><span class="line">  &#125;</span><br><span class="line">  return wbout</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>将需要导出的table表格设置一个id就可以了</p>
<p>再来看看打印,打印就比较简单了</p>
<p>在main.js中导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印插件</span><br><span class="line">import MyPlugin from &#39;@&#x2F;util&#x2F;print.js&#39;</span><br><span class="line">Vue.use(MyPlugin)</span><br></pre></td></tr></table></figure>

<p><code>print.js</code>的源码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印类属性、方法定义</span><br><span class="line">&#x2F;* eslint-disable *&#x2F;</span><br><span class="line">const Print &#x3D; function(dom, options) &#123;</span><br><span class="line">  if (!(this instanceof Print)) return new Print(dom, options);</span><br><span class="line"></span><br><span class="line">  this.options &#x3D; this.extend(&#123;</span><br><span class="line">    &#39;noPrint&#39;: &#39;.no-print&#39;</span><br><span class="line">  &#125;, options);</span><br><span class="line"></span><br><span class="line">  if ((typeof dom) &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;</span><br><span class="line">    this.dom &#x3D; document.querySelector(dom);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.isDOM(dom)</span><br><span class="line">    this.dom &#x3D; this.isDOM(dom) ? dom : dom.$el;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.init();</span><br><span class="line">&#125;;</span><br><span class="line">Print.prototype &#x3D; &#123;</span><br><span class="line">  init: function() &#123;</span><br><span class="line">    var content &#x3D; this.getStyle() + this.getHtml();</span><br><span class="line">    this.writeIframe(content);</span><br><span class="line">  &#125;,</span><br><span class="line">  extend: function(obj, obj2) &#123;</span><br><span class="line">    for (var k in obj2) &#123;</span><br><span class="line">      obj[k] &#x3D; obj2[k];</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getStyle: function() &#123;</span><br><span class="line">    var str &#x3D; &quot;&quot;,</span><br><span class="line">      styles &#x3D; document.querySelectorAll(&#39;style,link&#39;);</span><br><span class="line">    for (var i &#x3D; 0; i &lt; styles.length; i++) &#123;</span><br><span class="line">      str +&#x3D; styles[i].outerHTML;</span><br><span class="line">    &#125;</span><br><span class="line">    str +&#x3D; &quot;&lt;style&gt;&quot; + (this.options.notPrint ? this.options.notPrint : &#39;.no-print&#39;) + &quot;&#123;display:none;&#125;&lt;&#x2F;style&gt;&quot;;</span><br><span class="line">     </span><br><span class="line">    return str;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getHtml: function() &#123;</span><br><span class="line">    var inputs &#x3D; document.querySelectorAll(&#39;input&#39;);</span><br><span class="line">    var textareas &#x3D; document.querySelectorAll(&#39;textarea&#39;);</span><br><span class="line">    var selects &#x3D; document.querySelectorAll(&#39;select&#39;);</span><br><span class="line">    var canvass &#x3D; document.querySelectorAll(&#39;canvas&#39;);</span><br><span class="line">    for (var k &#x3D; 0; k &lt; inputs.length; k++) &#123;</span><br><span class="line">      if (inputs[k].type &#x3D;&#x3D; &quot;checkbox&quot; || inputs[k].type &#x3D;&#x3D; &quot;radio&quot;) &#123;</span><br><span class="line">        if (inputs[k].checked &#x3D;&#x3D; true) &#123;</span><br><span class="line">          inputs[k].setAttribute(&#39;checked&#39;, &quot;checked&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          inputs[k].removeAttribute(&#39;checked&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (inputs[k].type &#x3D;&#x3D; &quot;text&quot;) &#123;</span><br><span class="line">        inputs[k].setAttribute(&#39;value&#39;, inputs[k].value)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        inputs[k].setAttribute(&#39;value&#39;, inputs[k].value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var k2 &#x3D; 0; k2 &lt; textareas.length; k2++) &#123;</span><br><span class="line">      if (textareas[k2].type &#x3D;&#x3D; &#39;textarea&#39;) &#123;</span><br><span class="line">        textareas[k2].innerHTML &#x3D; textareas[k2].value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var k3 &#x3D; 0; k3 &lt; selects.length; k3++) &#123;</span><br><span class="line">      if (selects[k3].type &#x3D;&#x3D; &#39;select-one&#39;) &#123;</span><br><span class="line">        var child &#x3D; selects[k3].children;</span><br><span class="line">        for (var i in child) &#123;</span><br><span class="line">          if (child[i].tagName &#x3D;&#x3D; &#39;OPTION&#39;) &#123;</span><br><span class="line">            if (child[i].selected &#x3D;&#x3D; true) &#123;</span><br><span class="line">              child[i].setAttribute(&#39;selected&#39;, &quot;selected&quot;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              child[i].removeAttribute(&#39;selected&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;canvass echars图表转为图片</span><br><span class="line">    for (var k4 &#x3D; 0; k4 &lt; canvass.length; k4++) &#123;</span><br><span class="line">      var imageURL &#x3D; canvass[k4].toDataURL(&quot;image&#x2F;png&quot;);</span><br><span class="line">      var img &#x3D; document.createElement(&quot;img&quot;);</span><br><span class="line">      img.src &#x3D; imageURL;</span><br><span class="line">      img.setAttribute(&#39;style&#39;, &#39;max-width: 100%;&#39;);</span><br><span class="line">      img.className &#x3D; &#39;isNeedRemove&#39;</span><br><span class="line">      &#x2F;&#x2F; canvass[k4].style.display &#x3D; &#39;none&#39;</span><br><span class="line">      &#x2F;&#x2F; canvass[k4].parentNode.style.width &#x3D; &#39;100%&#39;</span><br><span class="line">      &#x2F;&#x2F; canvass[k4].parentNode.style.textAlign &#x3D; &#39;center&#39;</span><br><span class="line">      canvass[k4].parentNode.insertBefore(img, canvass[k4].nextElementSibling);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;做分页</span><br><span class="line">    &#x2F;&#x2F;style&#x3D;&quot;page-break-after: always&quot;</span><br><span class="line">&#x2F;&#x2F;     var pages &#x3D; document.querySelectorAll(&#39;.result&#39;);</span><br><span class="line">&#x2F;&#x2F;     for (var k5 &#x3D; 0; k5 &lt; pages.length; k5++) &#123;</span><br><span class="line">&#x2F;&#x2F;       pages[k5].setAttribute(&#39;style&#39;, &#39;page-break-after: always&#39;);</span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">    return this.dom.outerHTML;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  writeIframe: function(content) &#123;</span><br><span class="line">    var w, doc, iframe &#x3D; document.createElement(&#39;iframe&#39;),</span><br><span class="line">      f &#x3D; document.body.appendChild(iframe);</span><br><span class="line">    iframe.id &#x3D; &quot;myIframe&quot;;</span><br><span class="line">    iframe.style &#x3D; &quot;position:absolute;width:0;height:0;top:-10px;left:-10px;&quot;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 判断是否需要chart</span><br><span class="line">    if(document.querySelector(&#39;.myChart&#39;) !&#x3D;&#x3D; null)&#123;</span><br><span class="line">      iframe.setAttribute(&#39;style&#39;, &#39;position:absolute;width:&#39; + document.querySelector(&#39;.myChart&#39;).clientWidth + &#39;px;height:0;top:-10px;left:-10px;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    w &#x3D; f.contentWindow || f.contentDocument;</span><br><span class="line">    doc &#x3D; f.contentDocument || f.contentWindow.document;</span><br><span class="line">    doc.open();</span><br><span class="line">    doc.write(content);</span><br><span class="line">    doc.close();</span><br><span class="line"></span><br><span class="line">    var removes &#x3D; document.querySelectorAll(&#39;.isNeedRemove&#39;);</span><br><span class="line">    for (var k &#x3D; 0; k &lt; removes.length; k++) &#123;</span><br><span class="line">      removes[k].parentNode.removeChild(removes[k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var _this &#x3D; this</span><br><span class="line">    iframe.onload &#x3D; function() &#123;</span><br><span class="line">      _this.toPrint(w);</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        document.body.removeChild(iframe)</span><br><span class="line">      &#125;, 100)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  toPrint: function(frameWindow) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        frameWindow.focus();</span><br><span class="line">        try &#123;</span><br><span class="line">          if (!frameWindow.document.execCommand(&#39;print&#39;, false, null)) &#123;</span><br><span class="line">            frameWindow.print();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          frameWindow.print();</span><br><span class="line">        &#125;</span><br><span class="line">        frameWindow.close();</span><br><span class="line">      &#125;, 10);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.log(&#39;err&#39;, err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isDOM: (typeof HTMLElement &#x3D;&#x3D;&#x3D; &#39;object&#39;) ?</span><br><span class="line">    function(obj) &#123;</span><br><span class="line">      return obj instanceof HTMLElement;</span><br><span class="line">    &#125; : function(obj) &#123;</span><br><span class="line">      return obj &amp;&amp; typeof obj &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; obj.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; typeof obj.nodeName &#x3D;&#x3D;&#x3D; &#39;string&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const MyPlugin &#x3D; &#123;&#125;</span><br><span class="line">MyPlugin.install &#x3D; function(Vue, options) &#123;</span><br><span class="line">  &#x2F;&#x2F; 4. 添加实例方法</span><br><span class="line">  Vue.prototype.$print &#x3D; Print</span><br><span class="line">&#125;</span><br><span class="line">export default MyPlugin</span><br></pre></td></tr></table></figure>

<p>在页面中使用的时候,将需要打印的div设置一个id就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;打印页面内容</span><br><span class="line">printContent() &#123;</span><br><span class="line">  this.$print(document.querySelector(&#39;#printPage&#39;))</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p>以上就是我对导出和打印的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue使用history模式部署ng服务器</title>
    <url>/2019/12/13/111-Vue-cli%E4%BD%BF%E7%94%A8history%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>由于微信更新到7.0.9后不识别url地址栏上面的#,所以只能使用history模式,来看看有哪些需要注意的地方</p>
</blockquote>
<a id="more"></a>

<p>首先，按照官网的写法，添加history模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是仅仅这样是不够的,会导致刷新发生404,这一点官网也有说明,而且我的项目打包后在nginx的服务器上不是放在根目录上,所以对路径也有要求</p>
<p>ng服务器上应该这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       8080;</span><br><span class="line">  server_name  localhost;</span><br><span class="line">  #charset koi8-r;</span><br><span class="line">  #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">      try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">      root   html; #这里是文件的位置，可以直接写绝对路径</span><br><span class="line">      index  index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样配置后，打开的浏览器就可以直接访问到了。<code>127.0.0.1:8080/index.html</code></p>
<p>假设我的路径不想放在根目录下,我想要多一层路径用来区分,假设我的文件放在html下面的dev文件下的pay</p>
<p>那ng服务器应该这样配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;dev&#x2F;pay &#123;</span><br><span class="line">  try_files $uri $uri&#x2F; &#x2F;dev&#x2F;pay&#x2F;index.html; </span><br><span class="line">  root   html; </span><br><span class="line">  index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try_files</code>的意思也很好理解,寻找<code>$uri</code>,没有就匹配<code>$uri/</code>,都没有就进入<code>/dev/pay/index.html</code>,加这一句话也是为了刷新的时候不会出现404</p>
<p>ng这样配置之后,vue-cli也要做相应的配置,不然页面进来是白屏的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  base: &#39;&#x2F;dev&#x2F;pay&#x2F;&#39;,</span><br><span class="line">  routes: router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>到这里,vue使用history模式部署ng服务器都可以使用了</p>
<p>两种写法,不同的需求,需要哪个就使用哪个</p>
<p>以上就是我对vue使用history模式部署ng服务器的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript基础学习</title>
    <url>/2019/12/16/112-TypeScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>TypeScript现在已经越来越受到前端的使用了,和ECMAScript 6一样,慢慢的普及开来了</p>
</blockquote>
<a id="more"></a>

<p>TypeScript和其他的区别和好处在哪里我就不说了,既然选择学习它,就一定有它的优点</p>
<p>本篇学习技术胖的视频…谢谢大佬的分享</p>
<h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>命令窗口打开 </p>
<ol>
<li><p>安装插件: npm install typescript -g</p>
</li>
<li><p>初始化项目: 进入你的编程文件夹后,可以使用npm init -y来初始化项目,生成package.json文件。</p>
</li>
<li><p>创建tsconfig.json文件: 在终端中输入tsc –init</p>
</li>
</ol>
<p>默认情况下,tsc会使用默认的编译配置编译目录中的所有.ts文件。通过书写tsconfig.json,我们可以配置tsc的编译行为,达到想要的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,   &#x2F;&#x2F;指定生成哪个模块系统代码</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,        &#x2F;&#x2F;目标代码类型</span><br><span class="line">    &quot;noImplicitAny&quot;: false, &#x2F;&#x2F;在表达式和声明上有隐含的&#39;any&#39;类型时报错。</span><br><span class="line">    &quot;sourceMap&quot;: false,     &#x2F;&#x2F;用于debug   </span><br><span class="line">    &quot;rootDir&quot;:&quot;.&#x2F;src&quot;,      &#x2F;&#x2F;仅用来控制输出的目录结构--outDir。</span><br><span class="line">    &quot;outDir&quot;:&quot;.&#x2F;build&quot;,     &#x2F;&#x2F;重定向输出目录。   </span><br><span class="line">    &quot;watch&quot;:true            &#x2F;&#x2F;在监视模式下运行编译器。会监视输出文件,在它们改变时重新编译。</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;include&quot;:[</span><br><span class="line">    &quot;.&#x2F;src&#x2F;**&#x2F;*&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;exclude&quot;:[</span><br><span class="line">    &quot;views&quot;,</span><br><span class="line">    &quot;static&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>安装@types/node:  npm install –save-dev @types/node,这个主要是解决模块的声明文件问题。</p>
</li>
<li><p>写完ts文件,可以使用tsc Hello.ts 转化成 Hello.js,也可以在Vscode的任务菜单下,打开运行生成任务,然后选择tsc：构建-tsconfig.json</p>
</li>
</ol>
<p>到此准备工作都已经做完了,现在开始正式的写ts</p>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>TypeScript最大的一个特点就是变量是强类型的,也就是说,在声明变量的时候,我们必须给他一个类型。所以我们先来看一下有哪些类型</p>
<p>TypeScript中的数据类型有：</p>
<ul>
<li>Undefined : 未定义;</li>
<li>Number:数值类型;</li>
<li>string : 字符串类型;</li>
<li>Boolean: 布尔类型；</li>
<li>enum：枚举类型；</li>
<li>any : 任意类型,一个牛X的类型；</li>
<li>void：空类型；</li>
<li>Array : 数组类型;</li>
<li>Tuple : 元祖类型；</li>
<li>Null ：空类型。</li>
</ul>
<p>我们先来看一下怎样声明一个变量</p>
<p>普通的是这样的 <code>var name = &#39;csing&#39;</code></p>
<p>TypeScript声明时需要一个类型 <code>var name:string = &#39;csing&#39;</code></p>
<p>和vue组件中prop的概念有点类似,提前定义好变量类型</p>
<p>一些我们常用的变量类型就不说了,说一下上面我们不经常用到的几个类型</p>
<h4 id="enum类型"><a href="#enum类型" class="headerlink" title="enum类型"></a>enum类型</h4><p>枚举类型,我们用的比较少,什么场景下使用呢?有很多值是多个并且是固定的,比如：</p>
<p>一年的季节：春、夏、秋、冬 有四个结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum JiJie&#123;c,x,q,d&#125;</span><br><span class="line">console.log(JiJie.c) &#x2F;&#x2F; 返回0,类似数组索引</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 也可以进行赋值</span><br><span class="line">enum JiJie&#123;</span><br><span class="line">  c&#x3D; &#39;春&#39;,</span><br><span class="line">  x&#x3D; &#39;夏&#39;,</span><br><span class="line">  q&#x3D; &#39;秋&#39;,</span><br><span class="line">  d&#x3D; &#39;冬&#39;</span><br><span class="line">&#125;</span><br><span class="line">console.log(JiJie.c) &#x2F;&#x2F; 返回&#39;春&#39;这个字</span><br></pre></td></tr></table></figure>

<h4 id="any类型"><a href="#any类型" class="headerlink" title="any类型"></a>any类型</h4><p>既然ts需要提前定义好变量类型,为什么又要有any类型呢</p>
<p>因为一个写惯了前端的人,有时候不自觉的就分不清类型了。<br>这是个不好的习惯,也是前端的痛,就因为这个原因,JavaScript也多次被人诟病说大型项目不适合用JavaScript。<br>但是习惯一旦养成,改是需要时间和磨练的。TypeScript友好的为我们提供了一种特殊的类型any,比如我们在程序中不断变化着类型,又不想让程序报错,这时候就可以使用any了。</p>
<h4 id="Tuple类型"><a href="#Tuple类型" class="headerlink" title="Tuple类型"></a>Tuple类型</h4><p>元祖是一种特殊的数组,元祖类型允许表示一个已知元素数量和类型的数组,各元素的类型不必相同。<br>比如,你可以定义一对值分别为string和number类型的元祖。元祖在实际开发中使用的非常少,大家了解一下就可以了,不做过多介绍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明一个元祖类型</span><br><span class="line">let x : [string,number]</span><br><span class="line">&#x2F;&#x2F;正确的初始化</span><br><span class="line">x &#x3D; [&#39;hello&#39;,10]</span><br><span class="line">&#x2F;&#x2F;错误的初始化方法</span><br><span class="line">x &#x3D; [10,&#39;hello&#39;]</span><br></pre></td></tr></table></figure>

<h4 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h4><p>一般是用在函数里面的,学习过java的同学应该比较熟悉,当函数没有返回值的时候,就要定义一个void</p>
<h3 id="TypeScript的函数声明"><a href="#TypeScript的函数声明" class="headerlink" title="TypeScript的函数声明"></a>TypeScript的函数声明</h3><p>函数的声明需要注意以下几点</p>
<ol>
<li>声明(定义)函数必须加 function 关键字</li>
<li>函数名与变量名一样,命名规则按照标识符规则</li>
<li>函数参数可有可无,多个参数之间用逗号隔开</li>
<li>每个参数参数由名字与类型组成,之间用分号隔开</li>
<li>函数的返回值可有可无,没有时,返回类型为 void</li>
<li>大括号中是函数体。</li>
</ol>
<p>举个例子,我要创建一个函数,来说明自己几岁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function speckAge(age:number):string&#123;</span><br><span class="line">  return &#39;我现在&#39;+age+&#39;岁了&#39; </span><br><span class="line">&#125;</span><br><span class="line">var age:number &#x3D; 18</span><br><span class="line">var result:string &#x3D; speckAge(age)</span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在函数调用的时候,我们需要按照形参的规则传递实参,有几个形参就要传递几个实参,并且每一个实参的类型要与对应的形参类型一致。</p>
</blockquote>
<p>什么是形参? 函数定义的时候写的参数是形参。<br>什么是实参? 调用函数时传递的具体值就是实参。</p>
<h4 id="函数参数形式"><a href="#函数参数形式" class="headerlink" title="函数参数形式"></a>函数参数形式</h4><p>TypeScript的函数参数是比较灵活的,函数的形参分为:可选形参、默认形参、剩余参数形参等。</p>
<h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>可选参数,就是我们定义形参的时候,可以定义一个可传可不传的参数。这种参数,在定义函数的时候通过?标注。</p>
<p><code>function speckAge(age:number,name?:string):string{}</code></p>
<p>当name没有值传入的时候,会给一个默认是undefined</p>
<h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>默认参数就更好理解了,就是我们不传递的时候,他会给我们一个默认值,而不是undefined了。</p>
<p><code>function speckAge(age:number = 18,name?:string = &#39;csing&#39;):string{}</code></p>
<p>当没有值传入时使用默认值,当有值传入时,优先使用实参</p>
<h5 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h5><p>有时候我们有这样的需求,我传递给函数的参数个数不确定。例如：我要介绍自己很多兴趣。这时候你不能限制我,我要随心所欲。</p>
<p>剩余参数就是形参是一个数组,传递几个实参过来都可以直接存在形参的数组中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function interest(...qui:string[]):string&#123;</span><br><span class="line">  let yy:string &#x3D; &#39;我喜欢&#39;</span><br><span class="line">  for(let key in qui)&#123;</span><br><span class="line">    yy &#x3D; yy + qui[key]</span><br><span class="line">    if(parseInt(key) &lt; qui.length - 1)&#123;</span><br><span class="line">      yy&#x3D;yy+&#39;、&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var result:string  &#x3D;  interest(&#39;唱&#39;,&#39;跳&#39;,&#39;rap&#39;,&#39;篮球&#39;,&#39;Music&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="函数的三种声明方式"><a href="#函数的三种声明方式" class="headerlink" title="函数的三种声明方式"></a>函数的三种声明方式</h3><p>其实原理和我们之前的差不多</p>
<ul>
<li>函数声明法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(n1:number,n2:number):number&#123;</span><br><span class="line">    return n1+n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数表达式法 ,声明了必须使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var add2 &#x3D; function(n1:number,n2:number):number&#123;</span><br><span class="line">    return n1+n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>箭头函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var add3 &#x3D; (n1:number,n2:number):number&#x3D;&gt;&#123;</span><br><span class="line">    return n1+n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和之前的不同就是声明的时候需要定义好变量类型</p>
<h3 id="函数中变量的作用域"><a href="#函数中变量的作用域" class="headerlink" title="函数中变量的作用域"></a>函数中变量的作用域</h3><p>这个和js的一样,没什么好说的,函数已经都介绍完了,接下来说一下数组</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>声明数组的方法和我们之前差不多,区别在于声明数组的时候需要定义数组内的变量格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr1:number[]     &#x2F;&#x2F;声明一个数值类型的数组</span><br><span class="line">let arr2:Array&lt;string&gt;  &#x2F;&#x2F;声明一个字符串类型的数组</span><br></pre></td></tr></table></figure>

<p>字面量赋值法: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个数组时，直接给数组赋值</span><br><span class="line">let arr2:number[] &#x3D; [1,2,3,4,5]</span><br><span class="line">&#x2F;&#x2F;定义数组 的同事给数组赋值</span><br><span class="line">let arr3:Array&lt;string&gt; &#x3D; [&#39;随便&#39;,&#39;一个&#39;,&#39;单词&#39;]</span><br><span class="line">let arr4:Array&lt;boolean&gt; &#x3D; [ true,false,false]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 声明了什么类似,只能用这个类型</span><br></pre></td></tr></table></figure>

<p>构造函数赋值法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr1:number[] &#x3D; new Array()</span><br><span class="line">let ara2:number[] &#x3D; new Array(1,2,3,4,5)</span><br><span class="line">let arr3:Array&lt;string&gt; &#x3D; new Array(&#39;随便&#39;,&#39;一个&#39;,&#39;单词&#39;)</span><br><span class="line">let arr4:Array&lt;boolean&gt; &#x3D; new Array(true,false,false)</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str1:string &#x3D; &#39;一个字符&#39;</span><br><span class="line">let str2:String &#x3D; new String(&quot;另一个字符&quot;)</span><br></pre></td></tr></table></figure>

<p>用法和js的一样,获取字符串长度,截取什么的</p>
<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let d:Date &#x3D; new Date()</span><br></pre></td></tr></table></figure>

<p>其他用法和js一样</p>
<h3 id="正则表达式声明"><a href="#正则表达式声明" class="headerlink" title="正则表达式声明"></a>正则表达式声明</h3><p>创建正则表达式也提供了两种方法，一种是才采用new 关键字，另一种是采用字面量的方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数法</span><br><span class="line">let reg1:RegExp &#x3D; new RegExp(&quot;csing&quot;)  &#x2F;&#x2F;表示字符串规则里含有csing</span><br><span class="line">let reg2:RegExp &#x3D; new RegExp(&quot;csing&quot;,&#39;gi&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字面量创建</span><br><span class="line">let reg3:RegExp &#x3D; &#x2F;csing&#x2F;</span><br><span class="line">let reg4:RegExp &#x3D; &#x2F;csing&#x2F;gi</span><br></pre></td></tr></table></figure>

<h4 id="RegExp常用方法"><a href="#RegExp常用方法" class="headerlink" title="RegExp常用方法"></a>RegExp常用方法</h4><p>RegExp对象包含两个方法：test( )和exec( ),功能基本相似，用于测试字符串匹配。</p>
<p>test(string) ：在字符串中查找是否存在指定的正则表达式并返回布尔值，如果存在则返回 true，不存在则返回 false。<br>exec(string) : 用于在字符串中查找指定正则表达式，如果 exec() 方法执行成功，则返回包含该查找字符串的相关信息数组。如果执行失败，则返回 null。</p>
<h3 id="类的声明和使用"><a href="#类的声明和使用" class="headerlink" title="类的声明和使用"></a>类的声明和使用</h3><p>关于类,在ES6中也有提到过,今天再学习一下类的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CaiXuKun&#123;</span><br><span class="line">  name:string;</span><br><span class="line">  age:number;</span><br><span class="line">  constructor(name:string,age:number)&#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.age &#x3D; age </span><br><span class="line">  &#125;</span><br><span class="line">  say()&#123;</span><br><span class="line">    console.log(&#39;大家好,我是菜虚鲲&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let kun:CaiXuKun &#x3D; new CaiXuKun(&#39;菜虚鲲&#39;,18)</span><br><span class="line">console.log(kun)</span><br><span class="line">kun.say()</span><br></pre></td></tr></table></figure>

<p>我们先用class关键字声明了一个类，并在里边声明了name和age属性。constructor为构造函数。构造函数的主要作用是给类中封装的属性进行赋值。</p>
<p>使用和定义类其实很简单，关键是理解类的思想。要有抽象逻辑的能力，这样才能复用和增强维护性。</p>
<h4 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h4><p>TypeScript语言和后端的很像，类中属性的访问可以用访问修饰符来进行限制。访问修饰符分为：public、protected、private。</p>
<ul>
<li>public:公有修饰符，可以在类内或者类外使用public修饰的属性或者行为，默认修饰符。</li>
<li>protected:受保护的修饰符，可以本类和子类中使用protected修饰的属性和行为。</li>
<li>private : 私有修饰符，只可以在类内使用private修饰的属性和行为。</li>
</ul>
<p>直接在代码中说话,还是刚刚那个代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CaiXuKun&#123;</span><br><span class="line">  public sex:string</span><br><span class="line">  protected name:string</span><br><span class="line">  private age:number</span><br><span class="line">  public constructor(sex:string,name:string,age:number)&#123;</span><br><span class="line">    this.sex&#x3D;sex</span><br><span class="line">    this.name&#x3D;name</span><br><span class="line">    this.age&#x3D;age</span><br><span class="line">  &#125;</span><br><span class="line">  public sayHello()&#123;</span><br><span class="line">    console.log(&#39;我的鲲们,你们好&#39;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected sayLove()&#123;</span><br><span class="line">    console.log(&#39;老虎油&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let kun:CaiXuKun &#x3D; new CaiXuKun(&#39;女&#39;,&#39;菜虚鲲&#39;,18)</span><br><span class="line"></span><br><span class="line">console.log(kun.sex)</span><br><span class="line">console.log(kun.name)   &#x2F;&#x2F;报错</span><br><span class="line">console.log(kun.age)    &#x2F;&#x2F;报错</span><br><span class="line">kun.sayHello()</span><br><span class="line">kun.sayLove()    &#x2F;&#x2F;报错</span><br></pre></td></tr></table></figure>

<blockquote>
<p>public是都可以使用的,protected只能自己本类或者后面继承的子类可以使用,private只能自己本类使用</p>
</blockquote>
<p>还有一个修饰符叫作只读修饰符,用的比较少,有点类似const</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Man&#123;</span><br><span class="line">  public readonly sex:string &#x3D; &#39;男&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var man:Man &#x3D; new Man()</span><br><span class="line">man.sex&#x3D;&#39;女&#39; &#x2F;&#x2F;报错</span><br></pre></td></tr></table></figure>

<h3 id="类的继承和重写"><a href="#类的继承和重写" class="headerlink" title="类的继承和重写"></a>类的继承和重写</h3><h4 id="类方法继承"><a href="#类方法继承" class="headerlink" title="类方法继承"></a>类方法继承</h4><p>类的继承和ES6的相类似</p>
<p>首先创建一个父类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CaiXuKun&#123;</span><br><span class="line">  public name:string</span><br><span class="line">  public age : number</span><br><span class="line">  public skill: string</span><br><span class="line">  constructor(name:string,age:number,skill:string)&#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.age &#x3D; age</span><br><span class="line">    this.skill &#x3D; skill</span><br><span class="line">  &#125;</span><br><span class="line">  public interest()&#123;</span><br><span class="line">    console.log(&#39;我是两年半的练习生&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cxk:CaiXuKun &#x3D; new CaiXuKun(&#39;菜虚鲲&#39;,18,&#39;唱,跳,rap,篮球,music&#39;)</span><br><span class="line">cxk.interest()</span><br></pre></td></tr></table></figure>

<p>这时候准备继承一下这个类,子类有父类所有的特点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class KunKun extends CaiXuKun&#123;</span><br><span class="line">  public xingxiang:string &#x3D; &#39;娘娘腔&#39;</span><br><span class="line">  public jineng()&#123;</span><br><span class="line">    console.log(&#39;人家用小拳拳打你胸口&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let kk &#x3D; new KunKun(&#39;菜虚鲲&#39;,18,&#39;唱,跳,rap,篮球,music&#39;)</span><br><span class="line">kk.interest()</span><br><span class="line">kk.jineng()</span><br></pre></td></tr></table></figure>

<h4 id="类方法重写"><a href="#类方法重写" class="headerlink" title="类方法重写"></a>类方法重写</h4><p>重写就是在子类中重写父类的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class KunKun extends CaiXuKun&#123;</span><br><span class="line">  public xingxiang:string &#x3D; &#39;娘娘腔&#39;</span><br><span class="line">  public interest()&#123;</span><br><span class="line">    super.interest()</span><br><span class="line">    console.log(&#39;鸡你太美&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  public jineng()&#123;</span><br><span class="line">    console.log(&#39;人家用小拳拳打你胸口&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写过后,再调用<code>interest</code>这个方法,会将两个都输出出来</p>
<p>类的基础学习大概就这么多啦</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在通常情况下，接口是用来定义一些规范，使用这些接口，就必须实现按照接口中的规范来走。</p>
<p>定义接口的关键字是<code>interface</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface KunKun &#123;</span><br><span class="line">  sex:string</span><br><span class="line">  interest:string</span><br><span class="line">&#125;</span><br><span class="line">let cxk:KunKun &#x3D;&#123; sex:&#39;女&#39;,interest:&#39;鸡你太美&#39;&#125;</span><br><span class="line">console.log(cxk)</span><br></pre></td></tr></table></figure>

<p>如果有一些参数是可传可不传的,可以用?代替</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface KunKun &#123;</span><br><span class="line">  sex:string</span><br><span class="line">  interest:string</span><br><span class="line">  music?:Boolean</span><br><span class="line">&#125;</span><br><span class="line">let cxk:KunKun &#x3D;&#123; sex:&#39;女&#39;,interest:&#39;鸡你太美&#39;,music:true&#125;</span><br></pre></td></tr></table></figure>


<h4 id="规范函数类型接口"><a href="#规范函数类型接口" class="headerlink" title="规范函数类型接口"></a>规范函数类型接口</h4><p>我们还可以使用接口来规范函数类型的接口，我们需要哪些资源，在函数中进行匹配，最后返回是否匹配成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface  SearchMan&#123;</span><br><span class="line">    (source:string,subString:string):boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch:SearchMan</span><br><span class="line"></span><br><span class="line">mySearch &#x3D; function(source:string,subString:string):boolean&#123;</span><br><span class="line">    let flag &#x3D;source.search(subString)</span><br><span class="line">    return (flag !&#x3D; -1)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">console.log(mySearch(&#39;高、富、帅&#39;,&#39;胖&#39;))  &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>命名空间，又称内部模块，被用于组织有些具有内在联系的特性和对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace shuaiGe&#123;</span><br><span class="line">  export class Dehua&#123;</span><br><span class="line">    public name:string &#x3D; &#39;刘德华&#39;</span><br><span class="line">    talk()&#123;</span><br><span class="line">      console.log(&#39;我是帅哥刘德华&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace bajie&#123;</span><br><span class="line">  export class Dehua&#123;</span><br><span class="line">    public name:string &#x3D; &#39;马德华&#39;</span><br><span class="line">    talk()&#123;</span><br><span class="line">      console.log(&#39;我是二师兄马德华&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dehua1:shuaiGe.Dehua &#x3D; new shuaiGe.Dehua()</span><br><span class="line">let dehua2:shuaiGe.Dehua &#x3D; new bajie.Dehua()</span><br><span class="line">dehua1.talk()</span><br><span class="line">dehua2.talk()</span><br></pre></td></tr></table></figure>

<p>如果你已经学到了这里，我建议你也学一下ES6的语法，因为Typescript的语法和ES6的有很多都一样，比如说promise，async/await所以我就不在这里讲述了。有兴趣的小伙伴可以学一下。</p>
<p>以上就是我对TypeScript基础的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli 4.0学习</title>
    <url>/2019/12/18/113-vue-cli4.0%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>什么都不能阻挡我吐槽前端更新的速度了 ! ! !</p>
</blockquote>
<a id="more"></a>

<p>最近公司的项目终于到了空闲期，而闲不住的我终于打算研究一下Vue-cli 3了,本篇文章就是主要记录Vue-cli3.0 的搭建过程</p>
<h3 id="升级本地环境"><a href="#升级本地环境" class="headerlink" title="升级本地环境"></a>升级本地环境</h3><p>因为 vue-cli3.0 要 nodeJs ≧ 8.9（官方推荐 8.11.0+），所以我们先去升级一下Node</p>
<p>我安装的是 node8.12.0的版本,怎么安装node选择版本在我之前的博客有说</p>
<p>之后就可以升级vue-cli了</p>
<p>都说要把之前的卸载,其实不卸载也是可以的</p>
<p>直接安装</p>
<p><code>npm install -g @vue/cli</code></p>
<p>由于我的项目还有很多是vue-cli 2 的..所以我希望在vue-cli3的版本也可以使用它,再安装一个桥接工具插件</p>
<p><code>npm install -g @vue/cli-init</code></p>
<p>好了,输入 <code>vue -V</code> 查看版本</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/113-vue4.0.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="版本号"></p>
<p>我草草草草草草… 最近只顾着看技术了，没发现10月16日官方已经宣布 vue-cli4.0 已经正式发布了! ! !</p>
<p>有没有搞错，我 vue-cli3.0 都还没用,已经升级到 4.0了,那就直接开始搞 vue-cli4.0 吧!</p>
<h3 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h3><p>vue-cli3.0 以后项目创建的命令变成了下面这样</p>
<p><code>vue create &lt;Project Name&gt; //文件名 不支持驼峰（含大写字母）</code></p>
<p>动手开始输入</p>
<p><code>vue create myapp</code></p>
<p>emmmmm…….</p>
<p>怎么和网上的教程不一样,我怎么第一步就报错了</p>
<p>提示 Vue packages version mismatch 报错</p>
<p>上百度找一下原因..原来是vue版本不匹配,和<code>vue-template-compiler</code>的版本不同</p>
<p>看一下自己命令行里面的版本是多少,然后修改vue的版本</p>
<p><code>npm install vue@2.6.10 --save -g</code> 就可以解决了</p>
<p>开始正式的创建项目</p>
<p>输入 <code>vue create myapp</code></p>
<p>出现了两个选项</p>
<p>default 是使用默认配置</p>
<p>Manually select features 是自定义配置</p>
<p>选择第二个自己配置</p>
<p>我的自定义配置如下,配置一样,图片是网上找的</p>
<p><img src="https://img-blog.csdnimg.cn/20191025111842872.png" alt="https://img-blog.csdnimg.cn/20191025111842872.png"></p>
<p>选择是否使用路由 history router，其实直白来说就是是否路径带 # 号，建议选择 N，否则服务器还要进行配置</p>
<p><img src="https://img-blog.csdnimg.cn/20191025112058459.png" alt="https://img-blog.csdnimg.cn/20191025112058459.png"></p>
<p>css 的预处理器我选择的是 Sass/SCSS(with dart-sass) 。node-sass是自动编译实时的，dart-sass需要保存后才会生效</p>
<p>sass 官方目前主力推 dart-sass 最新的特性都会在这个上面先实现</p>
<p><img src="https://img-blog.csdnimg.cn/20191025112439146.png" alt="https://img-blog.csdnimg.cn/20191025112439146.png"></p>
<p>选择 ESLint 代码校验规则，提供一个插件化的javascript代码检测工具，ESLint + Prettier 使用较多</p>
<p><img src="https://img-blog.csdnimg.cn/20191025112705635.png" alt="https://img-blog.csdnimg.cn/20191025112705635.png"></p>
<p>然后选择什么时候进行代码校验，Lint on save 保存就检查，Lint and fix on commit   fix 或者 commit 的时候检查，建议第一个</p>
<p><img src="https://img-blog.csdnimg.cn/20191025112927950.png" alt="https://img-blog.csdnimg.cn/20191025112927950.png"></p>
<p>下面就是如何存放配置了，In dedicated config files 存放到独立文件中，In package.json 存放到 package.json 中</p>
<p>本着项目结构简单的想法，我选择了第二个</p>
<p><img src="https://img-blog.csdnimg.cn/20191025113213668.png" alt="https://img-blog.csdnimg.cn/20191025113213668.png"></p>
<p>最后就是是否保存本次的配置了，N 不记录，如果选择 Y 需要输入保存名字</p>
<p><img src="https://img-blog.csdnimg.cn/20191025113436834.png" alt="https://img-blog.csdnimg.cn/20191025113436834.png"></p>
<p>然后就等待创建项目</p>
<p>创建好之后,就cd进入文件夹,<code>npm run serve</code>启动项目</p>
<blockquote>
<p>这里有一个小黑科技,输入 vue ui 可以启动vue的启动图形化界面</p>
</blockquote>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>由于vue4.0取消了以前的那些配置文件,所以我们需要在根目录自己创建一个<code>vue.config.js</code></p>
<p>配置项很多,可以去<a href="https://cli.vuejs.org/zh/config/#全局-cli-配置" target="_blank" rel="noopener">官网</a>看看,我这里就不再细说了,贴一个我自己的配置.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  publicPath: &#39;.&#x2F;&#39;,</span><br><span class="line">  &#x2F;&#x2F; 输出文件目录,默认就是dist</span><br><span class="line">  outputDir: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;test&quot; ? &#39;distTest&#39; : &#39;distPro&#39;,</span><br><span class="line">  &#x2F;&#x2F; 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。</span><br><span class="line">  assetsDir: &#39;static&#39;,</span><br><span class="line">  &#x2F;&#x2F; 生产环境是否生成 sourceMap 文件</span><br><span class="line">  productionSourceMap: false,</span><br><span class="line">  &#x2F;&#x2F; 配置es-link true,&#39;error&#39;</span><br><span class="line">  lintOnSave: true,</span><br><span class="line">  css: &#123;  &#x2F;&#x2F; 一次配置，全局使用，这个scss 因为每个文件都要引入</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        prependData: &#96;@import &quot;.&#x2F;src&#x2F;assets&#x2F;css&#x2F;index.scss&quot;;&#96;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; webpack-dev-server 相关配置</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    &#x2F;&#x2F; 可以通过设置让浏览器 overlay 同时显示警告和错误：</span><br><span class="line">    overlay: &#123;</span><br><span class="line">      warnings: false,</span><br><span class="line">      errors: false</span><br><span class="line">    &#125;,</span><br><span class="line">    open: false,</span><br><span class="line">    host: &#39;localhost&#39;,</span><br><span class="line">    port: 8080,</span><br><span class="line">    https: false,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#39;&#x2F;mgr&#39;: &#123;</span><br><span class="line">        target: &#39;https:&#x2F;&#x2F;api.douban.com&#39;,</span><br><span class="line">        ws: true,</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite:&#123;</span><br><span class="line">          &#39;^&#x2F;mgr&#39;: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  configureWebpack:&#123;  &#x2F;&#x2F; 覆盖webpack默认配置的都在这里</span><br><span class="line">    resolve:&#123;   &#x2F;&#x2F; 配置解析别名</span><br><span class="line">      alias:&#123;</span><br><span class="line">        &#39;@&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#39;)</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动的时候报错了,终于在查了很久之后发现这里的一个坑,就是在使用最新版本的sass-loader(version&gt;=8.0.0)的时候 data 这个配置已经不再支持，这里是本次更新的issus(<a href="https://github.com/webpack-contrib/sass-loader/issues/760" target="_blank" rel="noopener">https://github.com/webpack-contrib/sass-loader/issues/760</a> ),而是使用 prependData 代替</p>
</blockquote>
<p>以上就是我对vue-cli4.0的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli中proxy的pathRewrite该怎么使用</title>
    <url>/2019/12/19/114-pathRewrite%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>很多同学明明配置好了跨域,可是接口还是返回404,不明所以</p>
</blockquote>
<a id="more"></a>

<p>跨域的原理我就不讲了</p>
<p>直接上代码显示</p>
<p>假如我的接口是<code>https://api.douban.com/v2/music/search?q=周杰伦</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    &#39;&#x2F;mgr&#39;: &#123;</span><br><span class="line">      target: &#39;https:&#x2F;&#x2F;api.douban.com&#39;,</span><br><span class="line">      ws: true,</span><br><span class="line">      changeOrigin: true,</span><br><span class="line">      pathRewrite:&#123;</span><br><span class="line">        &#39;^&#x2F;mgr&#39;: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>那我调用时就可以将接口写成这样<code>/mgr/v2/music/search?q=周杰伦</code></p>
<p>那这个pathRewrite到底是干嘛用的,为什么有时候需要写,有时候不需要写</p>
<p>其实很简单,用代理, 首先你得有一个标识, 告诉node, 我接口只要是’/mgr’开头的才用代理.所以你的接口就要这么写 /mgr/xx/xx. 最后代理的路径就是 <a href="http://xxx.xx.com/mgr/xx/xx" target="_blank" rel="noopener">http://xxx.xx.com/mgr/xx/xx</a>.</p>
<p>可是不对啊, 我正确的接口路径里面没有/mgr啊. 所以就需要 pathRewrite,用<code>&#39;^/mgr&#39;:&#39;&#39;</code>, 把’/mgr’去掉, 这样既能有正确标识, 又能在请求接口的时候去掉mgr.</p>
<p>现在换一种不用pathRewrite的写法</p>
<p>接口同样不变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    &#39;&#x2F;v2&#39;: &#123;</span><br><span class="line">      target: &#39;https:&#x2F;&#x2F;api.douban.com&#39;,</span><br><span class="line">      ws: true,</span><br><span class="line">      changeOrigin: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这时候接口就要写成这样<code>/v2/music/search?q=周杰伦</code>,因为v2是真的在接口中出现的,不能去掉</p>
<p>以上就是我对pathRewrite的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 4.0 打包配置不同环境</title>
    <url>/2019/12/20/115-Vue-cli%204.0%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>在之前已经写过了vue 2.0的打包配置,今天写一下4.0的配置,略微有些区别</p>
</blockquote>
<a id="more"></a>

<p>相比较于之前的版本,4.0的配置显得较为简单一些</p>
<p>首先在根目录下创建三个文件</p>
<p>.env .env.test .env.production</p>
<ul>
<li><p>.env 本地环境</p>
<span class="label info">NODE_ENV=development</span>
</li>
<li><p>.env.test 测试环境</p>
<span class="label info">NODE_ENV=test</span>
</li>
<li><p>.env.production 生产环境</p>
<span class="label info">NODE_ENV=production</span>

</li>
</ul>
<p>配置好后,在api.js中就可以直接使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let baseUrl&#x3D; &quot;&quot;;</span><br><span class="line">switch (process.env.NODE_ENV) &#123;</span><br><span class="line">  case &#39;development&#39;:</span><br><span class="line">    baseUrl &#x3D; &quot;&#x2F;mgr&quot; &#x2F;&#x2F;开发环境url</span><br><span class="line">    break</span><br><span class="line">  case &#39;test&#39;:</span><br><span class="line">    baseUrl &#x3D; &quot;&#x2F;test&quot; &#x2F;&#x2F;测试环境中的url</span><br><span class="line">    break</span><br><span class="line">  case &#39;production&#39;:</span><br><span class="line">    baseUrl &#x3D; &quot;&#x2F;production&quot; &#x2F;&#x2F;生产环境url</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于这个baseUrl,有人喜欢也在.env中文件直接配置好,这个看个人爱好</p>
<p>再来看看config中怎么配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 输出文件目录,默认就是dist</span><br><span class="line">  outputDir: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;test&quot; ? &#39;distTest&#39; : &#39;distPro&#39;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将测试和正式环境分开来,打包在不同的文件夹里面</p>
<p>最后就是配置命令了,和之前一样,在package.json中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">  &quot;test&quot;: &quot;vue-cli-service build --mode test&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;vue-cli-service build --mode production&quot;,</span><br><span class="line">  &quot;all&quot;: &quot;npm run build &amp;&amp; npm run test&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意命名要和文件名一样的</p>
</blockquote>
<p>以上就是我对vue-cli 4.0 打包配置的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中实现人脸识别</title>
    <url>/2020/01/20/116-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>2020年的第一篇博客,手把手教你在vue中使用百度AI开放平台的百度人脸识别能力</p>
</blockquote>
<a id="more"></a>

<p>开始敲代码之前,先做好准备工作</p>
<h3 id="百度智能云"><a href="#百度智能云" class="headerlink" title="百度智能云"></a>百度智能云</h3><p>1、先去百度智能云注册一个账号</p>
<p><a href="https://cloud.baidu.com/campaign/Annualceremony-2020/index.html?track=cp:nsem|pf:pc|pp:npinzhuan-biaoti|pu:wenzineirong|ci:2020ndsd|kw:2180026" target="_blank" rel="noopener">官方网站</a></p>
<p>2、创建人脸识别应用</p>
<p>进入页面后,在侧边栏选择人脸识别,在应用列表中创建一个新的应用,填写【应用名称】和【应用描述】,其他的使用默认值就可以了</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/116-1-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt=""></p>
<p>3、获取秘钥</p>
<p>应用创建成功后,记录下自己的API Key、Secret Key</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/116-2-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt=""></p>
<p>根据百度文档的API,第一次需要讲API Key、Secret Key传过去,用来获取Access Token,之后每一次请求都将这个token传递过去就可以了</p>
<p>4、创建人脸库</p>
<p>新建应用后,在人脸库管理中新增一个库,用来保存人脸识别的图片,这里图片就不贴出来了</p>
<p>至此,需要准备的东西已经准备好了</p>
<h3 id="Node服务端"><a href="#Node服务端" class="headerlink" title="Node服务端"></a>Node服务端</h3><p>服务端的基本东西都要先引入进来,常用的就是express、bodyParser、axios、fs、qs，跨域也顺便处理一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line"></span><br><span class="line">var bodyParser &#x3D; require(&#39;body-parser&#39;);</span><br><span class="line"></span><br><span class="line">var axios &#x3D; require(&#39;axios&#39;);</span><br><span class="line"></span><br><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">var qs &#x3D; require(&#39;querystring&#39;);</span><br><span class="line"></span><br><span class="line">var app &#x3D; express();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;limit: &#39;50mb&#39;, extended: true&#125;));</span><br><span class="line">app.use(bodyParser.json(&#123;limit : &quot;50mb&quot;&#125;));  </span><br><span class="line"></span><br><span class="line">app.all(&#39;*&#39;, function(req, res, next) &#123;</span><br><span class="line">  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, X-File-Type, Cache-Control, Origin&quot;);</span><br><span class="line">  res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>用于后期需要传入图片,默认的大小为2048Kb左右,所以我们需要稍微调大一点</p>
          </div>

<p>1、获取Access Token的接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 人脸识别-获取Access Token</span><br><span class="line">app.post(&#39;&#x2F;getToken&#39;,function(req,res)&#123;</span><br><span class="line">  const param &#x3D; qs.stringify(&#123;</span><br><span class="line">    &#39;grant_type&#39;: &#39;client_credentials&#39;,</span><br><span class="line">    &#39;client_id&#39;: &#39;你的client_id&#39;,</span><br><span class="line">    &#39;client_secret&#39;: &#39;你的client_secret&#39;</span><br><span class="line">  &#125;);</span><br><span class="line">  axios.post(&#39;https:&#x2F;&#x2F;aip.baidubce.com&#x2F;oauth&#x2F;2.0&#x2F;token&#39;, param).then((msg) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取access_token</span><br><span class="line">    res.send(msg.data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2、注册人脸库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.post(&#39;&#x2F;initFace&#39;,function(req,res)&#123;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 请求接口</span><br><span class="line">  var url &#x3D; &#39;https:&#x2F;&#x2F;aip.baidubce.com&#x2F;rest&#x2F;2.0&#x2F;face&#x2F;v3&#x2F;faceset&#x2F;user&#x2F;add?access_token&#x3D;&#39; + req.body.access_token</span><br><span class="line">  &#x2F;&#x2F; 请求的图片数据</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 请求数据</span><br><span class="line">  var data &#x3D; &#123;</span><br><span class="line">    image_type: &#39;BASE64&#39;,</span><br><span class="line">    image: req.body.img,</span><br><span class="line">    group_id: &#39;ceshiGroup&#39;, &#x2F;&#x2F; 之前注册人脸管理库的名字</span><br><span class="line">    user_id: &#39;csing&#39; ,      &#x2F;&#x2F; 这张图片的id</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  axios(&#123;</span><br><span class="line">    method: &quot;POST&quot;,</span><br><span class="line">    headers: &#123; &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot; &#125;,</span><br><span class="line">    url: url,</span><br><span class="line">    data: qs.stringify(data),</span><br><span class="line">  &#125;).then((msg)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(msg.data)</span><br><span class="line">    res.send(msg.data)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>3、监测人脸</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.post(&#39;&#x2F;checkFace&#39;,function(req,res)&#123;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 请求接口</span><br><span class="line">  var url &#x3D; &#39;https:&#x2F;&#x2F;aip.baidubce.com&#x2F;rest&#x2F;2.0&#x2F;face&#x2F;v3&#x2F;search?access_token&#x3D;&#39; + req.body.access_token</span><br><span class="line">  &#x2F;&#x2F; 请求的图片数据</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 请求数据</span><br><span class="line">  var data &#x3D; &#123;</span><br><span class="line">    image_type: &#39;BASE64&#39;,</span><br><span class="line">    image: req.body.img,</span><br><span class="line">    group_id_list: &#39;ceshiGroup&#39;, &#x2F;&#x2F; 之前注册人脸管理库的名字</span><br><span class="line">    liveness_control: &#39;HIGH&#39;     &#x2F;&#x2F; 活体监测</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  axios(&#123;</span><br><span class="line">    method: &quot;POST&quot;,</span><br><span class="line">    headers: &#123; &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot; &#125;,</span><br><span class="line">    url: url,</span><br><span class="line">    data: qs.stringify(data),</span><br><span class="line">  &#125;).then((msg)&#x3D;&gt;&#123;</span><br><span class="line">    res.send(msg.data)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>主要就是这三个核心的代码,用来获取Token,注册人脸和识别人脸</p>
          </div>

<h3 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h3><p>人脸识别分为两部分的</p>
<p>人脸注册和人脸识别</p>
<p>这两种分别用两种不同的方式</p>
<ol>
<li>一种是input的图片上传方式来注册人脸识别库</li>
<li>另一种是调用照相机自动识别人脸进行第二步的人脸识别</li>
</ol>
<p>这样不一样的需求就都满足到了</p>
<h4 id="上传图片到人脸识别库"><a href="#上传图片到人脸识别库" class="headerlink" title="上传图片到人脸识别库"></a>上传图片到人脸识别库</h4><p>基本的思路是这样的</p>
<p>进入页面后,执行两部操作</p>
<ol>
<li><p>获取Access_token并保存</p>
</li>
<li><p>初始监听图片选择,这样做的目的是用户点击input后,拍照或者选择照片,可以识别到用户的动作,将图片自动处理保存</p>
</li>
</ol>
<p>直接看看具体的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;div&gt;该页面为初始化识别库,添加识别人脸&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; capture&#x3D;&#39;camera&#39; accept&#x3D;&#39;image&#x2F;*&#39;&gt;</span><br><span class="line">    &lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;postFace&quot;&gt;上传人脸识别库&lt;&#x2F;button&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;HelloWorld&#39;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        access_token: &#39;&#39;,</span><br><span class="line">        imgbase64: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      &#x2F;&#x2F; 初始监听图片选择</span><br><span class="line">      initListenMsg()&#123;</span><br><span class="line">        var inputs &#x3D; document.querySelectorAll(&#39;input[type&#x3D;file]&#39;);</span><br><span class="line">        var _this &#x3D; this</span><br><span class="line"></span><br><span class="line">        inputs[0].onchange &#x3D; function() &#123;</span><br><span class="line">          var file &#x3D; document.querySelector(&#39;input&#39;).files[0];</span><br><span class="line">          var reader &#x3D; new FileReader();</span><br><span class="line">           &#x2F;&#x2F; 文件读取成功完成时触发</span><br><span class="line">          reader.onload &#x3D; function(e)&#123;</span><br><span class="line">            &#x2F;&#x2F; onload事件的回调函数接受一个事件对象，该对象的target.result就是文件的内容</span><br><span class="line">            _this.imgbase64 &#x3D; e.target.result.replace(&#x2F;^data:image\&#x2F;\w+;base64,&#x2F;, &quot;&quot;);</span><br><span class="line">          &#125;;</span><br><span class="line">          reader.readAsDataURL(file);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 初始化调用Token</span><br><span class="line">      getToken()&#123;</span><br><span class="line">        this.$axios.post(&#39;http:&#x2F;&#x2F;192.168.50.35:3000&#x2F;getToken&#39;,&#123;&#125;).then((res)&#x3D;&gt;&#123;</span><br><span class="line">          console.log(res)</span><br><span class="line">          this.access_token &#x3D; res.data.access_token</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 添加人脸</span><br><span class="line">      postFace()&#123;</span><br><span class="line">        this.$axios.post(&#39;http:&#x2F;&#x2F;192.168.50.35:3000&#x2F;initFace&#39;,&#123;</span><br><span class="line">          access_token: this.access_token,</span><br><span class="line">          img: this.imgbase64</span><br><span class="line">        &#125;).then((res)&#x3D;&gt;&#123;</span><br><span class="line">          if(res.data.error_code &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            alert(&#39;上传百度云AI人脸库管理成功&#39;)</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">            alert(&#39;人脸已存在,请勿重复添加&#39;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      this.initListenMsg();</span><br><span class="line">      this.getToken();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h4><p>图片上传到人脸库中了,接下来就要实验一下,人脸识别是否可以识别到库里面自己的照片</p>
<p>注册人脸库的时候,相机并没有像以前在其他的地方看到的人脸识别那样,有一个框框,自动识别到人脸后拍照上传,具体要怎么做呢,来看看思路</p>
<p>需要用到一个插件,tracking.js, 所以第一步先 <code>npm install tracking</code> 安装</p>
<p>接下里,解释一下这个插件应该怎么使用 </p>
<p>现在dom中创建两个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video width&#x3D;&quot;320&quot; height&#x3D;&quot;240&quot; ref&#x3D;&quot;videoDom&quot; id&#x3D;&quot;video&quot; preload autoplay loop muted&gt;&lt;&#x2F;video&gt;</span><br><span class="line">&lt;canvas width&#x3D;&quot;320&quot; height&#x3D;&quot;240&quot; ref&#x3D;&quot;canvasDOM&quot;&gt;&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure>

<p>这里的<span class="label primary">video</span>是用来展示视频流的,也就是摄像头调用后,在video中可以看到我们的脸</p>
<span class="label primary">canvas</span>则是用来绘制识别人脸的框框,所以这两个元素我们需要使用定位重叠起来

<h4 id="tracking核心功能"><a href="#tracking核心功能" class="headerlink" title="tracking核心功能"></a>tracking核心功能</h4><p>解释一下核心的代码,完整的代码再末尾会贴出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这一步就是用来开启摄像头的,tracking的插件已经帮我们封装好了</span><br><span class="line">tracking.track(this.video, this.tracker, &#123; camera: true &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化tracking参数,官方文档没有解释是干嘛用的,先照这些</span><br><span class="line">this.tracker &#x3D; new tracking.ObjectTracker(&quot;face&quot;);</span><br><span class="line">this.tracker.setInitialScale(4);</span><br><span class="line">this.tracker.setStepSize(2);</span><br><span class="line">this.tracker.setEdgesDensity(0.1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里启动监听,也就是检查是否有人脸</span><br><span class="line">this.tracker.on(&quot;track&quot;, event &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 将event的方法传递过去</span><br><span class="line">  this.onTracked(event);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果是读取视频，可以用trackerTask.stop trackerTask.run来暂停、开始视频</span><br><span class="line">this.trackerTask &#x3D; tracking.track(this.video, this.tracker);</span><br></pre></td></tr></table></figure>

<p>再看看监听的核心功能有哪些</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> onTracked(event)&#123;</span><br><span class="line">  &#x2F;&#x2F; 画框框</span><br><span class="line">  this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);</span><br><span class="line">  event.data.forEach(rect &#x3D;&gt; &#123;</span><br><span class="line">    this.context.lineWidth &#x3D; 1;</span><br><span class="line">    this.context.strokeStyle &#x3D; &quot;#a64ceb&quot;;</span><br><span class="line">    this.context.strokeRect(rect.x, rect.y, rect.width, rect.height);</span><br><span class="line">    this.context.font &#x3D; &quot;11px Helvetica&quot;;</span><br><span class="line">    this.context.fillStyle &#x3D; &quot;#fff&quot;;</span><br><span class="line">    &#x2F;&#x2F; 如果有数据,说明有人脸了</span><br><span class="line">    if (event.data.length &gt; 0) &#123;</span><br><span class="line">      console.log(&#39;监测到人脸&#39;)</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>摄像头的调用已经实现了,接下来对人脸进行截图,识别,就和之前注册人脸库一样的逻辑了,这里就不多讲了,直接贴完整代码吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;user-icon&quot;&gt;</span><br><span class="line">      &lt;video width&#x3D;&quot;320&quot; height&#x3D;&quot;240&quot; ref&#x3D;&quot;videoDom&quot; id&#x3D;&quot;video&quot; preload autoplay loop muted&gt;&lt;&#x2F;video&gt;</span><br><span class="line">      &lt;canvas width&#x3D;&quot;320&quot; height&#x3D;&quot;240&quot; ref&#x3D;&quot;canvasDOM&quot;&gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;div&gt;&#123;&#123;loding&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;button&quot; @click&#x3D;&quot;initTracker&quot;&gt;假设我是个按钮,点击之后我要人脸识别了&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  require(&#39;tracking&#x2F;build&#x2F;tracking-min.js&#39;)</span><br><span class="line">  require(&#39;tracking&#x2F;build&#x2F;data&#x2F;face-min.js&#39;)</span><br><span class="line">  &#x2F;&#x2F; 嘴巴等特征,后期可添加</span><br><span class="line">  &#x2F;&#x2F; require(&#39;tracking&#x2F;build&#x2F;data&#x2F;mouth-min.js&#39;)</span><br><span class="line">  &#x2F;&#x2F; require(&#39;tracking&#x2F;build&#x2F;data&#x2F;eye-min.js&#39;)</span><br><span class="line">  &#x2F;&#x2F;var objects &#x3D; new tracking.ObjectTracker([&#39;face&#39;, &#39;eye&#39;, &#39;mouth&#39;]);</span><br><span class="line">  &#x2F;&#x2F; require(&#39;tracking&#x2F;examples&#x2F;assets&#x2F;stats.min.js&#39;)</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;testTracking&#39;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录拍照到了几次</span><br><span class="line">        count: 0,</span><br><span class="line">        isdetected: &#39;请您保持脸部在画面中央&#39;,</span><br><span class="line">        loding: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      &#x2F;&#x2F; 初始化racker</span><br><span class="line">      initTracker()&#123;</span><br><span class="line">        &#x2F;&#x2F; alert(&#39;进来了&#39;)</span><br><span class="line">        &#x2F;&#x2F; alert(navigator.mediaDevices)</span><br><span class="line">         &#x2F;&#x2F; 启用摄像头,这一个是原生调用摄像头的功能,不写的话有时候谷歌浏览器调用摄像头会失败</span><br><span class="line">        navigator.mediaDevices</span><br><span class="line">          .getUserMedia(&#123;video: true,audio: true&#125;)</span><br><span class="line">          .then(this.getMediaStreamSuccess)</span><br><span class="line">          .catch(this.getMediaStreamError)</span><br><span class="line">        </span><br><span class="line">        this.context  &#x3D; this.canvas.getContext(&#39;2d&#39;)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 初始化tracking参数</span><br><span class="line">        this.tracker &#x3D; new tracking.ObjectTracker(&quot;face&quot;);</span><br><span class="line">        this.tracker.setInitialScale(4);</span><br><span class="line">        this.tracker.setStepSize(2);</span><br><span class="line">        this.tracker.setEdgesDensity(0.1);</span><br><span class="line">        this.tracker.on(&quot;track&quot;, event &#x3D;&gt; &#123;</span><br><span class="line">          this.onTracked(event);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; tracking启用摄像头,这里我选择调用原生的摄像头</span><br><span class="line">        &#x2F;&#x2F; tracking.track(this.video, this.tracker, &#123; camera: true &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果是读取视频，可以用trackerTask.stop trackerTask.run来暂停、开始视频</span><br><span class="line">        this.trackerTask &#x3D; tracking.track(this.video, this.tracker);</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 监听中</span><br><span class="line">      onTracked(event)&#123;</span><br><span class="line">        &#x2F;&#x2F; 判断终止条件, stop是异步的，不返回的话，还会一直截图</span><br><span class="line">        if (this.count &gt;&#x3D; 21) &#123;</span><br><span class="line">          this.onStopTracking();</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 画框框</span><br><span class="line">        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);</span><br><span class="line">        event.data.forEach(rect &#x3D;&gt; &#123;</span><br><span class="line">          this.context.lineWidth &#x3D; 1;</span><br><span class="line">          this.context.strokeStyle &#x3D; &quot;#a64ceb&quot;;</span><br><span class="line">          &#x2F;&#x2F;&#39;#a64ceb&#39;;</span><br><span class="line">          this.context.strokeRect(rect.x, rect.y, rect.width, rect.height);</span><br><span class="line">          this.context.font &#x3D; &quot;11px Helvetica&quot;;</span><br><span class="line">          this.context.fillStyle &#x3D; &quot;#fff&quot;;</span><br><span class="line">          &#x2F;&#x2F; 截图</span><br><span class="line">          </span><br><span class="line">          if (event.data.length &gt; 0 &amp;&amp; this.count &lt;&#x3D; 20) &#123;</span><br><span class="line">            if (this.count &lt; 0) &#123;</span><br><span class="line">              this.count &#x3D; 0</span><br><span class="line">            &#125;</span><br><span class="line">            this.count +&#x3D; 1</span><br><span class="line">            if (this.count &gt; 20) &#123;</span><br><span class="line">              this.isdetected &#x3D; &#39;已检测到人脸，正在识别&#39;</span><br><span class="line">              this.getPhoto()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.count -&#x3D; 1</span><br><span class="line">            if (this.count &lt; 0)&#123;</span><br><span class="line">              this.isdetected &#x3D; &#39;请您保持脸部在画面中央&#39;</span><br><span class="line">            &#125; </span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; 视频中心展示文字</span><br><span class="line">        this.context.fillText(this.isdetected, 100,30);</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 停止监听</span><br><span class="line">      onStopTracking() &#123;</span><br><span class="line">        this.trackerTask.stop();</span><br><span class="line">        this.video.pause();</span><br><span class="line">        &#x2F;&#x2F; 关闭摄像头</span><br><span class="line">        this.video.srcObject &#x3D; null</span><br><span class="line">        window.stream.getTracks().forEach(track &#x3D;&gt; track.stop())</span><br><span class="line">        </span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 获取人脸照片</span><br><span class="line">      getPhoto()&#123;</span><br><span class="line">        this.isdetected &#x3D; &#39;&#39;</span><br><span class="line">        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);</span><br><span class="line">        let video &#x3D; document.getElementById(&#39;video&#39;)</span><br><span class="line">        this.context.drawImage(video, 0,0, this.canvas.width, this.canvas.height)</span><br><span class="line">        let dataUrl &#x3D; this.canvas.toDataURL(&#39;image&#x2F;jpeg&#39;, 1);</span><br><span class="line">        this.imgbase64 &#x3D; dataUrl.replace(&#x2F;^data:image\&#x2F;\w+;base64,&#x2F;, &quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F; 开始人脸识别</span><br><span class="line">        this.postFace()</span><br><span class="line">        </span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 初始化调用Token</span><br><span class="line">      getToken()&#123;</span><br><span class="line">        this.$axios.post(&#39;http:&#x2F;&#x2F;192.168.50.35:3000&#x2F;getToken&#39;,&#123;&#125;).then((res)&#x3D;&gt;&#123;</span><br><span class="line">          this.access_token &#x3D; res.data.access_token</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 人脸验证</span><br><span class="line">      postFace()&#123;</span><br><span class="line">        this.loding &#x3D; &#39;正在识别中,请稍后................&#39;</span><br><span class="line">        this.$axios.post(&#39;http:&#x2F;&#x2F;192.168.50.35:3000&#x2F;checkFace&#39;,&#123;</span><br><span class="line">          access_token: this.access_token,</span><br><span class="line">          img: this.imgbase64</span><br><span class="line">        &#125;).then((res)&#x3D;&gt;&#123;</span><br><span class="line">          console.log(res)</span><br><span class="line">           this.loding &#x3D; &#39;&#39;</span><br><span class="line">          if(res.data.error_code !&#x3D;&#x3D; 0)&#123;</span><br><span class="line">            if(res.data.error_code &#x3D;&#x3D; 223120)&#123;</span><br><span class="line">              alert(&#39;活体监测失败&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;else &#123;</span><br><span class="line">            if(res.data.result.user_list[0].score &gt; 80)&#123;</span><br><span class="line">              alert(&#39;人脸识别成功&#39;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">              alert(&#39;人脸识别失败,查不到&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,     </span><br><span class="line">      &#x2F;&#x2F; 视频流启动</span><br><span class="line">      getMediaStreamSuccess(stream) &#123;</span><br><span class="line">        window.stream &#x3D; stream</span><br><span class="line">        this.video.srcObject &#x3D; stream</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 视频媒体流失败</span><br><span class="line">      getMediaStreamError(error) &#123;</span><br><span class="line">        alert(&#39;视频媒体流获取错误&#39; + error)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      this.video &#x3D; this.$refs.videoDom</span><br><span class="line">      this.canvas &#x3D; this.$refs.canvasDOM</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;初始化获取tonken</span><br><span class="line">      this.getToken();</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed() &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .user-icon &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    width: 360px;</span><br><span class="line">    height: 360px;</span><br><span class="line">  &#125;</span><br><span class="line">  .button &#123;</span><br><span class="line">    width: 90vw;</span><br><span class="line">    height: 50px;</span><br><span class="line">    line-height: 50px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    color: white;</span><br><span class="line">    text-align: center;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">  &#125;</span><br><span class="line">  video, canvas &#123; </span><br><span class="line">    position: absolute;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>完整的代码中包含了,人脸识别认证后自动截图,自动关闭摄像头等功能</p>
<p>示意图,如果有人脸,是会有紫色的框框,这里因为没有人脸,所以没有</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/116-3-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt=""></p>
<div class="note warning">
            <p>需要注意的是,在移动端,由于安全策略的原因,摄像头不能开启成功,录音等audio自动播放因为安全策略也都是不可以的.</p>
          </div>

<p>以上就是我对vue中实现人脸识别的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>人脸识别</category>
      </categories>
      <tags>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序中实现人脸识别和指纹识别</title>
    <url>/2020/01/20/117-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>写完普通的人脸识别,现在看看微信小程序中的人脸识别是怎么实现的</p>
</blockquote>
<a id="more"></a>

<p>首先创建一个微信小程序,这之前需要创建账户七七八八的,在这里就不再重复的叙述了,直接进入主题</p>
<p>微信的默认模板,一开始的时候,就默认的登录了我们的微信账号了,所以不管是刷脸还是指纹识别,用的都是我们之前在微信存好的信息</p>
<div class="note info">
            <p>微信的识别认证比较简单,只要调用方法就可以了,其中人脸识别需要手机设备的支持才可以,设备不支持的话,是不可以调用人脸识别的</p>
          </div>

<p>贴出完整的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openWxFace() &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 微信该设备支持的可被SOTER识别的生物识别方式</span><br><span class="line">  wx.checkIsSupportSoterAuthentication(&#123;</span><br><span class="line">    complete(res) &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 微信开始 SOTER 生物认证,目前仅支持指纹识别和人脸识别,facial支持,fingerPrint支持</span><br><span class="line">  wx.startSoterAuthentication(&#123;</span><br><span class="line">    requestAuthModes: [&#39;facial&#39;],</span><br><span class="line">    challenge: &#39;123456&#39;,</span><br><span class="line">    authContent: &#39;请用人脸识别&#39;,</span><br><span class="line">    complete(res) &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上就是我对微信小程序中实现人脸识别和指纹识别的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>人脸识别</category>
      </categories>
      <tags>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题升级</title>
    <url>/2020/01/24/118-Next%E4%B8%BB%E9%A2%98%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>突然发现,hexo和next升级了好几个版本,新增了一些小功能,记录一下升级的过程</p>
</blockquote>
<a id="more"></a>

<p>hexo升级比较简单,<code>npm i hexo-cli -g</code>,重新升级一下就好,主要来看看Next修改了哪些功能</p>
<h3 id="下载新版Next"><a href="#下载新版Next" class="headerlink" title="下载新版Next"></a>下载新版Next</h3><p><code>Git clone https://github.com/theme-next/hexo-theme-next themes/next</code> 下载到/themes的文件夹目录下,假设名字为next-v7.4.2</p>
<h3 id="修改根目录的-config-yml"><a href="#修改根目录的-config-yml" class="headerlink" title="修改根目录的_config.yml"></a>修改根目录的_config.yml</h3><ol>
<li>language改为: language: zh-CN</li>
<li>theme改为: theme: next-v7.4.2 # 这里的名字对应目录下的名字</li>
</ol>
<h3 id="配置Next主题文件夹的-config-yml"><a href="#配置Next主题文件夹的-config-yml" class="headerlink" title="配置Next主题文件夹的_config.yml"></a>配置Next主题文件夹的_config.yml</h3><p>关于这个配置,我也是看别人的博客一点一点改的,可是版本就算一样,也有可能不信,所以最好大家改的时候多试几个版本</p>
<h4 id="主题修改"><a href="#主题修改" class="headerlink" title="主题修改"></a>主题修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h3 id="设置菜单及对应页面"><a href="#设置菜单及对应页面" class="headerlink" title="设置菜单及对应页面"></a>设置菜单及对应页面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">  #comments: &#x2F;comments&#x2F; || comments</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure>

<p>新增的菜单需要修改中文的,在/languages的zh-CN.yml中自行修改</p>
<h3 id="配置底部显示"><a href="#配置底部显示" class="headerlink" title="配置底部显示"></a>配置底部显示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # 配置年份</span><br><span class="line">  since: 2016</span><br><span class="line"></span><br><span class="line">  # 配置图标</span><br><span class="line">  icon:</span><br><span class="line">    # 样式</span><br><span class="line">    name: heart</span><br><span class="line">    # 动画</span><br><span class="line">    animated: true</span><br><span class="line">    # 颜色</span><br><span class="line">    color: &quot;#ff0000&quot;</span><br><span class="line"></span><br><span class="line">  # 作者</span><br><span class="line">  copyright: 陈晟</span><br><span class="line"></span><br><span class="line">  powered:</span><br><span class="line">    # 显示驱动</span><br><span class="line">    enable: true</span><br><span class="line">    # 不显示版本</span><br><span class="line">    version: false</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # 显示主题</span><br><span class="line">    enable: true</span><br><span class="line">    # 不显示版本</span><br><span class="line">    version: false</span><br></pre></td></tr></table></figure>

<p>然后在/languages的zh-CN.yml中修改 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  powered: &quot;欢迎访问&quot;</span><br><span class="line">  theme: Mr.Chen的小前端</span><br></pre></td></tr></table></figure>

<h3 id="开启文章版权信息"><a href="#开启文章版权信息" class="headerlink" title="开启文章版权信息"></a>开启文章版权信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: true</span><br><span class="line">  post: true</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>

<h3 id="Tag-标签前图标修改"><a href="#Tag-标签前图标修改" class="headerlink" title="Tag 标签前图标修改"></a>Tag 标签前图标修改</h3><p>tag_icon: true</p>
<h3 id="站点访问量统计"><a href="#站点访问量统计" class="headerlink" title="站点访问量统计"></a>站点访问量统计</h3><p>新版的Next已经自动集成了不蒜子统计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true #设true 开启</span><br><span class="line">  total_visitors: true  #总阅读人数 uv数</span><br><span class="line">  total_visitors_icon: user  #阅读总人数的图标</span><br><span class="line">  total_views: true #总阅读次数 pv数</span><br><span class="line">  total_views_icon: eye #阅读总次数的图标</span><br><span class="line">  post_views: false #开启内容阅读次数</span><br><span class="line">  post_views_icon: eye #内容页阅读数的图标</span><br></pre></td></tr></table></figure>

<blockquote>
<p>高阶用法：通过修改代码来自定义统计文案</p>
</blockquote>
<p>编辑themes/next-v-7.4.2/layout/_partials/analytics/busuanzi-counter.swig,修改为下面这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.busuanzi_count.enable %&#125;</span><br><span class="line">&lt;div class&#x3D;&quot;busuanzi-count&quot;&gt;</span><br><span class="line">  &lt;script&#123;&#123; pjax &#125;&#125; async src&#x3D;&quot;https:&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">  &#123;%- if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">      &lt;span class&#x3D;&quot;site-uv&quot;&gt;</span><br><span class="line">        &#123;&#123; __(&#39;footer.total_visitors&#39;, &#39;&lt;span class&#x3D;&quot;busuanzi-value&quot; id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;&#39;) &#125;&#125;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- if theme.busuanzi_count.total_views %&#125;</span><br><span class="line">    &lt;span class&#x3D;&quot;site-pv&quot;&gt;</span><br><span class="line">     &#123;&#123; __(&#39;footer.total_views&#39;, &#39;&lt;span class&#x3D;&quot;busuanzi-value&quot; id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;&#39;) &#125;&#125;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<p>编辑：themes\next-v-7.4.2\languages\zh-CN.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  total_views: &quot;历经 %s 次回眸才与你相遇&quot;</span><br><span class="line">  total_visitors: &quot;我的第 %s 位朋友，&quot;</span><br></pre></td></tr></table></figure>

<p>在自定义样式文件中添加如下样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;修改不蒜子数据颜色</span><br><span class="line">.busuanzi-value &#123;</span><br><span class="line">  color: #1890ff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>新版本的Next主题说是在<code>custom_file_path</code>字段配置一下,然后再对应的文件夹下新增目录_data,写文件样式就可以了,但是我试过之后不行,所以我在<code>/source/css/_custom</code>下新增<code>_custom/.styl</code>,在外层的main.styl中引入<code>@import &quot;_custom/custom&quot;;</code></p>
          </div>

<h3 id="站点及文章字数统计"><a href="#站点及文章字数统计" class="headerlink" title="站点及文章字数统计"></a>站点及文章字数统计</h3><p>新版本也自动集成了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: false</span><br><span class="line">  item_text_post: false</span><br><span class="line">  item_text_total: true</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>

<h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure>

<h3 id="添加打赏功能"><a href="#添加打赏功能" class="headerlink" title="添加打赏功能"></a>添加打赏功能</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, reward would be displayed in every article by default.</span><br><span class="line">  # You can show or hide reward in a specific article throuth &#96;reward: true | false&#96; in Front-matter.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  comment: 没办法,总要恰饭的嘛~~</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wxpay.png</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.png</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure>

<h3 id="添加图片灯箱"><a href="#添加图片灯箱" class="headerlink" title="添加图片灯箱"></a>添加图片灯箱</h3><blockquote>
<p>添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 fancyBox 提供</p>
</blockquote>
<p>在根目录下执行以下命令安装相关依赖：</p>
<p><code>git clone https://github.com/theme-next/theme-next-fancybox3 themes/next/source/lib/fancybox</code></p>
<p>在主题配置文件中设置 <code>fancybox: true</code></p>
<h3 id="新增gittalk评论"><a href="#新增gittalk评论" class="headerlink" title="新增gittalk评论"></a>新增gittalk评论</h3><p>之前评论用畅言的,但是会给我塞广告,所以打算换成gittalk</p>
<p>新增Next也集成了!! 这就是为什么我要升级到新版本的原因</p>
<p>首先建立评论仓库</p>
<p>很简单建立一个名blogIssues的评论仓库</p>
<p>在git中github沿路径setting/Developer setting/OAuth Apps，新建自己的OAuth Apps</p>
<p>url都填写自己的域名,建立完成后可以看到client_id和client_secret,就可以记录下来</p>
<p>然后再主题文件中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: 328921371 # GitHub repo owner</span><br><span class="line">  repo: blogIssues # Repository name to store issues</span><br><span class="line">  client_id: 你的client_id # GitHub Application Client ID</span><br><span class="line">  client_secret: 你的client_secret # GitHub Application Client Secret</span><br><span class="line">  admin_user: 328921371 # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class="line">  distraction_free_mode: false # Facebook-like distraction free mode</span><br><span class="line">  redirect_uri: https:&#x2F;&#x2F;www.chensheng.group</span><br><span class="line">  id: location.pathname</span><br><span class="line">  # Gitalk&#39;s display language depends on user&#39;s browser or system environment</span><br><span class="line">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class="line">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class="line">  language: zh-CN</span><br></pre></td></tr></table></figure>

<p>初始化的时候我也遇到过问题,点击按钮的时候一直返回首页,应该是标题太长的问题,后来又可以了,我也不知道原因</p>
<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>博客中,边缘波动,打字礼花等有趣的,等着你们自己挖掘吧,自己建博客,享受的就是这个过程</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>博客写作技巧篇</title>
    <url>/2020/01/27/119-%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7%E7%AF%87/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>更新了next和hexo后,发现next有一些标签可以直接在Markdown文档上使用</p>
</blockquote>
<a id="more"></a>

<p>Markdown的基本语法我就不在说了,说一下next的标签使用,原文参考<a href="http://yearito.cn/posts/hexo-writing-skills.html#开始写作" target="_blank" rel="noopener">大佬的博客</a>,谢谢大佬的无私奉献</p>
<h3 id="文本居中标签"><a href="#文本居中标签" class="headerlink" title="文本居中标签"></a>文本居中标签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用&#123;% centerquote %&#125;或者&#123;% cq %&#125;标签包裹内容，实现内容居中的效果。</span><br><span class="line"></span><br><span class="line">注意内容后要用&#123;% endcenterquote %&#125;或&#123;% endcq %&#125;结尾。</span><br><span class="line"></span><br><span class="line">例如下方展示: &#123;% cq %&#125; 谢谢你 &#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center"><p>谢谢你 </p>
</blockquote>

<h3 id="代码块进阶用法"><a href="#代码块进阶用法" class="headerlink" title="代码块进阶用法"></a>代码块进阶用法</h3><figure class="highlight plain"><figcaption><span>写作技巧</span><a href="https://www.chensheng.group/2020/01/20/118-博客写作技巧篇/">链接地址</a></figcaption><table><tr><td class="code"><pre><span class="line">点击右上方的链接地址就可以打开这篇博客</span><br></pre></td></tr></table></figure>

<p>代码块进阶语法规则：</p>
<div class="note ">
            <p>``` language title url link text<br>code snippet<br>```</p>
          </div>

<p>其中，各参数意义如下：</p>
<ul>
<li>langugae：语言名称，引导渲染引擎正确解析并高亮显示关键字</li>
<li>title：代码块标题，将会显示在左上角</li>
<li>url：链接地址，如果没有指定 link text 则会在右上角显示 link</li>
<li>link text：链接名称，指定 url 后有效，将会显示在右上角</li>
<li>url 必须为有效链接地址才会以链接的形式显示在右上角，否则将作为标题显示在左上角。以 url 为分界，左侧除了第一个单词会被解析为 language，其他所有单词都会被解析为 title，而右侧的所有单词都会被解析为 link text。</li>
</ul>
<p>如果不想填写 title，可以在 language 和 url 之间添加至少三个空格。</p>
<h3 id="note-标签"><a href="#note-标签" class="headerlink" title="note 标签"></a>note 标签</h3><p>通过 note 标签可以为段落添加背景色，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note class  %&#125;</span><br><span class="line">文本内容 (支持行内标签)</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>支持的 class 种类包括 default primary success info warning danger，也可以不指定 class。</p>
<p>各种 class 种类的效果如下：</p>
<div class="note primary">
            <p>primary</p>
          </div>

<div class="note success">
            <p>success</p>
          </div>

<div class="note info">
            <p>info</p>
          </div>

<div class="note warning">
            <p>warning</p>
          </div>

<div class="note danger">
            <p>danger</p>
          </div>

<div class="note ">
            <p>不写class,默认是这个颜色</p>
          </div>

<p>更多配置可在主题配置文件中设置</p>
<figure class="highlight plain"><figcaption><span>config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note 标签样式预设</span><br><span class="line">  style: modern  # simple | modern | flat | disabled</span><br><span class="line">  icons: false  # 是否显示图标</span><br><span class="line">  border_radius: 3  # 圆角半径</span><br><span class="line">  light_bg_offset: 0  # 默认背景减淡效果，以百分比计算</span><br></pre></td></tr></table></figure>

<h3 id="label-标签"><a href="#label-标签" class="headerlink" title="label 标签"></a>label 标签</h3><p>通过 label 标签可以为文字添加背景色，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 语法格式</span><br><span class="line">&#123;% label class@text  %&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 具体范例</span><br><span class="line">&#123;% label @default  %&#125;</span><br><span class="line">&#123;% label primary@primary  %&#125;</span><br><span class="line">&#123;% label success@success  %&#125;</span><br><span class="line">&#123;% label info@info  %&#125;</span><br><span class="line">&#123;% label warning@warning  %&#125;</span><br><span class="line">&#123;% label danger@danger  %&#125;</span><br></pre></td></tr></table></figure>

<p>支持的 class 种类包括 default primary success info warning danger，默认使用 default 作为缺省。</p>
<p>具体效果如下：</p>
<blockquote class="blockquote-center"><p><span class="label default">default</span><br><span class="label primary">primary</span><br><span class="label success">success</span><br><span class="label info">info</span><br><span class="label warning">warning</span><br><span class="label danger">danger</span></p>
</blockquote>

<h3 id="button-按钮"><a href="#button-按钮" class="headerlink" title="button 按钮"></a>button 按钮</h3><p>通过 button 标签可以快速添加带有主题样式的按钮，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 语法格式</span><br><span class="line">&#123;% button &#x2F;path&#x2F;to&#x2F;url&#x2F;, text, icon [class], title %&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 具体范例</span><br><span class="line">&#123;% btn #, 文本 %&#125;</span><br><span class="line">&#123;% btn #, 文本 &amp; 标题,, 标题 %&#125;</span><br><span class="line">&#123;% btn #, 文本 &amp; 图标, home %&#125;</span><br><span class="line">&#123;% btn #, 文本 &amp; 大图标 (固定宽度), home fa-fw fa-lg %&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<a class="btn" href="#">文本</a>
<a class="btn" href="#" title="标题">文本 & 标题</a>
<a class="btn" href="#"><i class="fa fa-home"></i>文本 & 图标</a>
<a class="btn" href="#"><i class="fa fa-home fa-fw fa-lg"></i>文本 & 大图标 (固定宽度)</a>

<h3 id="tab-标签"><a href="#tab-标签" class="headerlink" title="tab 标签"></a>tab 标签</h3><p>tab 标签用于快速创建 tab 选项卡，语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 语法格式</span><br><span class="line">&#123;% tabs [Unique name], [index] %&#125;</span><br><span class="line">  &lt;!-- tab [Tab caption]@[icon] --&gt;</span><br><span class="line">  标签页内容（支持行内标签）</span><br><span class="line">  &lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 具体范例</span><br><span class="line">&#123;% tabs Tab标签列表 %&#125;</span><br><span class="line">  &lt;!-- tab 第一页 --&gt;</span><br><span class="line">    标签页1文本内容</span><br><span class="line">  &lt;!-- endtab --&gt;</span><br><span class="line">  &lt;!-- tab 第二页 --&gt;</span><br><span class="line">    标签页2文本内容</span><br><span class="line">  &lt;!-- endtab --&gt;</span><br><span class="line">  &lt;!-- tab 第三页 --&gt;</span><br><span class="line">    标签页3文本内容</span><br><span class="line">  &lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<p>其中，各参数意义如下：</p>
<ul>
<li>Unique name: 全局唯一的 Tab 名称，将作为各个标签页的 id 属性前缀</li>
<li>index: 当前激活的标签页索引，如果未定义则默认选中显示第一个标签页，如果设为 - 1 则默认隐藏所有标签页</li>
<li>Tab caption: 当前标签页的标题，如果不指定则会以 Unique name 加上索引作为标题</li>
<li>icon: 在标签页标题中添加 Font awesome 图标</li>
</ul>
<p>具体效果如下:</p>
<div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><a href="#-1">第一页</a></li><li class="tab"><a href="#-2">第二页</a></li><li class="tab"><a href="#-3">第三页</a></li></ul><div class="tab-content"><div class="tab-pane active" id="-1"><p>  标签页1文本内容</p></div><div class="tab-pane" id="-2"><p>  标签页2文本内容</p></div><div class="tab-pane" id="-3"><p>  标签页3文本内容</p></div></div></div>

]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 的使用</title>
    <url>/2016/12/20/12-git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>许多刚刚进入公司的小白当拿到了公司分发的GitHub账号都会一脸懵B，这是这个啥，怎么用，今天就和大家简单的介绍一下</p>
</blockquote>
<a id="more"></a>

<p>关于GitHub的教程，推荐廖雪峰老师的官网，写的实在是太好了，尤其适合初学者 附上链接 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">GitHub教程</a></p>
<p>我这里就不在做更多详细的介绍了，只是将git用到的命令总结下来，好记性不如烂笔头嘛</p>
<ol>
<li><p>git init</p>
</li>
<li><p>git config user.name”cs”</p>
</li>
<li><p>git config user.email”<a href="mailto:328921371@qq.com">328921371@qq.com</a>“</p>
</li>
<li><p>git add readme.txt (添加 文件名)</p>
</li>
<li><p>git commit -m “add distributed 20161220” (提交文件名)</p>
</li>
<li><p>git status （查看仓库状态）</p>
</li>
<li><p>git diff readme.txt （查看文件修改了哪些内容）</p>
</li>
<li><p>git log(查看最近到最远的提交日志，我们可以看到3次提交)</p>
</li>
<li><p>git log –pretty=oneline（输出版本号）</p>
</li>
<li><p>git reset –hard HEAD^（回到上个版本，^几个就是几个版本  还可以用 hard~100）</p>
</li>
<li><p>cat readme.txt（查看文件）</p>
</li>
<li><p>git reset –hard 3628164（回到最近的一次）</p>
</li>
<li><p>git reflog （查看每次操作的命令记录）</p>
</li>
<li><p>git checkout – readme.txt(撤销工作区的修改)</p>
</li>
<li><p>git reset HEAD readme.txt（撤销暂存区的修改，之后还要再撤销一下工作区的）</p>
</li>
<li><p>rm test.txt（删除文件，工作区的，git checkout – test.txt 删错了可以回退）</p>
</li>
<li><p>git rm test.txt（删除文件，版本库中的 ，需要commit一下）</p>
</li>
<li><p>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:328921371/cs.git（建立连接）</p>
</li>
<li><p>git push -u origin master（将内容推送到远程仓库里，第一次要加-u）</p>
</li>
<li><p>git push origin master(推送)</p>
</li>
<li><p>git clone <a href="mailto:git@github.com">git@github.com</a>:328921371/kelong.git（克隆，可以先创建一个文件夹，npm init一下，然后克隆下来）（ git clone <a href="https://github.com/lyc379980269/zhiyouAskAndAnswer.git）（克隆别人的）（克隆别人的，要先关联一下，" target="_blank" rel="noopener">https://github.com/lyc379980269/zhiyouAskAndAnswer.git）（克隆别人的）（克隆别人的，要先关联一下，</a> git remote add origin <a href="https://github.com/lyc379980269/zhiyouAskAndAnswer.git）" target="_blank" rel="noopener">https://github.com/lyc379980269/zhiyouAskAndAnswer.git）</a></p>
</li>
<li><p>git checkout -b dev（创建dev分支，然后切换到dev分支（相当于$ git branch dev  创建分支;$ git checkout dev 切换分支）</p>
</li>
<li><p>git branch（查看当前分支）</p>
</li>
<li><p>git checkout master  （切换到主分支master后，看不到之前在分支上的操作）</p>
</li>
<li><p>在master下，将分支的内容合并，git merge dev</p>
</li>
<li><p>合并完可以在主分支上看到，可以删除分支了 git branch -d dev</p>
</li>
<li><p>如果创建分支修改数据后，切换到muster主分支上，如果muster没有进行分支合并，直接进行修改，则会产生冲突，这时将===&lt;&lt;&gt;&gt;删掉，再add和commit一下就行。。git log –graph –pretty=oneline –abbrev-commit（这个可以看到分支的情况）</p>
</li>
</ol>
<p>最后附上两条git的流程和解决错误的方法</p>
<p><a href="http://blog.csdn.net/helloworld183/article/details/72638413" target="_blank" rel="noopener">git的操作方式</a></p>
<p><a href="http://blog.csdn.net/xinguan1267/article/details/39028789" target="_blank" rel="noopener">git遇到错误的解决方案</a></p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>weex环境部署</title>
    <url>/2020/01/30/120-weex%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>在家无聊,打算把跨端的Flutter,RN和weex都看一遍,记录一下weex</p>
</blockquote>
<a id="more"></a>

<p>配置环境是一件很麻烦的事情,我安装了两三个小时,可能是网速或者没有翻墙的问题</p>
<h3 id="node，npm，git"><a href="#node，npm，git" class="headerlink" title="node，npm，git"></a>node，npm，git</h3><p>需要安装的 node，npm，git,这个三个我就不说了,一般的前端都安装好了,没有安装的去我之前的博客搜一下就有</p>
<h3 id="java环境"><a href="#java环境" class="headerlink" title="java环境"></a>java环境</h3><p>安装java环境 下载地址：<a href="http://www.java.com/zh_CN/" target="_blank" rel="noopener">http://www.java.com/zh_CN/</a></p>
<h3 id="weex-toolkit"><a href="#weex-toolkit" class="headerlink" title="weex-toolkit"></a>weex-toolkit</h3><p>安装weex-toolkit  npm install weex-toolkit -g   检查一下weex -v</p>
<p>安装 webpack npm install webpack -g 检查一下 webpack -v</p>
<p>安装前先检查一下，如果有的话就不用安装了 </p>
<h3 id="android-studio"><a href="#android-studio" class="headerlink" title="android-studio"></a>android-studio</h3><p>安装 android-studio 记住那个sdk的路径，默认安装在 </p>
<p>C:\Users\CS\AppData\Local\Android\Sdk</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>配置环境变量：打开环境变量路径：控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;环境变量。</p>
<p>新建：ANDROID_HOME 并把我们刚才赋值的sdk路径作为值插入。</p>
<p>添加platform-tools和tools到path下</p>
<p>AndroidStudio配置：在AndroidStudio的欢迎界面，你需要点击右下方的Configure进行老版本的SDK tool配置，</p>
<p>步骤：Configure-&gt;SDKManager-&gt;SDK Tools-&gt;勾选show Package Details -&gt;勾选23.0.2</p>
<p>然后进入安装。</p>
<h3 id="初始化构建weex项目"><a href="#初始化构建weex项目" class="headerlink" title="初始化构建weex项目"></a>初始化构建weex项目</h3><p>初始化构建项目 weex create helloWeex，一路自己选择，和vue-cli差不多</p>
<p>添加Android应用支持： weex platform add android</p>
<h3 id="AVD虚拟机"><a href="#AVD虚拟机" class="headerlink" title="AVD虚拟机"></a>AVD虚拟机</h3><p>AVD虚拟机的安装： 菜单栏上有一个 AVD，鼠标悬停显示，找一找，然后点击Create Virtual Device</p>
<p>选择一个适合的分辨率，推荐480*800的 不会太大，然后选一个安卓版本下载，下载后选择安装完成，安装完成后点击运行就可以了</p>
<p>到这里,weex环境搭建,weex与android-studio创建联系,都已经完成了</p>
]]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex</tag>
      </tags>
  </entry>
  <entry>
    <title>weex打包.apk或.aar</title>
    <url>/2020/01/31/121-weex%E6%89%93%E5%8C%85aar/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>weex打包成apk我就不说了,android-studio的build上面可以构建,现在记录一下打包成.arr需要哪些步骤,也就是我们通常说的sdk</p>
</blockquote>
<a id="more"></a>

<p>首先,在文件夹project-app-build-outputs-apk中删除.apk</p>
<p>因为android-studio在运行的时候默认就生成了一个.apk的安装包</p>
<h3 id="相关文件改造"><a href="#相关文件改造" class="headerlink" title="相关文件改造"></a>相关文件改造</h3><h4 id="build-gradle文件改造"><a href="#build-gradle文件改造" class="headerlink" title="build.gradle文件改造"></a>build.gradle文件改造</h4><p>把构建插件由</p>
<p>apply plugin: ‘com.android.application’</p>
<p>换成</p>
<p>apply plugin:’com.android.library’</p>
<p>如果定义 applicationId ,也要注释掉</p>
<p>将下面一段代码也注释掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;    applicationVariants.all &#123; variant -&gt;</span><br><span class="line">&#x2F;&#x2F;        variant.outputs.each &#123; output -&gt;</span><br><span class="line">&#x2F;&#x2F;            def outputFile &#x3D; output.outputFile</span><br><span class="line">&#x2F;&#x2F;            if (outputFile !&#x3D; null &amp;&amp; outputFile.name.equals(&#39;app-debug.apk&#39;)) &#123;</span><br><span class="line">&#x2F;&#x2F;                def fileName &#x3D; outputFile.name.replace(&quot;app-debug.apk&quot;, &quot;weex-app.apk&quot;)</span><br><span class="line">&#x2F;&#x2F;                output.outputFile &#x3D; new File(outputFile.parent, fileName)</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="AndroidManifest-xml文件改造"><a href="#AndroidManifest-xml文件改造" class="headerlink" title="AndroidManifest.xml文件改造"></a>AndroidManifest.xml文件改造</h4><p>在文件夹project-app-src-main-AndroidManifest.xml</p>
<p>主窗口调用按需要去掉，不去会在桌面多出一个快捷方式，直接调用aar原来主窗口</p>
<p>去掉Application 中icon,label,theme,name属性，防止跟调用应用冲突</p>
<p>主入口也要注释,就是注释下面这段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;intent-filter&gt;</span><br><span class="line">	&lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot;&#x2F;&gt;</span><br><span class="line">	&lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;intent-filter&gt;</span><br></pre></td></tr></table></figure>


<p>该页面上面的android:name=”com.weex.app.SplashActivity”的SplashActivity,就是以后调用这个aar的包名</p>
<p>去掉switch</p>
<p>在project-app-src-main-java-com.weex.app-WXPageActivity.java中,去掉switch,改成if else,改成这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(item.getItemId()&#x3D;&#x3D;R.id.action_refresh)&#123;</span><br><span class="line">    createWeexInstance();</span><br><span class="line">    renderPage();</span><br><span class="line">  &#125;else if(item.getItemId()&#x3D;&#x3D;R.id.action_scan)&#123;</span><br><span class="line">    IntentIntegrator integrator &#x3D; new IntentIntegrator(this);</span><br><span class="line">    integrator.setDesiredBarcodeFormats(IntentIntegrator.QR_CODE_TYPES);</span><br><span class="line">    integrator.setPrompt(&quot;Scan a barcode&quot;);</span><br><span class="line">    &#x2F;&#x2F;integrator.setCameraId(0);  &#x2F;&#x2F; Use a specific camera of the device</span><br><span class="line">    integrator.setBeepEnabled(true);</span><br><span class="line">    integrator.setOrientationLocked(false);</span><br><span class="line">    integrator.setBarcodeImageEnabled(true);</span><br><span class="line">    integrator.setPrompt(getString(R.string.capture_qrcode_prompt));</span><br><span class="line">    integrator.initiateScan();</span><br><span class="line">  &#125;else if(item.getItemId()&#x3D;&#x3D;R.id.home)&#123;</span><br><span class="line">    finish();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="遇到的问题-weex-plugin-does-not-exist"><a href="#遇到的问题-weex-plugin-does-not-exist" class="headerlink" title="遇到的问题 weex_plugin does not exist."></a>遇到的问题 weex_plugin does not exist.</h3><p>将 apply plugin: ‘com.taobao.android.weex.plugin.gradle’ 也注释掉</p>
<p>这样android调用我们weex的插件,需要自己再手动添加依赖</p>
<p>以上就是我对weex打包成.arr的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex</tag>
      </tags>
  </entry>
  <entry>
    <title>实现微信语言识别</title>
    <url>/2020/04/09/122-%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E8%AF%AD%E8%A8%80%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>项目用到了语音识别的功能,在这里做一个记录</p>
</blockquote>
<a id="more"></a>

<p>语音识别可以使用百度或者科大讯飞等第三方的平台,由于项目是放在公众号上面的,所以就直接使用微信的语音识别</p>
<p>使用微信的API,首先就是导入 <code>import wx from &#39;weixin-js-sdk&#39;</code></p>
<p>之后像后台请求接口,获取到<code>wx.config</code>所需要的几个参数</p>
<h3 id="语音识别准备"><a href="#语音识别准备" class="headerlink" title="语音识别准备"></a>语音识别准备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$store.dispatch(&#39;Post&#39;, sendMessage).then((res) &#x3D;&gt; &#123;     </span><br><span class="line">  wx.config(&#123;</span><br><span class="line">    debug: false, &#x2F;&#x2F; 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">    appId: res.entity.appId, &#x2F;&#x2F; 必填，公众号的唯一标识</span><br><span class="line">    timestamp: res.entity.timestamp, &#x2F;&#x2F; 必填，生成签名的时间戳</span><br><span class="line">    nonceStr: res.entity.nonceStr, &#x2F;&#x2F; 必填，生成签名的随机串</span><br><span class="line">    signature: res.entity.signature, &#x2F;&#x2F; 必填，签名</span><br><span class="line">    jsApiList: [</span><br><span class="line">      &#39;startRecord&#39;, &#x2F;&#x2F;开始录音接口</span><br><span class="line">      &#39;stopRecord&#39;, &#x2F;&#x2F; 停止录音接口</span><br><span class="line">      &#39;playVoice&#39;, &#x2F;&#x2F;播放语音接口</span><br><span class="line">      &#39;pauseVoice&#39;, &#x2F;&#x2F;暂停播放接口</span><br><span class="line">      &#39;stopVoice&#39;, &#x2F;&#x2F;停止播放接口</span><br><span class="line">      &#39;uploadVoice&#39;, &#x2F;&#x2F;上传语音接口</span><br><span class="line">      &#39;downloadVoice&#39;, &#x2F;&#x2F;下载语音接口</span><br><span class="line">      &#39;onVoicePlayEnd&#39;, &#x2F;&#x2F; 监听语音播放完毕api</span><br><span class="line">      &#39;translateVoice&#39; &#x2F;&#x2F; 语言识别</span><br><span class="line">    ] &#x2F;&#x2F; 必填，需要使用的JS接口列表</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  wx.error(function(result) &#123;</span><br><span class="line">    alert(&#39;报错&#39;)</span><br><span class="line">    &#x2F;&#x2F; config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span><br><span class="line">    alert(result + &#39;测试报错，上线后就可以修复&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">  wx.ready(function() &#123;</span><br><span class="line">    &#x2F;&#x2F; config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p><code>jsApiList</code> 里面放入我们需要的API字段</p>
          </div>

<blockquote>
<p>准备阶段介绍之后,就可以开始使用了,微信的sdk使用还是很简单的</p>
</blockquote>
<h3 id="开始录音"><a href="#开始录音" class="headerlink" title="开始录音"></a>开始录音</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.startRecord(&#123;</span><br><span class="line">  success: function(res) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  fail: function(res) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  cancel: function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 用户拒绝授权录音</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="停止录音"><a href="#停止录音" class="headerlink" title="停止录音"></a>停止录音</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.stopRecord(&#123;</span><br><span class="line">  success: function(res) &#123;</span><br><span class="line">    &#x2F;&#x2F; 用户停止录音成功</span><br><span class="line">    &#x2F;&#x2F; 成功会返回localId</span><br><span class="line">  &#125;,</span><br><span class="line">  fail: function(error) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="上传音频"><a href="#上传音频" class="headerlink" title="上传音频"></a>上传音频</h3><p>这一步不是必须的,看需求是否需要在服务端保存音频</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.uploadVoice(&#123;</span><br><span class="line">  localId: this.localId, &#x2F;&#x2F; 需要上传的音频的本地ID，由stopRecord接口获得</span><br><span class="line">  isShowProgressTips: 1, &#x2F;&#x2F; 默认为1，显示进度提示</span><br><span class="line">  success: function (res) &#123;</span><br><span class="line">    &#x2F;&#x2F; 返回音频的服务器端ID(res.serverId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.translateVoice(&#123;</span><br><span class="line">  localId: this.localId, &#x2F;&#x2F; 需要识别的音频的本地Id，由录音相关接口获得</span><br><span class="line">  isShowProgressTips: 1, &#x2F;&#x2F; 默认为1，显示进度提示</span><br><span class="line">  success: function (res) &#123;</span><br><span class="line">    &#x2F;&#x2F;alert(res.translateResult); &#x2F;&#x2F; 语音识别的结果</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>到这里,语音识别的核心功能都完成了,现在可以优化一下,实现长按录音,松开识别语音,上滑取消录音</p>
<p>这里先说一下移动端绑定touch事件</p>
<ol>
<li>开始按下 <code>@touchstart=&quot;touchstart($event)&quot;</code></li>
<li>开始移动 <code>@touchmove=&quot;touchmove($event)&quot;</code></li>
<li>松开手指 <code>@touchend=&quot;touchend($event)&quot;</code></li>
</ol>
<h3 id="长按开始录音"><a href="#长按开始录音" class="headerlink" title="长按开始录音"></a>长按开始录音</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touchstart(event)&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  &#x2F;&#x2F; 在这里新增一个开始时间,用来记录</span><br><span class="line">  this.startTime &#x3D; new Date().getTime();</span><br><span class="line">  </span><br><span class="line">  this.timeOutEvent &#x3D; setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">    this.longPress()</span><br><span class="line">  &#125;,500);&#x2F;&#x2F;这里设置定时器，定义长按500毫秒触发长按事件，时间可以自己改，个人感觉500毫秒非常合适</span><br><span class="line">  return false;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;真正长按后应该执行的内容</span><br><span class="line">longPress()&#123;</span><br><span class="line">  &#x2F;&#x2F;执行长按要执行的内容，如弹出菜单</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="松开结束录音"><a href="#松开结束录音" class="headerlink" title="松开结束录音"></a>松开结束录音</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;手释放，如果在500毫秒内就释放，则取消长按事件，此时可以执行onclick应该执行的事件</span><br><span class="line">touchend(event)&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  clearTimeout(this.timeOutEvent);&#x2F;&#x2F;清除定时器</span><br><span class="line">  let endTime &#x3D; new Date().getTime();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 小于500说明录音时间太短</span><br><span class="line">  if((endTime - this.startTime) &lt; 500)&#123;</span><br><span class="line">    &#x2F;&#x2F; 说明录音时间太短</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    &#x2F;&#x2F; 这里可以开始停止录音</span><br><span class="line">    &#x2F;&#x2F; 语言识别可以写在录音停止成功的回调函数里面</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="上滑取消录音"><a href="#上滑取消录音" class="headerlink" title="上滑取消录音"></a>上滑取消录音</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touchmove(event)&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  clearTimeout(this.timeOutEvent);&#x2F;&#x2F;清除定时器</span><br><span class="line">  &#x2F;&#x2F; 这个clearndiv类似一个方块,用户移入进去时,取消录音</span><br><span class="line">  let clearndiv &#x3D; this.$refs.clearndiv</span><br><span class="line">  let offertSet &#x3D; clearndiv.getBoundingClientRect()   </span><br><span class="line">  let pageY &#x3D; event.targetTouches[0].pageY</span><br><span class="line">  let pageX &#x3D; event.targetTouches[0].pageX</span><br><span class="line">  </span><br><span class="line">  if(pageY &gt; offertSet.top &amp;&amp; pageY &lt; offertSet.bottom &amp;&amp; pageX &gt; offertSet.left &amp;&amp; pageX &lt; offertSet.right)&#123;</span><br><span class="line">    &#x2F;&#x2F; 用户手指在方块中,松开手指就取消录音了</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    &#x2F;&#x2F; 用户手指不在方块中</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>以上就是我对微信语言识别的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>SourceTree的使用</title>
    <url>/2020/05/01/123-SourceTree%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>之前介绍了git命令行操作,今天介绍一下git的可视化工具SourceTree的操作</p>
</blockquote>
<a id="more"></a>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>先去官网下载一下<a href="https://www.sourcetreeapp.com" target="_blank" rel="noopener">戳我戳我</a></p>
<p>之后直接开始安装,安装的时候需要一个Bitbucket的账号,安装他的步骤一步步注册就行,这里就不强调了</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>安装成功之后,我们就可以打开clone页面了,可以选择一个地址进行clone,假设这个地址是正确的,就会有提示</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/123-1-SourceTree.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="SourceTree页面"></p>
<p>选择一个文件夹开始clone</p>
<p>成功clone下来后,当前默认实在master主分支上,显示这个页面,并且可以显示这个项目之前的流程节点</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/123-2-SourceTree.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="SourceTree历史记录页面"></p>
<h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><p>项目clone下来后,就可以开始敲代码了,但是,最好不要直接在主分支上修改代码,我们应该新建一个分支去写代码</p>
<p>现在来看看如何在SourceTree页面上新建分支</p>
<p>点击上面的分支按钮,就会弹出这样的界面</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/123-3-SourceTree.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="SourceTree新建分支"></p>
<p>点击创建分支,当分支新建好之后,会自动帮我们切换到我们刚刚新建的分支上,这时候我们就可以开始写代码了</p>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>现在我们开始写代码了,比如我新增一个A.txt文件,随便写一点东西</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/123-4-SourceTree.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="SourceTree新"></p>
<p>这时候我写的内容,还只是在本地的工作区中,我们需要提交并推送到远程的分支上</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/123-5-SourceTree.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="SourceTree新"></p>
<p>先点击上方的提交按钮,告诉SourceTree我们准备提交了,然后将工作区中有修改的文件全部暂存,在下方写好我们这次提交的内容,就可以点击提交了</p>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>现在,我们需要把已经提交好的推送到远程分支上,点击上方的推送按钮</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/123-6-SourceTree.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="SourceTree新"></p>
<p>由于是第一次推送到远程分支上,所以SourceTree并没有给你一个你需要推送的提示,如果是后续的话,当你提交成功后,他就会提示你需要推送了</p>
<h3 id="获取他人上传的代码"><a href="#获取他人上传的代码" class="headerlink" title="获取他人上传的代码"></a>获取他人上传的代码</h3><p>假如我们要看看其他人的代码呢,我们先将上面的步骤重复一遍,模拟一个B</p>
<p>现在B也推送了他自己的分支,叫B_dev,我们首先点击上方获取的按钮</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/123-7-SourceTree.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="SourceTree新"></p>
<p>可以看到,当前我们看到的远程分支中并没有B_dev,现在我们点击一下确定,将所有的远程分支获取下来</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/123-8-SourceTree.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="SourceTree新"></p>
<p>我们看到已经有B_dev分支了,点击右键,检出到本地分支中</p>
<p>这时候你们可以自己切换两个分支,看看文件的变化</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>假设这时候A的代码写完了,需要合并到主分支,应该怎么操作呢</p>
<p>我们先切换到master主分支上,右键cs_dev,选择合并到当前分支就可以了</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/123-9-SourceTree.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="SourceTree新"></p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>假设A和B都已经获取到master上最新的代码了,两个人都有A,B 两个文件了,于是他们同时修改了A文件,一个全是写AAA,一个全是写BBB</p>
<p>当A推送之后当然没有冲突,可是当B提交的时候,需要先拉取A提交的代码,这时候,就发生冲突了</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/123-10-SourceTree.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="SourceTree新"></p>
<p>有冲突我们就解决对吧,右键点击冲突的文件,选择一个进行修改</p>
<p>到这里,SourceTree的使用就差不多了,至于上面的Git工作流,有兴趣可以先研究一下,我下次再一起分享</p>
<p>以上就是我对SourceTree的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实现Excel导入并解析</title>
    <url>/2020/05/02/124-Excel%E5%AF%BC%E5%85%A5/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>之前有说过表格导出到Excel,今天来说一下怎么样导入Excel表格</p>
</blockquote>
<a id="more"></a>

<p>一般来说这种功能都是封装成组件来使用的,我们来看看如何封装</p>
<p>在component中创建一个.vue文件,然后复制其他大佬的代码,做一个搬运工,具体代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input ref&#x3D;&quot;excel-upload-input&quot; class&#x3D;&quot;excel-upload-input&quot; type&#x3D;&quot;file&quot; accept&#x3D;&quot;.xlsx, .xls&quot; @change&#x3D;&quot;handleClick&quot;&gt;</span><br><span class="line">    &lt;button style&#x3D;&quot;margin-left:16px;&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;handleUpload&quot;&gt;上传文件&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import XLSX from &#39;xlsx&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    beforeUpload: Function,</span><br><span class="line">    onSuccess: Function</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      loading: false,</span><br><span class="line">      excelData: &#123;</span><br><span class="line">        header: null,</span><br><span class="line">        results: null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    generateData(&#123; header, results &#125;) &#123;</span><br><span class="line">      this.excelData.header &#x3D; header</span><br><span class="line">      this.excelData.results &#x3D; results</span><br><span class="line">      this.onSuccess &amp;&amp; this.onSuccess(this.excelData)</span><br><span class="line">    &#125;,</span><br><span class="line">    handleUpload() &#123;</span><br><span class="line">      this.$refs[&#39;excel-upload-input&#39;].click()</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick(e) &#123;</span><br><span class="line">      const files &#x3D; e.target.files</span><br><span class="line">      const rawFile &#x3D; files[0] </span><br><span class="line">      if (!rawFile) return</span><br><span class="line">      this.upload(rawFile)</span><br><span class="line">    &#125;,</span><br><span class="line">    upload(rawFile) &#123;</span><br><span class="line">      this.$refs[&#39;excel-upload-input&#39;].value &#x3D; null </span><br><span class="line"></span><br><span class="line">      if (!this.beforeUpload) &#123;</span><br><span class="line">        this.readerData(rawFile)</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      const before &#x3D; this.beforeUpload(rawFile)</span><br><span class="line">      if (before) &#123;</span><br><span class="line">        this.readerData(rawFile)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    readerData(rawFile) &#123;</span><br><span class="line">      this.loading &#x3D; true</span><br><span class="line">      return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        const reader &#x3D; new FileReader()</span><br><span class="line">        reader.onload &#x3D; e &#x3D;&gt; &#123;</span><br><span class="line">          const data &#x3D; e.target.result</span><br><span class="line">          const workbook &#x3D; XLSX.read(data, &#123; type: &#39;array&#39; &#125;)</span><br><span class="line">          const firstSheetName &#x3D; workbook.SheetNames[0]</span><br><span class="line">          const worksheet &#x3D; workbook.Sheets[firstSheetName]</span><br><span class="line">          const header &#x3D; this.getHeaderRow(worksheet)</span><br><span class="line">          const results &#x3D; XLSX.utils.sheet_to_json(worksheet)</span><br><span class="line">          this.generateData(&#123; header, results &#125;)</span><br><span class="line">          this.loading &#x3D; false</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;</span><br><span class="line">        reader.readAsArrayBuffer(rawFile)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getHeaderRow(sheet) &#123;</span><br><span class="line">      const headers &#x3D; []</span><br><span class="line">      const range &#x3D; XLSX.utils.decode_range(sheet[&#39;!ref&#39;])</span><br><span class="line">      let C</span><br><span class="line">      const R &#x3D; range.s.r</span><br><span class="line">      &#x2F;* start in the first row *&#x2F;</span><br><span class="line">      for (C &#x3D; range.s.c; C &lt;&#x3D; range.e.c; ++C) &#123; &#x2F;* walk every column in the range *&#x2F;</span><br><span class="line">        const cell &#x3D; sheet[XLSX.utils.encode_cell(&#123; c: C, r: R &#125;)]</span><br><span class="line">        &#x2F;* find the cell in the first row *&#x2F;</span><br><span class="line">        let hdr &#x3D; &#39;UNKNOWN &#39; + C &#x2F;&#x2F; &lt;-- replace with your desired default</span><br><span class="line">        if (cell &amp;&amp; cell.t) hdr &#x3D; XLSX.utils.format_cell(cell)</span><br><span class="line">        headers.push(hdr)</span><br><span class="line">      &#125;</span><br><span class="line">      return headers</span><br><span class="line">    &#125;,</span><br><span class="line">    isExcel(file) &#123;</span><br><span class="line">      return &#x2F;\.(xlsx|xls|csv)$&#x2F;.test(file.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.excel-upload-input&#123;</span><br><span class="line">  display: none;</span><br><span class="line">  z-index: -9999;</span><br><span class="line">&#125;</span><br><span class="line">.drop&#123;</span><br><span class="line">  border: 2px dashed #bbb;</span><br><span class="line">  width: 600px;</span><br><span class="line">  height: 160px;</span><br><span class="line">  line-height: 160px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  font-size: 24px;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #bbb;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>记得要安装一下 xlsx</p>
</blockquote>
<p>然后就可以使用了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;upload-excel-component :on-success&#x3D;&quot;handleSuccess&quot; :before-upload&#x3D;&quot;beforeUpload&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import UploadExcelComponent from &#39;@&#x2F;components&#x2F;excel.vue&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;UploadExcel&#39;,</span><br><span class="line">  components: &#123; UploadExcelComponent &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      tableData: [],</span><br><span class="line">      tableHeader: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    beforeUpload(file) &#123;</span><br><span class="line">      const isLt1M &#x3D; file.size &#x2F; 1024 &#x2F; 1024 &lt; 1</span><br><span class="line"></span><br><span class="line">      if (isLt1M) &#123;</span><br><span class="line">        return true</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.$message(&#123;</span><br><span class="line">        message: &#39;Please do not upload files larger than 1m in size.&#39;,</span><br><span class="line">        type: &#39;warning&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">      return false</span><br><span class="line">    &#125;,</span><br><span class="line">    handleSuccess(&#123; results, header &#125;) &#123;</span><br><span class="line">      console.log(results)</span><br><span class="line">      console.log(header)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>使用也很简单,handleSuccess函数中,results就是我们需要的数据了</p>
<p>好了,导入Excel就差不多了</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>URL生成二维码</title>
    <url>/2020/05/02/125-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>由于最近时间太忙了,只能趁着五一把之前欠下的博客全部补上,今天说一下前端如何生成二维码</p>
</blockquote>
<a id="more"></a>

<p>之前做支付的时候就有用到的,本来想着因为很简单,就不写博客了,结果最近又遇到了,于是又百度了一下,索性自己写一篇博客,方便以后查找</p>
<p>代码也没啥好解释的,导入一个<code>qrcodejs2</code>就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">		&lt;div class&#x3D;&quot;motail&quot;&gt;</span><br><span class="line">		  &lt;div id&#x3D;&quot;qrcode&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import QRCode from &#39;qrcodejs2&#39;  &#x2F;&#x2F; 引入qrcode</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      &#x2F;&#x2F; 生成二维码</span><br><span class="line">      document.getElementById(&quot;qrcode&quot;).innerHTML &#x3D; &quot;&quot;;</span><br><span class="line">      let url &#x3D; this.$route.query.text</span><br><span class="line">      console.log(url)</span><br><span class="line">      let qrcode &#x3D; new QRCode(&#39;qrcode&#39;, &#123;</span><br><span class="line">        width: 220,  </span><br><span class="line">        height: 220,</span><br><span class="line">        text: url, &#x2F;&#x2F; 二维码地址</span><br><span class="line">        render: &#39;canvas&#39;,</span><br><span class="line">        colorDark : &quot;#000&quot;,</span><br><span class="line">        colorLight : &quot;#fff&quot;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.motail &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  width: 100vw;</span><br><span class="line">  height: 100vh;</span><br><span class="line">  background-color: rgba(0,0,0,0.5);</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">#qrcode &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  background-color: #fff; &#x2F;* 设置白色背景色 *&#x2F;</span><br><span class="line">  padding: 20px; &#x2F;* 利用padding的特性，挤出白边 *&#x2F;</span><br><span class="line">  margin-top: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>生成出来的二维码样式可能不太好看,我们可以利用padding的特性,挤出白边</p>
<p>以上就是我对生成二维码的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>eslink配置记录</title>
    <url>/2020/05/23/126-eslink%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>项目中都有使用到eslink,怎么安装我就不说了,现在vue-cli4.0初始化的时候,都会提示你是否直接安装</p>
</blockquote>
<a id="more"></a>

<p>本篇记录一下自己经常用到的一些eslink的配置,一些vue风格的没有配置,类似规定组件大小写之类的,有兴趣的可以自己加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isPro &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot;;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  root: true,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    parser: &quot;babel-eslint&quot;,</span><br><span class="line">    ecmaVersion:true</span><br><span class="line">  &#125;,</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: true,</span><br><span class="line">    es6: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: [&#39;plugin:vue&#x2F;essential&#39;],</span><br><span class="line">  plugins: [&quot;vue&quot;],</span><br><span class="line">  &#x2F;&#x2F; &quot;off&quot;或者0    关闭规则关闭</span><br><span class="line">  &#x2F;&#x2F; &quot;warn&quot;或者1   在打开的规则作为警告（不影响退出代码）</span><br><span class="line">  &#x2F;&#x2F; &quot;error&quot;或者2  把规则作为一个错误（退出代码触发时为1）</span><br><span class="line">  rules: &#123;</span><br><span class="line">    &#x2F;&#x2F; 代码风格规范</span><br><span class="line">    &quot;quotes&quot;: [2, &quot;single&quot;], &#x2F;&#x2F;字符串使用单引号</span><br><span class="line">    &quot;space-infix-ops&quot;: 2, &#x2F;&#x2F; 操作符周围要有空格</span><br><span class="line">    &quot;spaced-comment&quot;: 2, &#x2F;&#x2F;注释风格要有空格</span><br><span class="line">    &quot;comma-spacing&quot;: 2, &#x2F;&#x2F;逗号后要有空格</span><br><span class="line">    &quot;comma-style&quot;: [2, &quot;last&quot;], &#x2F;&#x2F;逗号风格，换行时在行首还是行尾</span><br><span class="line">    &quot;consistent-this&quot;: [2, &quot;_this&quot;], &#x2F;&#x2F;this别名</span><br><span class="line">    &quot;curly&quot;: [2, &quot;all&quot;], &#x2F;&#x2F;必须使用 if()&#123;&#125; 中的&#123;&#125;</span><br><span class="line">    &quot;brace-style&quot;: [2, &quot;1tbs&quot;], &#x2F;&#x2F; 大括号和关键字在同一行</span><br><span class="line">    &quot;no-unused-vars&quot;: [0, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;], &#x2F;&#x2F;不能有声明后未被使用的变量或参数</span><br><span class="line">    &quot;no-use-before-define&quot;: 0, &#x2F;&#x2F;未定义前不能使用</span><br><span class="line">    &quot;arrow-parens&quot;: 2, &#x2F;&#x2F;箭头函数用小括号括起来</span><br><span class="line">    &quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;], &#x2F;&#x2F;空行最多不能超过2行</span><br><span class="line">    &quot;operator-linebreak&quot;: [2, &quot;after&quot;], &#x2F;&#x2F;换行时运算符在行尾还是行首</span><br><span class="line">    &quot;indent&quot;: [2, 2], &#x2F;&#x2F;缩进风格,缩进两格</span><br><span class="line">    &quot;comma-dangle&quot;: [2, &quot;never&quot;], &#x2F;&#x2F;对象字面量项尾不能有逗号</span><br><span class="line">    &quot;dot-location&quot;: 2, &#x2F;&#x2F;对象访问符的位置，换行的时候在行首还是行尾</span><br><span class="line">    &quot;func-call-spacing&quot;: 2, &#x2F;&#x2F;函数调用不要空格</span><br><span class="line">    &quot;key-spacing&quot;: [2, &#123; &quot;afterColon&quot;: true, &quot;mode&quot;: &quot;strict&quot; &#125;], &#x2F;&#x2F; key的冒号后面要有空格</span><br><span class="line">    &quot;no-dupe-keys&quot;: 2,&#x2F;&#x2F;在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;</span><br><span class="line">    &quot;no-duplicate-case&quot;: 2,&#x2F;&#x2F;switch中的case标签不能重复</span><br><span class="line">    &quot;no-floating-decimal&quot;: 2,&#x2F;&#x2F;禁止省略浮点数中的0 .5 3.</span><br><span class="line">    &quot;no-multi-spaces&quot;: 2,&#x2F;&#x2F;不能用多余的空格</span><br><span class="line">    &quot;no-multi-str&quot;: 2, &#x2F;&#x2F;字符串不能用\换行</span><br><span class="line">    &quot;object-property-newline&quot;: 2, &#x2F;&#x2F;对象属性换行时注意统一代码风格。</span><br><span class="line">    &quot;padded-blocks&quot;: 0,&#x2F;&#x2F;块语句内行首行尾是否要空行</span><br><span class="line">    &quot;vue&#x2F;v-bind-style&quot;: [&quot;error&quot;, &quot;shorthand&quot;],</span><br><span class="line">    &quot;vue&#x2F;v-on-style&quot;: [&quot;error&quot;, &quot;shorthand&quot;],</span><br><span class="line">    &quot;prefer-destructuring&quot;: 0,</span><br><span class="line">    &quot;class-methods-use-this&quot;: 0,</span><br><span class="line">    &quot;no-mixed-operators&quot;: 0,</span><br><span class="line">    &quot;max-len&quot;: 0, &#x2F;&#x2F;字符串最大长度</span><br><span class="line">    &quot;no-unused-expressions&quot;: 2, &#x2F;&#x2F;禁止无用的表达式</span><br><span class="line">    &quot;import&#x2F;no-dynamic-require&quot;: 0,</span><br><span class="line">    &quot;func-names&quot;: 0, &#x2F;&#x2F;函数表达式必须有名字</span><br><span class="line">    &quot;no-underscore-dangle&quot;: 0, &#x2F;&#x2F;标识符不能以_开头或结尾</span><br><span class="line">    &quot;no-restricted-properties&quot;: 0,</span><br><span class="line">    &quot;no-restricted-syntax&quot;: 0,</span><br><span class="line">    &quot;no-prototype-builtins&quot;: 0,</span><br><span class="line">    &quot;no-plusplus&quot;: 0, &#x2F;&#x2F;禁止使用++，--</span><br><span class="line">    &quot;one-var&quot;: 0, &#x2F;&#x2F;连续声明</span><br><span class="line">    &quot;no-tabs&quot;: 0,</span><br><span class="line">    &quot;prefer-const&quot;: 0, &#x2F;&#x2F;首选const</span><br><span class="line">    &quot;global-require&quot;: 0,</span><br><span class="line">    &quot;guard-for-in&quot;: 0, &#x2F;&#x2F;for in循环要用if语句过滤</span><br><span class="line">    &quot;import&#x2F;extensions&quot;:0,</span><br><span class="line">    &quot;no-console&quot;: 0,</span><br><span class="line">    &quot;no-return-assign&quot;: 0, &#x2F;&#x2F;return 语句中不能有赋值表达式</span><br><span class="line">    &quot;no-param-reassign&quot;: 0, &#x2F;&#x2F;禁止给参数重新赋值</span><br><span class="line">    &quot;no-nested-ternary&quot;: 0, &#x2F;&#x2F;禁止使用嵌套的三目运算</span><br><span class="line">    &quot;camelcase&quot;: 0, &#x2F;&#x2F;强制驼峰法命名</span><br><span class="line">    &quot;eqeqeq&quot;: 0,&#x2F;&#x2F;必须使用全等</span><br><span class="line">    &quot;import&#x2F;no-extraneous-dependencies&quot;: 0,</span><br><span class="line">    &quot;no-debugger&quot;: isPro ? &quot;error&quot; : &quot;off&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是我对eslink配置的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>eslink</category>
      </categories>
      <tags>
        <tag>eslink</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码学习-响应式原理</title>
    <url>/2020/05/31/127-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>响应式原理是什么?为什么vue能监听到data里面的变化?为什么一定要把变量写在data里?为什么有时候数组监听不到?一起来学习一下吧</p>
</blockquote>
<a id="more"></a>

<h3 id="响应式核心"><a href="#响应式核心" class="headerlink" title="响应式核心"></a>响应式核心</h3><p>我们都知道vue是MVVM模式,数据驱动视图,那么他的响应式是如何实现的呢?</p>
<p>面试的时候也经常会这么问,一般我们都会回答一下根据<code>Object.defineProperty</code>来实现响应式原理,这也就够了,但是具体是怎么实现的呢</p>
<p>Vue在初始化数据的时候,会默认把data里面的值进行遍历,内部会使用<code>Object.defineProperty</code>重新定义所有属性</p>
<p>而<code>Object.defineProperty</code>的特点,可以使数据的设置(set)或者获取(get)都增加一个拦截的功能</p>
<p>当页面取到对应属性时,会进行<code>依赖收集(收集当前组件的watcher)</code>,当属性发生变化时,就会通知相关的依赖进行更新操作</p>
<p>举个例子,我们在页面上渲染一个数据,我们就会对这个数据进行取值,取值的时候我们就可以把当前的渲染watcher给存起来,当数据变化的时候,就会告诉对应的watcher进行更新,这样就实现了响应式数据原理</p>
<h3 id="Vue实现响应式原理"><a href="#Vue实现响应式原理" class="headerlink" title="Vue实现响应式原理"></a>Vue实现响应式原理</h3><p>那Vue的源码是如何实现上面这些步骤的呢(下面的方法都是vue源码定义的)</p>
<ol>
<li>initData</li>
</ol>
<p>当Vue初始化数据的时候,会调用一个initdata方法,获取当前data传入的数据</p>
<ol start="2">
<li>new Observer</li>
</ol>
<p>创建一个观测类,观测获取到的数据</p>
<ol start="3">
<li>this.walk(value)</li>
</ol>
<p>如果数据是一个对象(非数组),就会调用this.walk这个方法,内部会重新遍历这些数据,用defineReactive重新定义(使用Object.defineProperty)</p>
<ol start="4">
<li>defineReactive(循环对象属性定义响应式变化)</li>
<li>Object.defineProperty(使用Object.defineProperty重新定义数据)</li>
</ol>
<p>由于我们传入的data必定是个对象,所以一定会观测到数据变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  data: &#123;&#125;</span><br><span class="line">  &#x2F;&#x2F; 不能是 data: &#39;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这也是为什么data传入的一定是个对象,不能是字符串;如果对象中嵌套对象,内部会进行递归遍历</p>
<p>但是如果data中的属性是后面添加进行去,Vue就无法对他进行响应式更新,举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    a:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#96;vm.a&#96; 是响应式的</span><br><span class="line"></span><br><span class="line">vm.b &#x3D; 2</span><br><span class="line">&#x2F;&#x2F; &#96;vm.b&#96; 是非响应式的</span><br></pre></td></tr></table></figure>

<p>因为初始化我们initData的时候,没有获取到他的值,但是我们可以这样操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$set(this.someObject,&#39;b&#39;,2)</span><br></pre></td></tr></table></figure>

<p>这也是在对象中如何重新定义一个新的属性来被Vue检查到的方法</p>
<h3 id="大致的源码解析"><a href="#大致的源码解析" class="headerlink" title="大致的源码解析"></a>大致的源码解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function observe (obj) &#123; &#x2F;&#x2F; 我们来用它使对象变成可观察的</span><br><span class="line">  &#x2F;&#x2F; 判断类型</span><br><span class="line">  if (!obj || typeof obj !&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(obj).forEach(key &#x3D;&gt; &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">  function defineReactive (obj, key, value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 递归子属性</span><br><span class="line">    observe(value)</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: true, &#x2F;&#x2F;可枚举（可以遍历）</span><br><span class="line">      configurable: true, &#x2F;&#x2F;可配置（比如可以删除）</span><br><span class="line">      get: function reactiveGetter () &#123;</span><br><span class="line">        const value &#x3D; getter ? getter.call(obj) : val</span><br><span class="line">        if (Dep.target) &#123;</span><br><span class="line">          dep.depend() &#x2F;&#x2F; ** 收集依赖 ** &#x2F;        </span><br><span class="line">          if (childOb) &#123;</span><br><span class="line">            childOb.dep.depend()</span><br><span class="line">            if (Array.isArray(value)) &#123;</span><br><span class="line">              dependArray(value)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return value</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function reactiveSetter (newVal) &#123;</span><br><span class="line">        const value &#x3D; getter ? getter.call(obj) : val</span><br><span class="line">        if (newVal &#x3D;&#x3D;&#x3D; value || (newVal !&#x3D;&#x3D; newVal &amp;&amp; value !&#x3D;&#x3D; value)) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125; </span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; customSetter) &#123;</span><br><span class="line">          customSetter()</span><br><span class="line">        &#125;</span><br><span class="line">        val &#x3D; newVal</span><br><span class="line">        childOb &#x3D; !shallow &amp;&amp; observe(newVal) &#x2F;&#x2F;如果赋值是一个对象，也要递归子属性</span><br><span class="line">        dep.notify() &#x2F;**通知相关依赖进行更新**&#x2F;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="vue如何检测数组变化"><a href="#vue如何检测数组变化" class="headerlink" title="vue如何检测数组变化"></a>vue如何检测数组变化</h3><p>数组更新的方法有七种,pop/push/reverse/shift/sort/splice/unshift,Vue使用函数劫持的方式,重写了数组的方法,进行了原型链的重写,指向了自己定义的数组原型方法</p>
<p>这样当调用数组api的时候,可以通知依赖更新,如果数组中包含着引用类型,会对数组中的引用类型再次进行监控</p>
<ol>
<li>initData</li>
<li>new Observer</li>
<li>protoAugment(将数组的原型方法指向重写的原型)</li>
<li>observeArray(深度观察数组中的每一项,如果是对象的话,会进一步观测)</li>
</ol>
<p>为什么只监听七种方法呢,因为只有这七种方法才可以改变我们的数组,这也是为什么我们直接通过角标修改数组,视图不能及时的响应更新,当这并不是绝对的,举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设有一个数组</span><br><span class="line">let ary &#x3D; [ &#123; a: 1 &#125;, &#39;csing&#39;];</span><br><span class="line"></span><br><span class="line">ary[0].a &#x3D; 2; &#x2F;&#x2F; 可以监听到</span><br><span class="line">ary[1] &#x3D; &#39;chensheng&#39;; &#x2F;&#x2F; 监听不到</span><br></pre></td></tr></table></figure>

<p>因为observeArray方法会深度观察数组中的每一项,所以如果是对象的话,还是会进行defineReactive定义响应式变化</p>
<p>所以如果需要修改数组中的字符串,需要<code>this.$set(vm.items, indexOfItem, newValue)</code></p>
<h3 id="大致的源码解析-1"><a href="#大致的源码解析-1" class="headerlink" title="大致的源码解析"></a>大致的源码解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arrayProto &#x3D; Array.prototype </span><br><span class="line">export const arrayMethods &#x3D; Object.create(arrayProto) </span><br><span class="line">const methodsToPatch &#x3D; [&#39;push&#39;,  &#39;pop&#39;,  &#39;shift&#39;,  &#39;unshift&#39;,  &#39;splice&#39;,  &#39;sort&#39;,  &#39;reverse&#39;] </span><br><span class="line"></span><br><span class="line">methodsToPatch.forEach(function (method) &#123; &#x2F;&#x2F; 重写原型方法</span><br><span class="line">  const original &#x3D; arrayProto[method] &#x2F;&#x2F; 调用原数组的方法</span><br><span class="line">  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line">    const result &#x3D; original.apply(this, args)</span><br><span class="line">    const ob &#x3D; this.__ob__</span><br><span class="line">    let inserted</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      case &#39;push&#39;:</span><br><span class="line">      case &#39;unshift&#39;:</span><br><span class="line">        inserted &#x3D; args</span><br><span class="line">        break</span><br><span class="line">    case &#39;splice&#39;:</span><br><span class="line">      inserted &#x3D; args.slice(2)</span><br><span class="line">      break</span><br><span class="line">    &#125; </span><br><span class="line">     if (inserted) ob.observeArray(inserted)</span><br><span class="line">    &#x2F;&#x2F; notify change</span><br><span class="line">    ob.dep.notify() &#x2F;&#x2F; 当调用数组方法后，手动通知视图更新</span><br><span class="line">    return result</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;)</span><br><span class="line">this.observeArray(value) &#x2F;&#x2F; 进行深度监控</span><br></pre></td></tr></table></figure>

<p>以上就是我对vue响应式原理的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli 打包删除console.log</title>
    <url>/2020/06/05/128-vue%E6%89%93%E5%8C%85%E5%8E%BB%E9%99%A4log/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>项目打包的时候想要删除console.log,但是又不想手动删除,万一编译的时候还要用,这时候就要自己开始配置了</p>
</blockquote>
<a id="more"></a>

<h3 id="vue-cli-2-版本-并且-webpack-3-版本"><a href="#vue-cli-2-版本-并且-webpack-3-版本" class="headerlink" title="vue-cli 2 版本 并且 webpack 3 版本"></a>vue-cli 2 版本 并且 webpack 3 版本</h3><p>打开webpack.prod.conf.js文件</p>
<p>找到 UglifyJsPlugin, 添加<code>drop_console: true</code> 就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new UglifyJsPlugin(&#123;</span><br><span class="line">  uglifyOptions: &#123;</span><br><span class="line">    compress: &#123;</span><br><span class="line">      warnings: false,</span><br><span class="line">      drop_debugger: true,</span><br><span class="line">      drop_console: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  sourceMap: config.build.productionSourceMap,</span><br><span class="line">  parallel: true</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>

<h3 id="vue-cli-3-4-版本"><a href="#vue-cli-3-4-版本" class="headerlink" title="vue-cli 3 || 4 版本"></a>vue-cli 3 || 4 版本</h3><p>由于这个版本的webpack被简化了,所以我们的项目中没有build文件夹,所以可以在vue.config.js的文件中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configureWebpack: (config) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 覆盖webpack默认配置的都在这里</span><br><span class="line">  if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot;) &#123;</span><br><span class="line">    config.optimization.minimizer[0].options.terserOptions.compress.warnings &#x3D; false;</span><br><span class="line">    config.optimization.minimizer[0].options.terserOptions.compress.drop_console &#x3D; true;</span><br><span class="line">    config.optimization.minimizer[0].options.terserOptions.compress.drop_debugger &#x3D; true;</span><br><span class="line">    config.optimization.minimizer[0].options.terserOptions.compress.pure_funcs &#x3D; [</span><br><span class="line">      &quot;console.log&quot;</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有看到其他用插件的,什么安装<code>babel-plugin-transform-remove-console</code>,安装<code>terser-webpack-plugin</code>, 都太麻烦了,webpack中有自带的,用它的就行</p>
<p>以上就是我对console.log配置的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli 打包优化</title>
    <url>/2020/06/21/129-vue%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>随着项目越来越大,打包的速度也变的很慢,甚至出现了node内存溢出,今天来一起学习一下打包的一些优化</p>
</blockquote>
<a id="more"></a>

<h3 id="node内存溢出"><a href="#node内存溢出" class="headerlink" title="node内存溢出"></a>node内存溢出</h3><p>有些时候,打包或者编译会报这个错误: <code>FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed</code></p>
<p>是因为Node是基于V8引擎,我们的64位电脑只能支持到1.4G的内存,超过这个就会报错,解决方法如下</p>
<p>cnpm install -g increase-memory-limit 全局安装<code>increase-memory-limit</code></p>
<p>进入项目文件夹,运行：<code>increase-memory-limit</code></p>
<p>如果还是不行,在packjson中修改build命令</p>
<p><code>&quot;build&quot;: &quot;node --max_old_space_size=8192 build/build.js&quot;</code></p>
<blockquote>
<p>如果是多人合作的项目,也可以直接将increase-memory-limit配置到文件当中,做法如下</p>
</blockquote>
<p>npm install increase-memory-limit -S<br>npm install cross-env -S</p>
<p>在packjson中添加命令<code>&quot;fix-memory-limit&quot;: &quot;cross-env LIMIT=8192 increase-memory-limit&quot;</code></p>
<p>直接运行 <code>npm run fix-memory-limit</code> 就可以了</p>
<p>可以在/node_modules/.bin/文件中看到,文件被修改了运行内存</p>
<h3 id="使用HappyPack多进程进行loader处理"><a href="#使用HappyPack多进程进行loader处理" class="headerlink" title="使用HappyPack多进程进行loader处理"></a>使用HappyPack多进程进行loader处理</h3><p>优化原理: </p>
<ol>
<li>由于运行在 Node.js 之上的 Webpack 是单线程模型的,所以 Webpack 需要处理的事情只能一件一件地做,不能多件事一起做。</li>
<li>而 HappyPack 的处理思路是：将原有的 webpack 对 loader 的执行过程,从单一进程的形式扩展多进程模式,从而加速代码构建。</li>
</ol>
<p><code>cnpm i happypack -S</code> 安装插件</p>
<p>修改<code>build/webpack.base.conf.js</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const HappyPack &#x3D; require(&#39;happypack&#39;);</span><br><span class="line">&#x2F;&#x2F; node 提供的系统操作模块</span><br><span class="line">const os &#x3D; require(&#39;os&#39;);</span><br><span class="line">&#x2F;&#x2F; 根据我的系统的内核BS数量 指定BS线程池个数 也可以其他数量</span><br><span class="line">const happyThreadPool &#x3D; HappyPack.ThreadPool(&#123; size: os.cpus().length &#125;);</span><br><span class="line"> </span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        &#x2F;&#x2F;把对.js 的文件处理交给id为happyBabel 的HappyPack 的实例执行</span><br><span class="line">        loader: &#39;happypack&#x2F;loader?id&#x3D;happyBabel&#39;,</span><br><span class="line">        include: [resolve(&#39;src&#39;)],</span><br><span class="line">        &#x2F;&#x2F;排除node_modules 目录下的文件</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HappyPack(&#123;</span><br><span class="line">        &#x2F;&#x2F;用id来标识 happypack处理那里类文件</span><br><span class="line">      id: &#39;happyBabel&#39;,</span><br><span class="line">      &#x2F;&#x2F;如何处理  用法和loader 的配置一样</span><br><span class="line">      loaders: [&#123;</span><br><span class="line">        loader: &#39;babel-loader?cacheDirectory&#x3D;true&#39;,</span><br><span class="line">      &#125;],</span><br><span class="line">      &#x2F;&#x2F;共享进程池</span><br><span class="line">      threadPool: happyThreadPool,</span><br><span class="line">      &#x2F;&#x2F;允许 HappyPack 输出日志</span><br><span class="line">      verbose: true,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果报错的话,说明当前使用的webpack版本没有自带os,需要自己安装</p>
</blockquote>
<p>npm i webpack-parallel-uglify-plugin -D<br>npm i os -D</p>
<h3 id="配置loader的-include-amp-exclude"><a href="#配置loader的-include-amp-exclude" class="headerlink" title="配置loader的 include &amp; exclude"></a>配置loader的 include &amp; exclude</h3><p>优化原理</p>
<ol>
<li>webpack 的 loaders 里的每个子项都可以有 include 和 exclude 属性：<ul>
<li>include：导入的文件将由加载程序转换的路径或文件数组（把要处理的目录包括进来）</li>
<li>exclude：不能满足的条件（排除不处理的目录）</li>
</ul>
</li>
<li>我们可以使用 include 更精确地指定要处理的目录，这可以减少不必要的遍历，从而减少性能损失。</li>
<li>同时使用 exclude 对于已经明确知道的，不需要处理的目录，予以排除，从而进一步提升性能。</li>
</ol>
<p>打开 build/webpack.base.conf.js 文件,添加如下 include , exclude 配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: &#x2F;.vue$&#x2F;,</span><br><span class="line">      loader: &#39;vue-loader&#39;,</span><br><span class="line">      options: vueLoaderConfig,</span><br><span class="line">      include: [resolve(&#39;src&#39;)],  &#x2F;&#x2F; 添加配置</span><br><span class="line">      exclude: &#x2F;node_modules(?!(autotrack|dom-utils))|vendor.dll.js&#x2F; &#x2F;&#x2F; 添加配置</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: &#x2F;.js$&#x2F;,</span><br><span class="line">      loader: &#39;babel-loader&#39;,</span><br><span class="line">      include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;), resolve(&#39;node_modules&#x2F;webpack-dev-server&#x2F;client&#39;)], &#x2F;&#x2F; 添加配置</span><br><span class="line">      exclude: &#x2F;node_modules&#x2F; &#x2F;&#x2F; 添加配置</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置-resolve-modules"><a href="#配置-resolve-modules" class="headerlink" title="配置 resolve.modules"></a>配置 resolve.modules</h3><p>优化原理:</p>
<ol>
<li>webpack 的 resolve.modules 是用来配置模块库（即 node_modules）所在的位置。当 js 里出现 import ‘vue’ 这样不是相对、也不是绝对路径的写法时,它便会到 node_modules 目录下去找。</li>
<li>在默认配置下,webpack 会采用向上递归搜索的方式去寻找。但通常项目目录里只有一个 node_modules,且是在项目根目录。为了减少搜索范围,可我们以直接写明 node_modules 的全路径。</li>
</ol>
<p>修改<code>build/webpack.base.conf.js</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;],</span><br><span class="line">    modules: [</span><br><span class="line">      resolve(&#39;src&#39;),</span><br><span class="line">      resolve(&#39;node_modules&#39;)</span><br><span class="line">    ],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      &#39;vue$&#39;: &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;,</span><br><span class="line">      &#39;@&#39;: resolve(&#39;src&#39;),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看打包后的文件体积"><a href="#查看打包后的文件体积" class="headerlink" title="查看打包后的文件体积"></a>查看打包后的文件体积</h3><p>打包的时候 <code>npm run build --report</code></p>
<h3 id="使用webpack-parallel-uglify-plugin多线程压缩JS"><a href="#使用webpack-parallel-uglify-plugin多线程压缩JS" class="headerlink" title="使用webpack-parallel-uglify-plugin多线程压缩JS"></a>使用webpack-parallel-uglify-plugin多线程压缩JS</h3><p>优化原理:</p>
<ol>
<li>默认情况下 webpack 使用 UglifyJS 插件进行代码压缩,但由于其采用单线程压缩,速度很慢。</li>
<li>我们可以改用 webpack-parallel-uglify-plugin 插件,它可以并行运行 UglifyJS 插件,从而更加充分、合理的使用 CPU 资源,从而大大减少构建时间。</li>
</ol>
<p><code>npm i webpack-parallel-uglify-plugin</code> 安装</p>
<p>修改<code>build/webpack.prod.conf.js</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ParallelUglifyPlugin &#x3D; require(&#39;webpack-parallel-uglify-plugin&#39;);</span><br><span class="line">&#x2F;&#x2F; 删掉webpack提供的UglifyJS插件</span><br><span class="line">&#x2F;&#x2F;new UglifyJsPlugin(&#123;</span><br><span class="line">&#x2F;&#x2F;  uglifyOptions: &#123;</span><br><span class="line">&#x2F;&#x2F;    compress: &#123;</span><br><span class="line">&#x2F;&#x2F;      warnings: false</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;  &#125;,</span><br><span class="line">&#x2F;&#x2F;  sourceMap: config.build.productionSourceMap,</span><br><span class="line">&#x2F;&#x2F;  parallel: true</span><br><span class="line">&#x2F;&#x2F;&#125;),</span><br><span class="line">&#x2F;&#x2F; 增加 webpack-parallel-uglify-plugin来替换</span><br><span class="line">  new ParallelUglifyPlugin(&#123;</span><br><span class="line">    cacheDir: &#39;.cache&#x2F;&#39;,</span><br><span class="line">    uglifyJS:&#123;</span><br><span class="line">      output: &#123;</span><br><span class="line">        comments: false</span><br><span class="line">      &#125;,</span><br><span class="line">      compress: &#123;</span><br><span class="line">        drop_debugger: true,</span><br><span class="line">        drop_console: true,</span><br><span class="line">        pure_funcs: [&#39;console.log&#39;]</span><br><span class="line">      &#125;,</span><br><span class="line">      warnings: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>warnings 有一些webpack的版本是放在compress里面的</p>
</blockquote>
<p>可能打包后会报错:</p>
<p>ERROR in Encountered an error while minifying static/js/vendor.js:<br>Maximum call stack size exceeded</p>
<p>不要紧,是因为vendor.js这个文件太大了,导致压缩失败,继续往下走,后面把第三方库抽离出来后就不会报错了</p>
<h3 id="去除map文件-并开启gzip打包"><a href="#去除map文件-并开启gzip打包" class="headerlink" title="去除map文件,并开启gzip打包"></a>去除map文件,并开启gzip打包</h3><p><code>cnpm install --save-dev compression-webpack-plugin@1.1.11</code>安装,这里一定要带版本号安装,否则会报错</p>
<p>在config/index中修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build: &#123;</span><br><span class="line">  productionSourceMap: false,</span><br><span class="line">  productionGzip: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dev中的配置也可以稍微修改一选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devtool: &#39;eval&#39;(最快速度)</span><br></pre></td></tr></table></figure>

<h3 id="使用-DllPlugin-和-DllReferencePlugin-预编译资源模块"><a href="#使用-DllPlugin-和-DllReferencePlugin-预编译资源模块" class="headerlink" title="使用 DllPlugin 和 DllReferencePlugin 预编译资源模块"></a>使用 DllPlugin 和 DllReferencePlugin 预编译资源模块</h3><p>优化原理:</p>
<ol>
<li>我们的项目依赖中通常会引用大量的 npm 包,而这些包在正常的开发过程中并不会进行修改,但是在每一次构建过程中却需要反复的将其解析,而下面介绍的两个插件就是用来规避此类损耗的：<ul>
<li>DllPlugin 插件：作用是预先编译一些模块。</li>
<li>DllReferencePlugin 插件：它的所用则是把这些预先编译好的模块引用起来。</li>
</ul>
</li>
<li>注意：DllPlugin 必须要在 DllReferencePlugin 执行前先执行一次,dll 这个概念应该也是借鉴了 windows 程序开发中的 dll 文件的设计理念。</li>
</ol>
<p>实践: </p>
<p>新建一个配置文件，比如build/webpack.dll.conf.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [&#39;vue&#39;,&#39;vue-router&#39;,&#39;cs-ruler&#39;]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, &#39;..&#x2F;static&#x2F;js&#39;), &#x2F;&#x2F; 打包后文件输出的位置</span><br><span class="line">    filename: &#39;[name].dll.js&#39;,</span><br><span class="line">    library: &#39;[name]_library&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DllPlugin(&#123;</span><br><span class="line">      path: path.join(__dirname, &#39;.&#39;, &#39;[name]-manifest.json&#39;),</span><br><span class="line">      name: &#39;[name]_library&#39;,</span><br><span class="line">      context: __dirname &#x2F;&#x2F;必填，不然在web网页中找不到 &#39;_dll_[name]&#39;，会报错</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; 压缩打包的文件</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>vendor里面就是第三方库</p>
</blockquote>
<p>编辑 package.json 文件,添加一条编译命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;dll&quot;: &quot;webpack --config build&#x2F;webpack.dll.conf.js&quot;</span><br></pre></td></tr></table></figure>

<p>npm run dll 成功以后，static下会有dll.vendor.js，根目录下会有vendor.manifest.json</p>
<p>ok，到这里，抽离依赖库的事情就完成了，那么接下来问题就是怎么引用呢，怎么在dev和build跑呢？</p>
<p>这里补了一点dll和commonsChunk概念上的区别，commonsChunk之所以慢和大，是因为每次run的时候，都会去做一次打包，而实际上我们不会一直去更新我们引用的依赖库，所以dll的做法就等于是，事先先打包好依赖库，然后只对每次都修改的js做打包。</p>
<p>好了,继续</p>
<p>修改build/webpack.dev.conf.js 和 build/webpack.prod.conf.js, 添加DllReferencePlugin的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;.....</span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.DllReferencePlugin(&#123;</span><br><span class="line">    context: __dirname,</span><br><span class="line">    manifest: require(&#39;.&#x2F;vendor-manifest.json&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>最后再index.html中添加<code>&lt;script src=&quot;/static/js/vendor.dll.js&quot;&gt;&lt;/script&gt;</code></p>
<p>到这里,vue打包优化配置基本结束</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>require的基本操作</title>
    <url>/2016/12/28/13-require%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>为什么要用到require？首先，当js文件 都引入的同一个文件下时，会导致命名冲动。其次，js文件之间存在依赖关系，因此必须严格保证加载顺序，依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。所以require很好的解决了这个问题</p>
</blockquote>
<a id="more"></a>

<p>require.js的教程推荐 推荐阮一峰老师的日志，这样附上链接 <a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener">request.js教程</a></p>
<p>我简单的和大家分享一下学习的过程，</p>
<h3 id="require的基本使用"><a href="#require的基本使用" class="headerlink" title="require的基本使用"></a>require的基本使用</h3><pre><code>这里的js1，js2，main，require，html文件都是自己创建的</code></pre><h4 id="html界面"><a href="#html界面" class="headerlink" title="html界面"></a>html界面</h4><pre><code>&lt;script src=&quot;require.js&quot;  data-main=&quot;main&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</code></pre><p>这里的src导入的是require.js——这里的main为主文件的路径，可以不加.js</p>
<h4 id="js页面"><a href="#js页面" class="headerlink" title="js页面"></a>js页面</h4><pre><code>简单的创建几个变量作为测试。比如var a = 5;var b = 10;
这里的js页面不用独立作用域,不需要return</code></pre><h4 id="main页面"><a href="#main页面" class="headerlink" title="main页面"></a>main页面</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'js1'</span>,<span class="string">'js2'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当js1和js2没有独立的时候,main可以使用js1 和 js2 文件中的任意变量,</p>
<p>require.js 默认会把入口js文件所在的路径,作为基本路径,加载其他文件中的js时,需要改变路径</p>
<p>参数一:是一个数组,数组中规定了需要导入的js文件的文件路径,可以同时加载多个js文件<br>参数二:是一个回调函数,等一个参数中的所有js文件全部被加载完成后,才会进行回调参数二中指定的回调函数</p>
<h3 id="require的模块化-AMD"><a href="#require的模块化-AMD" class="headerlink" title="require的模块化(AMD)"></a>require的模块化(AMD)</h3><p>全称是Asynchronous Module Definition，即异步模块加载机制</p>
<p>requireJs优点:</p>
<ol>
<li>说明不同js文件之间的依赖</li>
<li>可以按需求，并行，延时去加载js库</li>
<li>可以让我们的代码已模块的方式使用</li>
</ol>
<p>我将主要代码贴出</p>
<h4 id="html页面"><a href="#html页面" class="headerlink" title="html页面"></a>html页面</h4><pre><code>这个页面和之前的一样</code></pre><h4 id="js页面-1"><a href="#js页面-1" class="headerlink" title="js页面"></a>js页面</h4><p>需要define(),有三个参数：</p>
<ol>
<li>模块的名称        ——–可省略</li>
<li>需要依赖的js    ——–可省略</li>
<li>回调函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">15</span>;</span><br><span class="line">	<span class="keyword">var</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>&#123;a,c&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里需要注意一下，因为导入了js3，所以可以使用js3中的str----这里的js3没有独立</span></span><br><span class="line">define([<span class="string">'js1'</span>,<span class="string">'js3'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">js1</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'这是js2中的函数'</span> +  str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fun</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="main页面-1"><a href="#main页面-1" class="headerlink" title="main页面"></a>main页面</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'js1'</span>,<span class="string">'js2'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">js1,js2</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//js3里面的str在这里也可以被使用，因为js3没有独立，而且已经被js2导入了</span></span><br><span class="line">		<span class="built_in">console</span>.log(str)</span><br><span class="line">	<span class="comment">//由于js1和js2已经独立了，所以在main里面只能用js1 和js2 导出的模块功能</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="require导出模块的四种方式"><a href="#require导出模块的四种方式" class="headerlink" title="require导出模块的四种方式"></a>require导出模块的四种方式</h3><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p>定义模块：define<br>导出模块中的功能:return</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>定义模块：define<br>导出模块中的功能 exports</p>
<p>注意点:</p>
<ol>
<li>需要导入exports作为依赖项</li>
<li>需要有参数</li>
<li>导出时一个一个导出</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'exports'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">exports</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> num1 = <span class="number">11</span>;</span><br><span class="line">	exports.num1 = num1;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><p>定义模块：define<br>导出模块中的功能 module.exports</p>
<p>注意点：</p>
<ol>
<li>这里需要导入module作为依赖项</li>
<li>需要有参数</li>
<li>导出时以对象的形式导出</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'module'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> num1 = <span class="number">111</span>;</span><br><span class="line">	<span class="built_in">module</span>.exports = &#123;num1&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h4><p>注意点：</p>
<ol>
<li>这里需要导入require作为依赖项</li>
<li>需要有参数</li>
<li>其他与第三种方法差不多</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'require'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">require</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'module'</span>)</span><br><span class="line">	<span class="keyword">var</span> num1 = <span class="number">1111</span>;</span><br><span class="line">	<span class="built_in">module</span>.exports = &#123;num1&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>之后在main文件中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'m1'</span>,<span class="string">'m2'</span>,<span class="string">'m3'</span>,<span class="string">'m4'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">m1,m2,m3,m4</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(m1);</span><br><span class="line">	<span class="comment">//使用什么就打点调用什么</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="require的配置及define时定义名字怎么使用"><a href="#require的配置及define时定义名字怎么使用" class="headerlink" title="require的配置及define时定义名字怎么使用"></a>require的配置及define时定义名字怎么使用</h3><p>假设我们要使用一个jq全屏插件，怎么使用require进行配置依赖项</p>
<p>这是需要用到的js文件： jquery.fullscreen.js</p>
<p>最终实现这样的效果： $(document).fullScreen(true)</p>
<p>变量名是随便起的，主要是介绍一下主要的知识点是什么意思</p>
<h4 id="define-使用名字："><a href="#define-使用名字：" class="headerlink" title="define()使用名字："></a>define()使用名字：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="string">'moduleA1'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'这个是a.js中的moduleA1'</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'这个是a.js中的moduleA1'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>一个js文件中可以定义多个模块，一个文件中定义多个模块的话，尽量去使用模块名称进行区分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="string">'moduleA2'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'这个是a.js中的moduleA2'</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'这个是a.js中的moduleA2'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="在主界面main中配置require"><a href="#在主界面main中配置require" class="headerlink" title="在主界面main中配置require"></a>在主界面main中配置require</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">	baseUrl:<span class="string">'lib'</span>,----- 配置基本路径，默认的是入口js文件所在的路径</span><br><span class="line"></span><br><span class="line">	paths:&#123;</span><br><span class="line">		test:<span class="string">'../scripts/aaa/bbb'</span>, ----配置不放在基本路径上的js的路径</span><br><span class="line">		test1:<span class="string">'http://cdn.jquery-3.2.1/'</span> ---含有URL协议的也可以，比如http，导入时不要写后缀.js</span><br><span class="line">		a:<span class="string">'../scripts/a'</span></span><br><span class="line">	&#125;,</span><br><span class="line">	shim:&#123;  ---------配置依赖项，当依赖的模块全部加载结束之后，才会执行当前脚本</span><br><span class="line">		jqueryFullscreen : [<span class="string">'jquery'</span>,<span class="string">'test'</span>]	---对象的属性为模块名（js的名字），数组中的元素一般是相对与baseUrl的路径，只不过没有文件后缀</span><br><span class="line">	&#125;,</span><br><span class="line">	bundles:&#123;--模块树，如果一个js文件中有多个模块，就可以使用这种方法来进行解决</span><br><span class="line">		a:[<span class="string">'moduleA1'</span>,<span class="string">'moduleA2'</span>]	---之前定义的名字在这里使用</span><br><span class="line">	&#125;,</span><br><span class="line">	waitSeconds:<span class="number">7</span> ----设置等待加载，默认<span class="number">7</span>秒</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>配置完之后，就可以使用模块的名字了,要记得写参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'jqueryFullscreen'</span>,<span class="string">'moduleA1'</span>,<span class="string">'moduleA2'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a0,a1,a2</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a1);</span><br><span class="line">	<span class="built_in">console</span>.log(a2);</span><br><span class="line">	<span class="built_in">console</span>.log($.fn.fullScreen);</span><br><span class="line">	<span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line">	$(<span class="string">'div'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		$(<span class="built_in">document</span>).fullScreen(<span class="literal">true</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>require的知识还有许多，这里只是一些入门，如果有错，希望大牛们指点一下，感激不尽</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>AMD</tag>
      </tags>
  </entry>
  <entry>
    <title>echars地图数据下钻</title>
    <url>/2020/06/26/130-Echart%E5%85%A8%E5%9B%BD%E5%9C%B0%E5%9B%BE%E4%B8%8B%E9%92%BB/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>项目中使用到echart的地图,在此记录一下</p>
</blockquote>
<a id="more"></a>

<p>首先引入map的json数据,然后放在static文件中</p>
<p>可以去我的网盘中下载</p>
<p>链接: <a href="https://pan.baidu.com/s/1lUbJvVYDPvfrhRxuPuN48w" target="_blank" rel="noopener">https://pan.baidu.com/s/1lUbJvVYDPvfrhRxuPuN48w</a> 提取码: ndi9</p>
<p>新建一个map.js,用来放各个地区的编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 34个省、市、自治区的名字拼音映射数组</span><br><span class="line">var provinces &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 23个省</span><br><span class="line">  台湾: &#39;taiwan&#39;,</span><br><span class="line">  河北: &#39;hebei&#39;,</span><br><span class="line">  山西: &#39;shanxi&#39;,</span><br><span class="line">  辽宁: &#39;liaoning&#39;,</span><br><span class="line">  吉林: &#39;jilin&#39;,</span><br><span class="line">  黑龙江: &#39;heilongjiang&#39;,</span><br><span class="line">  江苏: &#39;jiangsu&#39;,</span><br><span class="line">  浙江: &#39;zhejiang&#39;,</span><br><span class="line">  安徽: &#39;anhui&#39;,</span><br><span class="line">  福建: &#39;fujian&#39;,</span><br><span class="line">  江西: &#39;jiangxi&#39;,</span><br><span class="line">  山东: &#39;shandong&#39;,</span><br><span class="line">  河南: &#39;henan&#39;,</span><br><span class="line">  湖北: &#39;hubei&#39;,</span><br><span class="line">  湖南: &#39;hunan&#39;,</span><br><span class="line">  广东: &#39;guangdong&#39;,</span><br><span class="line">  海南: &#39;hainan&#39;,</span><br><span class="line">  四川: &#39;sichuan&#39;,</span><br><span class="line">  贵州: &#39;guizhou&#39;,</span><br><span class="line">  云南: &#39;yunnan&#39;,</span><br><span class="line">  陕西: &#39;shanxi1&#39;,</span><br><span class="line">  甘肃: &#39;gansu&#39;,</span><br><span class="line">  青海: &#39;qinghai&#39;,</span><br><span class="line">  &#x2F;&#x2F; 5个自治区</span><br><span class="line">  新疆: &#39;xinjiang&#39;,</span><br><span class="line">  广西: &#39;guangxi&#39;,</span><br><span class="line">  内蒙古: &#39;neimenggu&#39;,</span><br><span class="line">  宁夏: &#39;ningxia&#39;,</span><br><span class="line">  西藏: &#39;xizang&#39;,</span><br><span class="line">  &#x2F;&#x2F; 4个直辖市</span><br><span class="line">  北京: &#39;beijing&#39;,</span><br><span class="line">  天津: &#39;tianjin&#39;,</span><br><span class="line">  上海: &#39;shanghai&#39;,</span><br><span class="line">  重庆: &#39;chongqing&#39;,</span><br><span class="line">  &#x2F;&#x2F; 2个特别行政区</span><br><span class="line">  香港: &#39;xianggang&#39;,</span><br><span class="line">  澳门: &#39;aomen&#39;</span><br><span class="line">&#125;</span><br><span class="line">var cityMap &#x3D; &#123;</span><br><span class="line">  北京市: &#39;110100&#39;,</span><br><span class="line">  天津市: &#39;120100&#39;,</span><br><span class="line">  上海市: &#39;310100&#39;,</span><br><span class="line">  重庆市: &#39;500100&#39;,</span><br><span class="line">  崇明县: &#39;310200&#39;,</span><br><span class="line">  湖北省直辖县市: &#39;429000&#39;,</span><br><span class="line">  铜仁市: &#39;522200&#39;,</span><br><span class="line">  毕节市: &#39;522400&#39;,</span><br><span class="line">  石家庄市: &#39;130100&#39;,</span><br><span class="line">  唐山市: &#39;130200&#39;,</span><br><span class="line">  秦皇岛市: &#39;130300&#39;,</span><br><span class="line">  邯郸市: &#39;130400&#39;,</span><br><span class="line">  邢台市: &#39;130500&#39;,</span><br><span class="line">  保定市: &#39;130600&#39;,</span><br><span class="line">  张家口市: &#39;130700&#39;,</span><br><span class="line">  承德市: &#39;130800&#39;,</span><br><span class="line">  沧州市: &#39;130900&#39;,</span><br><span class="line">  廊坊市: &#39;131000&#39;,</span><br><span class="line">  衡水市: &#39;131100&#39;,</span><br><span class="line">  太原市: &#39;140100&#39;,</span><br><span class="line">  大同市: &#39;140200&#39;,</span><br><span class="line">  阳泉市: &#39;140300&#39;,</span><br><span class="line">  长治市: &#39;140400&#39;,</span><br><span class="line">  晋城市: &#39;140500&#39;,</span><br><span class="line">  朔州市: &#39;140600&#39;,</span><br><span class="line">  晋中市: &#39;140700&#39;,</span><br><span class="line">  运城市: &#39;140800&#39;,</span><br><span class="line">  忻州市: &#39;140900&#39;,</span><br><span class="line">  临汾市: &#39;141000&#39;,</span><br><span class="line">  吕梁市: &#39;141100&#39;,</span><br><span class="line">  呼和浩特市: &#39;150100&#39;,</span><br><span class="line">  包头市: &#39;150200&#39;,</span><br><span class="line">  乌海市: &#39;150300&#39;,</span><br><span class="line">  赤峰市: &#39;150400&#39;,</span><br><span class="line">  通辽市: &#39;150500&#39;,</span><br><span class="line">  鄂尔多斯市: &#39;150600&#39;,</span><br><span class="line">  呼伦贝尔市: &#39;150700&#39;,</span><br><span class="line">  巴彦淖尔市: &#39;150800&#39;,</span><br><span class="line">  乌兰察布市: &#39;150900&#39;,</span><br><span class="line">  兴安盟: &#39;152200&#39;,</span><br><span class="line">  锡林郭勒盟: &#39;152500&#39;,</span><br><span class="line">  阿拉善盟: &#39;152900&#39;,</span><br><span class="line">  沈阳市: &#39;210100&#39;,</span><br><span class="line">  大连市: &#39;210200&#39;,</span><br><span class="line">  鞍山市: &#39;210300&#39;,</span><br><span class="line">  抚顺市: &#39;210400&#39;,</span><br><span class="line">  本溪市: &#39;210500&#39;,</span><br><span class="line">  丹东市: &#39;210600&#39;,</span><br><span class="line">  锦州市: &#39;210700&#39;,</span><br><span class="line">  营口市: &#39;210800&#39;,</span><br><span class="line">  阜新市: &#39;210900&#39;,</span><br><span class="line">  辽阳市: &#39;211000&#39;,</span><br><span class="line">  盘锦市: &#39;211100&#39;,</span><br><span class="line">  铁岭市: &#39;211200&#39;,</span><br><span class="line">  朝阳市: &#39;211300&#39;,</span><br><span class="line">  葫芦岛市: &#39;211400&#39;,</span><br><span class="line">  长春市: &#39;220100&#39;,</span><br><span class="line">  吉林市: &#39;220200&#39;,</span><br><span class="line">  四平市: &#39;220300&#39;,</span><br><span class="line">  辽源市: &#39;220400&#39;,</span><br><span class="line">  通化市: &#39;220500&#39;,</span><br><span class="line">  白山市: &#39;220600&#39;,</span><br><span class="line">  松原市: &#39;220700&#39;,</span><br><span class="line">  白城市: &#39;220800&#39;,</span><br><span class="line">  延边朝鲜族自治州: &#39;222400&#39;,</span><br><span class="line">  哈尔滨市: &#39;230100&#39;,</span><br><span class="line">  齐齐哈尔市: &#39;230200&#39;,</span><br><span class="line">  鸡西市: &#39;230300&#39;,</span><br><span class="line">  鹤岗市: &#39;230400&#39;,</span><br><span class="line">  双鸭山市: &#39;230500&#39;,</span><br><span class="line">  大庆市: &#39;230600&#39;,</span><br><span class="line">  伊春市: &#39;230700&#39;,</span><br><span class="line">  佳木斯市: &#39;230800&#39;,</span><br><span class="line">  七台河市: &#39;230900&#39;,</span><br><span class="line">  牡丹江市: &#39;231000&#39;,</span><br><span class="line">  黑河市: &#39;231100&#39;,</span><br><span class="line">  绥化市: &#39;231200&#39;,</span><br><span class="line">  大兴安岭地区: &#39;232700&#39;,</span><br><span class="line">  南京市: &#39;320100&#39;,</span><br><span class="line">  无锡市: &#39;320200&#39;,</span><br><span class="line">  徐州市: &#39;320300&#39;,</span><br><span class="line">  常州市: &#39;320400&#39;,</span><br><span class="line">  苏州市: &#39;320500&#39;,</span><br><span class="line">  南通市: &#39;320600&#39;,</span><br><span class="line">  连云港市: &#39;320700&#39;,</span><br><span class="line">  淮安市: &#39;320800&#39;,</span><br><span class="line">  盐城市: &#39;320900&#39;,</span><br><span class="line">  扬州市: &#39;321000&#39;,</span><br><span class="line">  镇江市: &#39;321100&#39;,</span><br><span class="line">  泰州市: &#39;321200&#39;,</span><br><span class="line">  宿迁市: &#39;321300&#39;,</span><br><span class="line">  杭州市: &#39;330100&#39;,</span><br><span class="line">  宁波市: &#39;330200&#39;,</span><br><span class="line">  温州市: &#39;330300&#39;,</span><br><span class="line">  嘉兴市: &#39;330400&#39;,</span><br><span class="line">  湖州市: &#39;330500&#39;,</span><br><span class="line">  绍兴市: &#39;330600&#39;,</span><br><span class="line">  金华市: &#39;330700&#39;,</span><br><span class="line">  衢州市: &#39;330800&#39;,</span><br><span class="line">  舟山市: &#39;330900&#39;,</span><br><span class="line">  台州市: &#39;331000&#39;,</span><br><span class="line">  丽水市: &#39;331100&#39;,</span><br><span class="line">  合肥市: &#39;340100&#39;,</span><br><span class="line">  芜湖市: &#39;340200&#39;,</span><br><span class="line">  蚌埠市: &#39;340300&#39;,</span><br><span class="line">  淮南市: &#39;340400&#39;,</span><br><span class="line">  马鞍山市: &#39;340500&#39;,</span><br><span class="line">  淮北市: &#39;340600&#39;,</span><br><span class="line">  铜陵市: &#39;340700&#39;,</span><br><span class="line">  安庆市: &#39;340800&#39;,</span><br><span class="line">  黄山市: &#39;341000&#39;,</span><br><span class="line">  滁州市: &#39;341100&#39;,</span><br><span class="line">  阜阳市: &#39;341200&#39;,</span><br><span class="line">  宿州市: &#39;341300&#39;,</span><br><span class="line">  六安市: &#39;341500&#39;,</span><br><span class="line">  亳州市: &#39;341600&#39;,</span><br><span class="line">  池州市: &#39;341700&#39;,</span><br><span class="line">  宣城市: &#39;341800&#39;,</span><br><span class="line">  福州市: &#39;350100&#39;,</span><br><span class="line">  厦门市: &#39;350200&#39;,</span><br><span class="line">  莆田市: &#39;350300&#39;,</span><br><span class="line">  三明市: &#39;350400&#39;,</span><br><span class="line">  泉州市: &#39;350500&#39;,</span><br><span class="line">  漳州市: &#39;350600&#39;,</span><br><span class="line">  南平市: &#39;350700&#39;,</span><br><span class="line">  龙岩市: &#39;350800&#39;,</span><br><span class="line">  宁德市: &#39;350900&#39;,</span><br><span class="line">  南昌市: &#39;360100&#39;,</span><br><span class="line">  景德镇市: &#39;360200&#39;,</span><br><span class="line">  萍乡市: &#39;360300&#39;,</span><br><span class="line">  九江市: &#39;360400&#39;,</span><br><span class="line">  新余市: &#39;360500&#39;,</span><br><span class="line">  鹰潭市: &#39;360600&#39;,</span><br><span class="line">  赣州市: &#39;360700&#39;,</span><br><span class="line">  吉安市: &#39;360800&#39;,</span><br><span class="line">  宜春市: &#39;360900&#39;,</span><br><span class="line">  抚州市: &#39;361000&#39;,</span><br><span class="line">  上饶市: &#39;361100&#39;,</span><br><span class="line">  济南市: &#39;370100&#39;,</span><br><span class="line">  青岛市: &#39;370200&#39;,</span><br><span class="line">  淄博市: &#39;370300&#39;,</span><br><span class="line">  枣庄市: &#39;370400&#39;,</span><br><span class="line">  东营市: &#39;370500&#39;,</span><br><span class="line">  烟台市: &#39;370600&#39;,</span><br><span class="line">  潍坊市: &#39;370700&#39;,</span><br><span class="line">  济宁市: &#39;370800&#39;,</span><br><span class="line">  泰安市: &#39;370900&#39;,</span><br><span class="line">  威海市: &#39;371000&#39;,</span><br><span class="line">  日照市: &#39;371100&#39;,</span><br><span class="line">  莱芜市: &#39;371200&#39;,</span><br><span class="line">  临沂市: &#39;371300&#39;,</span><br><span class="line">  德州市: &#39;371400&#39;,</span><br><span class="line">  聊城市: &#39;371500&#39;,</span><br><span class="line">  滨州市: &#39;371600&#39;,</span><br><span class="line">  菏泽市: &#39;371700&#39;,</span><br><span class="line">  郑州市: &#39;410100&#39;,</span><br><span class="line">  开封市: &#39;410200&#39;,</span><br><span class="line">  洛阳市: &#39;410300&#39;,</span><br><span class="line">  平顶山市: &#39;410400&#39;,</span><br><span class="line">  安阳市: &#39;410500&#39;,</span><br><span class="line">  鹤壁市: &#39;410600&#39;,</span><br><span class="line">  新乡市: &#39;410700&#39;,</span><br><span class="line">  焦作市: &#39;410800&#39;,</span><br><span class="line">  濮阳市: &#39;410900&#39;,</span><br><span class="line">  许昌市: &#39;411000&#39;,</span><br><span class="line">  漯河市: &#39;411100&#39;,</span><br><span class="line">  三门峡市: &#39;411200&#39;,</span><br><span class="line">  南阳市: &#39;411300&#39;,</span><br><span class="line">  商丘市: &#39;411400&#39;,</span><br><span class="line">  信阳市: &#39;411500&#39;,</span><br><span class="line">  周口市: &#39;411600&#39;,</span><br><span class="line">  驻马店市: &#39;411700&#39;,</span><br><span class="line">  省直辖县级行政区划: &#39;469000&#39;,</span><br><span class="line">  武汉市: &#39;420100&#39;,</span><br><span class="line">  黄石市: &#39;420200&#39;,</span><br><span class="line">  十堰市: &#39;420300&#39;,</span><br><span class="line">  宜昌市: &#39;420500&#39;,</span><br><span class="line">  襄阳市: &#39;420600&#39;,</span><br><span class="line">  鄂州市: &#39;420700&#39;,</span><br><span class="line">  荆门市: &#39;420800&#39;,</span><br><span class="line">  孝感市: &#39;420900&#39;,</span><br><span class="line">  荆州市: &#39;421000&#39;,</span><br><span class="line">  黄冈市: &#39;421100&#39;,</span><br><span class="line">  咸宁市: &#39;421200&#39;,</span><br><span class="line">  随州市: &#39;421300&#39;,</span><br><span class="line">  恩施土家族苗族自治州: &#39;422800&#39;,</span><br><span class="line">  长沙市: &#39;430100&#39;,</span><br><span class="line">  株洲市: &#39;430200&#39;,</span><br><span class="line">  湘潭市: &#39;430300&#39;,</span><br><span class="line">  衡阳市: &#39;430400&#39;,</span><br><span class="line">  邵阳市: &#39;430500&#39;,</span><br><span class="line">  岳阳市: &#39;430600&#39;,</span><br><span class="line">  常德市: &#39;430700&#39;,</span><br><span class="line">  张家界市: &#39;430800&#39;,</span><br><span class="line">  益阳市: &#39;430900&#39;,</span><br><span class="line">  郴州市: &#39;431000&#39;,</span><br><span class="line">  永州市: &#39;431100&#39;,</span><br><span class="line">  怀化市: &#39;431200&#39;,</span><br><span class="line">  娄底市: &#39;431300&#39;,</span><br><span class="line">  湘西土家族苗族自治州: &#39;433100&#39;,</span><br><span class="line">  广州市: &#39;440100&#39;,</span><br><span class="line">  韶关市: &#39;440200&#39;,</span><br><span class="line">  深圳市: &#39;440300&#39;,</span><br><span class="line">  珠海市: &#39;440400&#39;,</span><br><span class="line">  汕头市: &#39;440500&#39;,</span><br><span class="line">  佛山市: &#39;440600&#39;,</span><br><span class="line">  江门市: &#39;440700&#39;,</span><br><span class="line">  湛江市: &#39;440800&#39;,</span><br><span class="line">  茂名市: &#39;440900&#39;,</span><br><span class="line">  肇庆市: &#39;441200&#39;,</span><br><span class="line">  惠州市: &#39;441300&#39;,</span><br><span class="line">  梅州市: &#39;441400&#39;,</span><br><span class="line">  汕尾市: &#39;441500&#39;,</span><br><span class="line">  河源市: &#39;441600&#39;,</span><br><span class="line">  阳江市: &#39;441700&#39;,</span><br><span class="line">  清远市: &#39;441800&#39;,</span><br><span class="line">  东莞市: &#39;441900&#39;,</span><br><span class="line">  中山市: &#39;442000&#39;,</span><br><span class="line">  潮州市: &#39;445100&#39;,</span><br><span class="line">  揭阳市: &#39;445200&#39;,</span><br><span class="line">  云浮市: &#39;445300&#39;,</span><br><span class="line">  南宁市: &#39;450100&#39;,</span><br><span class="line">  柳州市: &#39;450200&#39;,</span><br><span class="line">  桂林市: &#39;450300&#39;,</span><br><span class="line">  梧州市: &#39;450400&#39;,</span><br><span class="line">  北海市: &#39;450500&#39;,</span><br><span class="line">  防城港市: &#39;450600&#39;,</span><br><span class="line">  钦州市: &#39;450700&#39;,</span><br><span class="line">  贵港市: &#39;450800&#39;,</span><br><span class="line">  玉林市: &#39;450900&#39;,</span><br><span class="line">  百色市: &#39;451000&#39;,</span><br><span class="line">  贺州市: &#39;451100&#39;,</span><br><span class="line">  河池市: &#39;451200&#39;,</span><br><span class="line">  来宾市: &#39;451300&#39;,</span><br><span class="line">  崇左市: &#39;451400&#39;,</span><br><span class="line">  海口市: &#39;460100&#39;,</span><br><span class="line">  三亚市: &#39;460200&#39;,</span><br><span class="line">  三沙市: &#39;460300&#39;,</span><br><span class="line">  成都市: &#39;510100&#39;,</span><br><span class="line">  自贡市: &#39;510300&#39;,</span><br><span class="line">  攀枝花市: &#39;510400&#39;,</span><br><span class="line">  泸州市: &#39;510500&#39;,</span><br><span class="line">  德阳市: &#39;510600&#39;,</span><br><span class="line">  绵阳市: &#39;510700&#39;,</span><br><span class="line">  广元市: &#39;510800&#39;,</span><br><span class="line">  遂宁市: &#39;510900&#39;,</span><br><span class="line">  内江市: &#39;511000&#39;,</span><br><span class="line">  乐山市: &#39;511100&#39;,</span><br><span class="line">  南充市: &#39;511300&#39;,</span><br><span class="line">  眉山市: &#39;511400&#39;,</span><br><span class="line">  宜宾市: &#39;511500&#39;,</span><br><span class="line">  广安市: &#39;511600&#39;,</span><br><span class="line">  达州市: &#39;511700&#39;,</span><br><span class="line">  雅安市: &#39;511800&#39;,</span><br><span class="line">  巴中市: &#39;511900&#39;,</span><br><span class="line">  资阳市: &#39;512000&#39;,</span><br><span class="line">  阿坝藏族羌族自治州: &#39;513200&#39;,</span><br><span class="line">  甘孜藏族自治州: &#39;513300&#39;,</span><br><span class="line">  凉山彝族自治州: &#39;513400&#39;,</span><br><span class="line">  贵阳市: &#39;520100&#39;,</span><br><span class="line">  六盘水市: &#39;520200&#39;,</span><br><span class="line">  遵义市: &#39;520300&#39;,</span><br><span class="line">  安顺市: &#39;520400&#39;,</span><br><span class="line">  黔西南布依族苗族自治州: &#39;522300&#39;,</span><br><span class="line">  黔东南苗族侗族自治州: &#39;522600&#39;,</span><br><span class="line">  黔南布依族苗族自治州: &#39;522700&#39;,</span><br><span class="line">  昆明市: &#39;530100&#39;,</span><br><span class="line">  曲靖市: &#39;530300&#39;,</span><br><span class="line">  玉溪市: &#39;530400&#39;,</span><br><span class="line">  保山市: &#39;530500&#39;,</span><br><span class="line">  昭通市: &#39;530600&#39;,</span><br><span class="line">  丽江市: &#39;530700&#39;,</span><br><span class="line">  普洱市: &#39;530800&#39;,</span><br><span class="line">  临沧市: &#39;530900&#39;,</span><br><span class="line">  楚雄彝族自治州: &#39;532300&#39;,</span><br><span class="line">  红河哈尼族彝族自治州: &#39;532500&#39;,</span><br><span class="line">  文山壮族苗族自治州: &#39;532600&#39;,</span><br><span class="line">  西双版纳傣族自治州: &#39;532800&#39;,</span><br><span class="line">  大理白族自治州: &#39;532900&#39;,</span><br><span class="line">  德宏傣族景颇族自治州: &#39;533100&#39;,</span><br><span class="line">  怒江傈僳族自治州: &#39;533300&#39;,</span><br><span class="line">  迪庆藏族自治州: &#39;533400&#39;,</span><br><span class="line">  拉萨市: &#39;540100&#39;,</span><br><span class="line">  昌都地区: &#39;542100&#39;,</span><br><span class="line">  山南地区: &#39;542200&#39;,</span><br><span class="line">  日喀则地区: &#39;542300&#39;,</span><br><span class="line">  那曲地区: &#39;542400&#39;,</span><br><span class="line">  阿里地区: &#39;542500&#39;,</span><br><span class="line">  林芝地区: &#39;542600&#39;,</span><br><span class="line">  西安市: &#39;610100&#39;,</span><br><span class="line">  铜川市: &#39;610200&#39;,</span><br><span class="line">  宝鸡市: &#39;610300&#39;,</span><br><span class="line">  咸阳市: &#39;610400&#39;,</span><br><span class="line">  渭南市: &#39;610500&#39;,</span><br><span class="line">  延安市: &#39;610600&#39;,</span><br><span class="line">  汉中市: &#39;610700&#39;,</span><br><span class="line">  榆林市: &#39;610800&#39;,</span><br><span class="line">  安康市: &#39;610900&#39;,</span><br><span class="line">  商洛市: &#39;611000&#39;,</span><br><span class="line">  兰州市: &#39;620100&#39;,</span><br><span class="line">  嘉峪关市: &#39;620200&#39;,</span><br><span class="line">  金昌市: &#39;620300&#39;,</span><br><span class="line">  白银市: &#39;620400&#39;,</span><br><span class="line">  天水市: &#39;620500&#39;,</span><br><span class="line">  武威市: &#39;620600&#39;,</span><br><span class="line">  张掖市: &#39;620700&#39;,</span><br><span class="line">  平凉市: &#39;620800&#39;,</span><br><span class="line">  酒泉市: &#39;620900&#39;,</span><br><span class="line">  庆阳市: &#39;621000&#39;,</span><br><span class="line">  定西市: &#39;621100&#39;,</span><br><span class="line">  陇南市: &#39;621200&#39;,</span><br><span class="line">  临夏回族自治州: &#39;622900&#39;,</span><br><span class="line">  甘南藏族自治州: &#39;623000&#39;,</span><br><span class="line">  西宁市: &#39;630100&#39;,</span><br><span class="line">  海东地区: &#39;632100&#39;,</span><br><span class="line">  海北藏族自治州: &#39;632200&#39;,</span><br><span class="line">  黄南藏族自治州: &#39;632300&#39;,</span><br><span class="line">  海南藏族自治州: &#39;632500&#39;,</span><br><span class="line">  果洛藏族自治州: &#39;632600&#39;,</span><br><span class="line">  玉树藏族自治州: &#39;632700&#39;,</span><br><span class="line">  海西蒙古族藏族自治州: &#39;632800&#39;,</span><br><span class="line">  银川市: &#39;640100&#39;,</span><br><span class="line">  石嘴山市: &#39;640200&#39;,</span><br><span class="line">  吴忠市: &#39;640300&#39;,</span><br><span class="line">  固原市: &#39;640400&#39;,</span><br><span class="line">  中卫市: &#39;640500&#39;,</span><br><span class="line">  乌鲁木齐市: &#39;650100&#39;,</span><br><span class="line">  克拉玛依市: &#39;650200&#39;,</span><br><span class="line">  吐鲁番地区: &#39;652100&#39;,</span><br><span class="line">  哈密地区: &#39;652200&#39;,</span><br><span class="line">  昌吉回族自治州: &#39;652300&#39;,</span><br><span class="line">  博尔塔拉蒙古自治州: &#39;652700&#39;,</span><br><span class="line">  巴音郭楞蒙古自治州: &#39;652800&#39;,</span><br><span class="line">  阿克苏地区: &#39;652900&#39;,</span><br><span class="line">  克孜勒苏柯尔克孜自治州: &#39;653000&#39;,</span><br><span class="line">  喀什地区: &#39;653100&#39;,</span><br><span class="line">  和田地区: &#39;653200&#39;,</span><br><span class="line">  伊犁哈萨克自治州: &#39;654000&#39;,</span><br><span class="line">  塔城地区: &#39;654200&#39;,</span><br><span class="line">  阿勒泰地区: &#39;654300&#39;,</span><br><span class="line">  自治区直辖县级行政区划: &#39;659000&#39;,</span><br><span class="line">  台湾省: &#39;710000&#39;,</span><br><span class="line">  香港特别行政区: &#39;810100&#39;,</span><br><span class="line">  澳门特别行政区: &#39;820000&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; provinces, cityMap &#125;</span><br></pre></td></tr></table></figure>

<p>然后再vue文件中引入,提前将echart和axios在main中先导入好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;map&quot; :style&#x3D;&quot;&#123;width: &#39;100%&#39;,height: &#39;700px&#39;&#125;&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; provinces, cityMap&#125; from &#39;.&#x2F;map.js&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      myMapChart: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 预留绘制全国地图</span><br><span class="line">    initMap() &#123;</span><br><span class="line">      this.myMapChart &#x3D; this.$echarts.init(document.getElementById(&#39;map&#39;))</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 直辖市和特别行政区-只有二级地图，没有三级地图</span><br><span class="line">      let special &#x3D; [&#39;北京&#39;, &#39;天津&#39;, &#39;上海&#39;, &#39;重庆&#39;, &#39;香港&#39;, &#39;澳门&#39;]</span><br><span class="line">      let mapdata &#x3D; []</span><br><span class="line">      &#x2F;&#x2F; 这是组件开始初始化时需要拉去的数据--中国地图的数据</span><br><span class="line">      this.$axios.get(&#39;static&#x2F;map&#x2F;china.json&#39;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">        let data &#x3D; res.data</span><br><span class="line">        let d &#x3D; []</span><br><span class="line">        for (let i &#x3D; 0; i &lt; data.features.length; i++) &#123;</span><br><span class="line">          d.push(&#123;</span><br><span class="line">            name: data.features[i].properties.name</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        mapdata &#x3D; d</span><br><span class="line">        &#x2F;&#x2F; 注册地图</span><br><span class="line">        this.$echarts.registerMap(&#39;china&#39;, data)</span><br><span class="line">        &#x2F;&#x2F; 绘制地图</span><br><span class="line">        renderMap(&#39;china&#39;, d)</span><br><span class="line">      &#125;)</span><br><span class="line">      &#x2F;&#x2F; 绑定点击事件</span><br><span class="line">      this.myMapChart.on(&#39;click&#39;, (params)&#x3D;&gt; &#123;</span><br><span class="line">        console.log(params)</span><br><span class="line">      	if (params.name in provinces) &#123;</span><br><span class="line">      		&#x2F;&#x2F; 如果点击的是34个省、市、自治区，绘制选中地区的二级地图</span><br><span class="line">          this.$axios.get(&#39;static&#x2F;map&#x2F;json&#x2F;province&#x2F;&#39; + provinces[params.name] + &#39;.json&#39;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">            let data &#x3D; res.data</span><br><span class="line">            let d &#x3D; []</span><br><span class="line">            this.$echarts.registerMap(params.name, data)</span><br><span class="line">            for (let i &#x3D; 0; i &lt; data.features.length; i++) &#123;</span><br><span class="line">            	d.push(&#123;</span><br><span class="line">            		name: data.features[i].properties.name</span><br><span class="line">            	&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            renderMap(params.name, d)</span><br><span class="line">          &#125;)</span><br><span class="line">      	&#125; else if (params.seriesName in provinces) &#123;</span><br><span class="line">      		&#x2F;&#x2F; 如果是【直辖市&#x2F;特别行政区】只有二级下钻</span><br><span class="line">      		if (special.indexOf(params.seriesName) &gt;&#x3D; 0) &#123;</span><br><span class="line">      			renderMap(&#39;china&#39;, mapdata)</span><br><span class="line">      		&#125; else &#123;</span><br><span class="line">      			&#x2F;&#x2F; 显示县级地图</span><br><span class="line">            this.$axios.get(&#39;static&#x2F;map&#x2F;json&#x2F;citys&#x2F;&#39; + cityMap[params.name] + &#39;.json&#39;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">              console.log(res)</span><br><span class="line">              let data &#x3D; res.data</span><br><span class="line">              let d &#x3D; []</span><br><span class="line">      				this.$echarts.registerMap(params.name, data)</span><br><span class="line">      				for (let i &#x3D; 0; i &lt; data.features.length; i++) &#123;</span><br><span class="line">      					d.push(&#123;</span><br><span class="line">      						name: data.features[i].properties.name</span><br><span class="line">      					&#125;)</span><br><span class="line">      				&#125;</span><br><span class="line">      				renderMap(params.name, d)</span><br><span class="line">      			&#125;)</span><br><span class="line">      		&#125;</span><br><span class="line">      	&#125; else &#123;</span><br><span class="line">      		&#x2F;&#x2F; 点击县级时是否返回</span><br><span class="line">      		renderMap(&#39;china&#39;, mapdata)</span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 初始化绘制全国地图配置</span><br><span class="line">      let _this &#x3D; this</span><br><span class="line">      function renderMap(map, data) &#123;</span><br><span class="line">        let option &#x3D; &#123;</span><br><span class="line">          backgroundColor: &#39;#FFFFFF&#39;,</span><br><span class="line">          grid: &#123;</span><br><span class="line">            height: &#39;100%&#39;,</span><br><span class="line">            width: &#39;100%&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          series: [&#123;</span><br><span class="line">            name: map,</span><br><span class="line">            type: &#39;map&#39;,</span><br><span class="line">            mapType: map,</span><br><span class="line">            roam: false,</span><br><span class="line">            data: data,</span><br><span class="line">            nameMap: &#123;</span><br><span class="line">              china: &#39;中国&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            label: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                show: true,</span><br><span class="line">                textStyle: &#123;</span><br><span class="line">                  color: &#39;#333&#39;,</span><br><span class="line">                  fontSize: 12</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              emphasis: &#123;</span><br><span class="line">                show: true,</span><br><span class="line">                textStyle: &#123;</span><br><span class="line">                  color: &#39;#fff&#39;,</span><br><span class="line">                  fontSize: 12</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">              normal: &#123;</span><br><span class="line">                areaColor: &#39;#76b1ff&#39;,</span><br><span class="line">                borderColor: &#39;#eee&#39;,</span><br><span class="line">                shadowColor: &#39;#76b1ff&#39;,</span><br><span class="line">                shadowBlur: 10,</span><br><span class="line">                borderWidth: 2</span><br><span class="line">              &#125;,</span><br><span class="line">              emphasis: &#123;</span><br><span class="line">                &#x2F;&#x2F; 鼠标移入颜色</span><br><span class="line">                areaColor: &#39;#409EFF&#39;,</span><br><span class="line">                borderWidth: 0</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">      	&#x2F;&#x2F; 渲染地图</span><br><span class="line">      	_this.myMapChart.setOption(option)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.initMap()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>代码已经贴出来了,复制就可以直接使用</p>
<p>如果想要将地图当成背景使用,echarts中有一个geo的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">geo: &#123;</span><br><span class="line">  map: map,</span><br><span class="line">  top: &#39;center&#39;,</span><br><span class="line">  left: &#39;60&#39;,</span><br><span class="line">  roam: false,</span><br><span class="line">  width: &#39;100%&#39;,</span><br><span class="line">  height: &#39;100%&#39;,</span><br><span class="line">  zoom: 0.85,</span><br><span class="line">  label: &#123;</span><br><span class="line">    show: true,</span><br><span class="line">    normal: &#123;</span><br><span class="line">      show: true,</span><br><span class="line">      color: &#39;#333&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    emphasis: &#123;</span><br><span class="line">      color: &#39;#fff&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  itemStyle: &#123;</span><br><span class="line">    normal: &#123;</span><br><span class="line">      areaColor: &#39;#76b1ff&#39;,</span><br><span class="line">      borderColor: &#39;#eee&#39;,</span><br><span class="line">      shadowColor: &#39;#76b1ff&#39;,</span><br><span class="line">      shadowBlur: 10,</span><br><span class="line">      borderWidth: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    emphasis: &#123;</span><br><span class="line">      &#x2F;&#x2F; 鼠标移入颜色</span><br><span class="line">      areaColor: &#39;#409EFF&#39;,</span><br><span class="line">      borderWidth: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以让地图当成背景使用,在上面绘制其他图表</p>
<p>以上就是我对Echart地图配置的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>echars</category>
      </categories>
      <tags>
        <tag>echars</tag>
      </tags>
  </entry>
  <entry>
    <title>神器扒网站——teleport ultra</title>
    <url>/2020/06/26/131-%E7%88%AC%E7%BD%91%E7%AB%99%E7%A5%9E%E5%99%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>在平时的开发或者学习的过程中，我们难免会看到一些让人心动的网站，于是自己想把它搞下来，自己手工一个文件一个文件把它保存下来也可以实现，完成了也累得够呛，有一款扒站的神器，可以把你所喜欢的目标网站整个网站给扒下来，这个神器就是teleport ultra！</p>
</blockquote>
<a id="more"></a>

<h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><p>首先到官网下载：<a href="http://www.tenmax.com/teleport/ultra/download.htm" target="_blank" rel="noopener">http://www.tenmax.com/teleport/ultra/download.htm</a> 然后按照软件的安装指引完成安装</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>打开软件 </p>
<p>点击File，然后点击 New Project Wizred…，选择第一项，点击下一步 </p>
<p>然后在输入框输入你要扒的网站的地址，点击下一步 </p>
<p>选择everything，点击下一步，然后点击完成 </p>
<p>选择本地保存网站源文件的路径后，点击保存 </p>
<p>再单击start，即开始扒网站的文件 </p>
<p>搞定 </p>
]]></content>
      <categories>
        <category>teleport</category>
      </categories>
      <tags>
        <tag>teleport</tag>
      </tags>
  </entry>
  <entry>
    <title>element-ui动态换肤</title>
    <url>/2020/06/27/132-element-ui%E5%8A%A8%E6%80%81%E6%8D%A2%E8%82%A4/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>element-ui这个框架想必大家都不陌生,今天学习一下如何动态更改主题色</p>
</blockquote>
<a id="more"></a>

<p>官网有提供改变主题色的方法,但是那个仅适用于一次性的更改全局主题颜色</p>
<p>如果我们想要实时根据ColorPicker颜色选择器进行动态换肤,要怎么实现呢</p>
<p>首先新建一个vue组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-tooltip effect&#x3D;&quot;dark&quot; content&#x3D;&quot;theme&quot; placement&#x3D;&quot;bottom&quot;&gt;</span><br><span class="line">    &lt;el-color-picker</span><br><span class="line">    v-model&#x3D;&quot;theme&quot;</span><br><span class="line">    class&#x3D;&quot;theme-picker&quot;</span><br><span class="line">    size&#x3D;&quot;small&quot;</span><br><span class="line">    popper-class&#x3D;&quot;theme-picker-dropdown&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;el-tooltip&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">const version &#x3D; require(&#39;element-ui&#x2F;package.json&#39;).version &#x2F;&#x2F; element-ui version from node_modules</span><br><span class="line">const ORIGINAL_THEME &#x3D; &#39;#409EFF&#39; &#x2F;&#x2F; default color</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      chalk: &#39;&#39;, &#x2F;&#x2F; content of theme-chalk css</span><br><span class="line">      theme: ORIGINAL_THEME</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    theme(val, oldVal) &#123;</span><br><span class="line">      if (typeof val !&#x3D;&#x3D; &#39;string&#39;) return</span><br><span class="line">      const themeCluster &#x3D; this.getThemeCluster(val.replace(&#39;#&#39;, &#39;&#39;))</span><br><span class="line">      const originalCluster &#x3D; this.getThemeCluster(oldVal.replace(&#39;#&#39;, &#39;&#39;))</span><br><span class="line">      const getHandler &#x3D; (variable, id) &#x3D;&gt; &#123;</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">          const originalCluster &#x3D; this.getThemeCluster(ORIGINAL_THEME.replace(&#39;#&#39;, &#39;&#39;))</span><br><span class="line">          const newStyle &#x3D; this.updateStyle(this[variable], originalCluster, themeCluster)</span><br><span class="line"></span><br><span class="line">          let styleTag &#x3D; document.getElementById(id)</span><br><span class="line">          if (!styleTag) &#123;</span><br><span class="line">            styleTag &#x3D; document.createElement(&#39;style&#39;)</span><br><span class="line">            styleTag.setAttribute(&#39;id&#39;, id)</span><br><span class="line">            document.head.appendChild(styleTag)</span><br><span class="line">          &#125;</span><br><span class="line">          styleTag.innerText &#x3D; newStyle</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const chalkHandler &#x3D; getHandler(&#39;chalk&#39;, &#39;chalk-style&#39;)</span><br><span class="line"></span><br><span class="line">      if (!this.chalk) &#123;</span><br><span class="line">        const url &#x3D; &#96;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui@$&#123;version&#125;&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#96;</span><br><span class="line">        this.getCSSString(url, chalkHandler, &#39;chalk&#39;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        chalkHandler()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const styles &#x3D; [].slice.call(document.querySelectorAll(&#39;style&#39;))</span><br><span class="line">        .filter(style &#x3D;&gt; &#123;</span><br><span class="line">          const text &#x3D; style.innerText</span><br><span class="line">          return new RegExp(oldVal, &#39;i&#39;).test(text) &amp;&amp; !&#x2F;Chalk Variables&#x2F;.test(text)</span><br><span class="line">        &#125;)</span><br><span class="line">      styles.forEach(style &#x3D;&gt; &#123;</span><br><span class="line">        const &#123; innerText &#125; &#x3D; style</span><br><span class="line">        if (typeof innerText !&#x3D;&#x3D; &#39;string&#39;) return</span><br><span class="line">        style.innerText &#x3D; this.updateStyle(innerText, originalCluster, themeCluster)</span><br><span class="line">      &#125;)</span><br><span class="line">      this.$message(&#123;</span><br><span class="line">        message: &#39;换肤成功&#39;,</span><br><span class="line">        type: &#39;success&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateStyle(style, oldCluster, newCluster) &#123;</span><br><span class="line">      let newStyle &#x3D; style</span><br><span class="line">      oldCluster.forEach((color, index) &#x3D;&gt; &#123;</span><br><span class="line">        newStyle &#x3D; newStyle.replace(new RegExp(color, &#39;ig&#39;), newCluster[index])</span><br><span class="line">      &#125;)</span><br><span class="line">      return newStyle</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getCSSString(url, callback, variable) &#123;</span><br><span class="line">      const xhr &#x3D; new XMLHttpRequest()</span><br><span class="line">      xhr.onreadystatechange &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if (xhr.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          this[variable] &#x3D; xhr.responseText.replace(&#x2F;@font-face&#123;[^&#125;]+&#125;&#x2F;, &#39;&#39;)</span><br><span class="line">          callback()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      xhr.open(&#39;GET&#39;, url)</span><br><span class="line">      xhr.send()</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getThemeCluster(theme) &#123;</span><br><span class="line">      const tintColor &#x3D; (color, tint) &#x3D;&gt; &#123;</span><br><span class="line">        let red &#x3D; parseInt(color.slice(0, 2), 16)</span><br><span class="line">        let green &#x3D; parseInt(color.slice(2, 4), 16)</span><br><span class="line">        let blue &#x3D; parseInt(color.slice(4, 6), 16)</span><br><span class="line"></span><br><span class="line">        if (tint &#x3D;&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; when primary color is in its rgb space</span><br><span class="line">          return [red, green, blue].join(&#39;,&#39;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          red +&#x3D; Math.round(tint * (255 - red))</span><br><span class="line">          green +&#x3D; Math.round(tint * (255 - green))</span><br><span class="line">          blue +&#x3D; Math.round(tint * (255 - blue))</span><br><span class="line"></span><br><span class="line">          red &#x3D; red.toString(16)</span><br><span class="line">          green &#x3D; green.toString(16)</span><br><span class="line">          blue &#x3D; blue.toString(16)</span><br><span class="line"></span><br><span class="line">          return &#96;#$&#123;red&#125;$&#123;green&#125;$&#123;blue&#125;&#96;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const shadeColor &#x3D; (color, shade) &#x3D;&gt; &#123;</span><br><span class="line">        let red &#x3D; parseInt(color.slice(0, 2), 16)</span><br><span class="line">        let green &#x3D; parseInt(color.slice(2, 4), 16)</span><br><span class="line">        let blue &#x3D; parseInt(color.slice(4, 6), 16)</span><br><span class="line"></span><br><span class="line">        red &#x3D; Math.round((1 - shade) * red)</span><br><span class="line">        green &#x3D; Math.round((1 - shade) * green)</span><br><span class="line">        blue &#x3D; Math.round((1 - shade) * blue)</span><br><span class="line"></span><br><span class="line">        red &#x3D; red.toString(16)</span><br><span class="line">        green &#x3D; green.toString(16)</span><br><span class="line">        blue &#x3D; blue.toString(16)</span><br><span class="line"></span><br><span class="line">        return &#96;#$&#123;red&#125;$&#123;green&#125;$&#123;blue&#125;&#96;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const clusters &#x3D; [theme]</span><br><span class="line">      for (let i &#x3D; 0; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">        clusters.push(tintColor(theme, Number((i &#x2F; 10).toFixed(2))))</span><br><span class="line">      &#125;</span><br><span class="line">      clusters.push(shadeColor(theme, 0.1))</span><br><span class="line">      return clusters</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>然后引入它就可以直接使用了</p>
<p>感觉各位大佬的无私分享</p>
]]></content>
      <categories>
        <category>element</category>
      </categories>
      <tags>
        <tag>element</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的执行顺序</title>
    <url>/2020/07/04/133-JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>如何理解JavaScript的事件循环?什么是宏任务和微任务?怎么理解消息队列的执行顺序?</p>
</blockquote>
<a id="more"></a>

<p>由于我们是一个前端的开发者,所以大多数接触到的是浏览器或者Node,我们该如何去使用JavaScript 引擎。</p>
<p>当拿到一段 JavaScript 代码时,浏览器或者 Node 环境首先要做的就是,传递给 JavaScript 引擎,并且要求它去执行。</p>
<p>我们都知道JavaScript是单线程,但是执行 JavaScript 并非一步到位,宿主环境当遇到一些事件时,会继续把一段代码传递给 JavaScript 引擎去执行,此外,我们可能还会提供 API 给 JavaScript 引擎,比如 setTimeout 这样的 API,它会允许 JavaScript 在特定的时机执行。</p>
<div class="note info">
            <p>所以,我们首先应该形成一个感性的认知：一个 JavaScript 引擎会常驻于内存中,它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。</p>
          </div>


<p>在 ES3 和更早的版本中,JavaScript 本身还没有异步执行代码的能力,这也就意味着,宿主环境传递给 JavaScript 引擎一段代码,引擎就把代码直接顺次执行了,这个任务也就是宿主发起的任务。</p>
<p>但是,在 ES5 之后,JavaScript 引入了 Promise,这样,不需要浏览器的安排,JavaScript 引擎本身也可以发起任务了。</p>
<p>我们采纳 JSC 引擎的术语,把宿主发起的任务称为宏观任务,把 JavaScript 引擎发起的任务称为微观任务。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JavaScript 引擎等待宿主环境分配宏观任务,在操作系统中,通常等待的行为都是一个事件循环,所以在 Node 术语中,也会把这个部分称为事件循环(event loop)。</p>
<p>JavaScript是单线程异步处理,其实也都是通过事件循环来实现的异步或模拟’多线程’。</p>
<ul>
<li><p>同步和异步任务在不同的执行”场所”,同步的进入主线程,异步的进入Event Table执行并注册函数。</p>
</li>
<li><p>当指定的异步事情完成时,Event Table会将这个函数移入Event Queue。</p>
</li>
<li><p>主线程内的任务执行完毕为空,会去Event Queue读取对应的函数,推入主线程执行。</p>
</li>
<li><p>js引擎的monitoring process进程会持续不断的检查主线程执行栈是否为空,一旦为空,就会去Event Queue那里检查是否有等待被调用的函数。上述过程会不断重复,也就是常说的Event Loop(事件循环)。</p>
</li>
</ul>
<p>用个例子说明上述过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let data &#x3D; [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url:www.javascript.com,</span><br><span class="line">  data:data,</span><br><span class="line">  success:() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;发送成功!&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;代码执行结束&#39;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ajax（异步任务）进入Event Table,注册回调函数success。</p>
</li>
<li><p>执行console.log(‘代码执行结束’)。（同步任务在主线程执行）</p>
</li>
<li><p>ajax事件完成,回调函数success进入Event Queue。</p>
</li>
<li><p>主线程从Event Queue读取回调函数success并执行。</p>
</li>
</ul>
<p>我们可以大概理解：宏观任务的队列就相当于事件循环。总结起来就是下面这样</p>
<p>主任务(宏任务)完 ——&gt; 所有微任务 ——&gt; 宏任务（找到宏任务其中一个任务队列执行,其中如果又有微任务,该任务队列执行完就执行微任务）——&gt; 宏任务中另外一个任务队列（里面有微任务就再执行微任务）。</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/133-Js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="图片"></p>
<h3 id="宏观任务-MacroTask-和微观任务-MicroTask"><a href="#宏观任务-MacroTask-和微观任务-MicroTask" class="headerlink" title="宏观任务(MacroTask)和微观任务(MicroTask)"></a>宏观任务(MacroTask)和微观任务(MicroTask)</h3><p>之前我们说过了,宿主发起的任务称为宏观任务,把 JavaScript 引擎发起的任务称为微观任务</p>
<p>除了广义的同步任务和异步任务,我们对任务有更精细的定义:</p>
<p>macro-task(宏任务): 包括整体代码script,setTimeout,setInterval</p>
<p>micro-task(微任务): Promise,process.nextTick</p>
<p>那宏观任务和微观任务有什么关系呢?</p>
<p>在宏观任务中,JavaScript 的 Promise 还会产生异步代码,JavaScript 必须保证这些异步代码在一个宏观任务中完成,因此,每个宏观任务中又包含了一个微观任务队列</p>
<p>有了宏观任务和微观任务机制,我们就可以实现 JavaScript 引擎级和宿主级的任务了,例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API,则会添加宏观任务。</p>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise我们已经讲过很多次了,这里就不再重复说了,再看一次我之前再其他博客写过的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function()&#123; </span><br><span class="line">  console.log(4)</span><br><span class="line">&#125;, 0);</span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  for( var i &#x3D; 0 ; i &lt; 10000 ; i++ )&#123;</span><br><span class="line">    i &#x3D;&#x3D; 9999 &amp;&amp; resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">  console.log(5)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(3);</span><br></pre></td></tr></table></figure>

<p>打印的结果是 ‘1, 2, 3, 5, 4’, 具体详情可以参考这篇博客 <a href="https://www.chensheng.group/2019/10/10/106-JS高频考题分享/">陈先生的小前端-JS高频考题分享</a></p>
<p>我们发现,不论代码顺序如何,4 必定发生在 5 之后,因为 Promise 产生的是 JavaScript 引擎内部的微任务,而 setTimeout 是浏览器 API,它产生宏任务。</p>
<p>为了理解微任务始终先于宏任务,我们设计一个实验：执行一个耗时 1 秒的 Promise。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&quot;6&quot;)</span><br><span class="line">&#125;, 0) </span><br><span class="line">var r &#x3D; new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;1&#39;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;); </span><br><span class="line">r.then(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;3&#39;)</span><br><span class="line">  var begin &#x3D; Date.now(); </span><br><span class="line">  while(Date.now() - begin &lt; 1000);</span><br><span class="line">  console.log(&quot;4&quot;) </span><br><span class="line">  new Promise((resolve, reject)&#x3D;&gt;&#123; </span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(() &#x3D;&gt; console.log(&quot;5&quot;))</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#39;2&#39;)</span><br></pre></td></tr></table></figure>

<p>这里我们强制了 1 秒的执行耗时,这样,我们可以确保任务 5 是在 6 之后被添加到任务队列。<br>我们可以看到,即使耗时一秒的 4 执行完毕,再 enque 的 5,仍然先于 6 执行了,这很好地解释了微任务优先的原理。</p>
<p>通过一系列的实验,我们可以总结一下如何分析异步执行的顺序：</p>
<ul>
<li>首先我们分析有多少个宏任务；</li>
<li>在每个宏任务中,分析有多少个微任务；</li>
<li>根据调用次序,确定宏任务中的微任务执行次序；</li>
<li>根据宏任务的触发规则和调用次序,确定宏任务的执行次序；</li>
<li>确定整个顺序。</li>
</ul>
<p>Promise 是 JavaScript 中的一个定义,但是实际编写代码时,我们可以发现,它似乎并不比回调的方式书写更简单,但是从 ES6 开始,我们有了 async/await,这个语法改进跟 Promise 配合,能够有效地改善代码结构。</p>
<p>之前一直没有说async/await, 今天刚好一起介绍一下</p>
<h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>其实async/await 就是 promise的一个语法糖,让我们的代码看起来像是同步,更加的美观,先来看一下基本用法</p>
<p>async 函数必定返回 Promise,我们把所有返回 Promise 的函数都可以认为是异步函数。</p>
<p>async 函数是一种特殊语法,特征是在 function 关键字之前加上 async 关键字,这样,就定义了一个 async 函数,我们可以在其中使用 await 来等待一个 Promise。</p>
<p>另外还有一个很有意思的语法规定,await 只能出现在 async 函数中。</p>
<p>我们先看看async 起什么作用,而他又是怎么处理他的返回值的</p>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  testAsync() &#123;</span><br><span class="line">    return &quot;hello async&quot;;</span><br><span class="line">  &#125;,</span><br><span class="line">  async testAsync2() &#123;</span><br><span class="line">    return &quot;hello async&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别输出这两个函数,你会发现很有趣的地方</p>
<p>async 函数返回的是一个 Promise 对象,如果在函数中 return 一个直接量,async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。</p>
<p>假设我们没有return东西,那它就会返回一个Promise.resolve(undefined)。</p>
<blockquote>
<p>补充知识点: Promise.resolve(x) 可以看作是 new Promise(resolve =&gt; resolve(x)) 的简写,可以用于快速封装字面量对象或其他对象,将其封装成 Promise 实例。</p>
</blockquote>
<p>现在来看看await,他等的是什么?</p>
<p>一般来说,都认为 await 是在等待一个 async 函数完成。其实也可以用来等待普通函数,所以实际上 await 等是一个返回值 </p>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  async getData()&#123;</span><br><span class="line">    let sendMessage &#x3D; &#123;</span><br><span class="line">      url: &#39;&#x2F;v2&#x2F;music&#x2F;search?q&#x3D;周杰伦&#39;,</span><br><span class="line">      PostData: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return await this.$store.dispatch(&#39;Get&#39;, sendMessage) &#x2F;&#x2F; 这个是封装的方法,返回的是一个promise</span><br><span class="line">  &#125;,</span><br><span class="line">  test()&#123;</span><br><span class="line">    return &#39;music&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  async lookData()&#123;</span><br><span class="line">    let m1 &#x3D; await this.getData()</span><br><span class="line">    let m2 &#x3D; await this.test()</span><br><span class="line">    console.log(m1, m2)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;,</span><br><span class="line">created() &#123;</span><br><span class="line">  this.lookData() &#x2F;&#x2F; m1和m2都可以输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单一的 Promise 链并不能发现 async/await 的优势,但是,如果需要处理由多个 Promise 组成的 then 链的时候,优势就能体现出来了</p>
<p>我们之前是用Promise 通过 then 链来解决多层回调地狱的问题</p>
<p>现在又可以使用 async/await 来进一步优化它,看起来更像一个同步了。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>为了更好的理解 事件循环,宏观任务,微观任务,以及任务队列,直接上代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;1&#39;); &#x2F;&#x2F;第一轮主线程【1】</span><br><span class="line"> </span><br><span class="line">setTimeout(function() &#123; &#x2F;&#x2F;碰到set异步，丢入宏任务队列【set1】：我将它命名为set1</span><br><span class="line">     console.log(&#39;2&#39;);&#x2F;&#x2F;第二轮宏任务执行，输出【2】</span><br><span class="line">     process.nextTick(function() &#123;&#x2F;&#x2F;第二轮宏任务执行，碰到process，丢入微任务队列，【3】</span><br><span class="line">         console.log(&#39;3&#39;);</span><br><span class="line">     &#125;)</span><br><span class="line">     new Promise(function(resolve) &#123;&#x2F;&#x2F;第二轮宏任务执行，输出【2，4】</span><br><span class="line">         console.log(&#39;4&#39;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#39;5&#39;)&#x2F;&#x2F;第二轮宏任务执行，碰到then丢入微任务队列，【3，5】</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123; &#x2F;&#x2F;碰到process，丢入微任务队列【6】</span><br><span class="line">    console.log(&#39;6&#39;); &#x2F;&#x2F;第一轮微任务执行</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123; </span><br><span class="line">    console.log(&#39;7&#39;); &#x2F;&#x2F;new的同时执行代码，第一轮主线程此时输出【1，7】</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#39;8&#39;) &#x2F;&#x2F;第一轮主线程中promise的then丢入微任务队列，此时微任务队列为【6，8】。当第一轮微任务执行，顺序输出【6，8】</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123; &#x2F;&#x2F;碰到set异步丢入宏任务队列，此时宏任务队列【set1.set2】：我将它命名为set2</span><br><span class="line">    console.log(&#39;9&#39;);&#x2F;&#x2F;第三轮宏任务执行，输出【9】</span><br><span class="line">    process.nextTick(function() &#123; &#x2F;&#x2F;第三轮宏中执行过程中添加到微任务【10】</span><br><span class="line">        console.log(&#39;10&#39;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#39;11&#39;);&#x2F;&#x2F;第三轮宏任务执行，宏任务累计输出【9,11】</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#39;12&#39;) &#x2F;&#x2F;第三轮宏中执行过程中添加到微任务【10，12】</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>解答: </p>
<p>第一轮：主线程输出：【1，7】，添加宏任务【set1，set2】，添加微任务【6，8】。执行完主线程，然后执行微任务输出【6，8】</p>
<p>第二轮：执行宏任务其中一个任务队列set1:输出【2，4】，执行任务的过程，碰到有微任务，所以在微任务队列添加输出【3，5】的微任务，在set1宏任务执行完就执行该微任务，第二轮总输出：【2，4，3，5】</p>
<p>第三轮：执行任务另一个任务队列set2：输出【9，11】，执行任务的过程，碰到有微任任务，所以在微任务队列添加输出【10，12】的微任务，在set2宏任务执行完就执行该微任务，第三轮总输出：【9，11，10，12】</p>
<p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p>
<p>以上就是我对JavaScript执行的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>富文本编辑器</title>
    <url>/2020/07/17/134-%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>推荐一个好用的富文本编辑器,之前也有用过其他版本的,但是都太简易了</p>
</blockquote>
<a id="more"></a>

<p>安装 vue-editor-wrap</p>
<p>npm install vue-editor-wrap</p>
<p>下载大神已经处理后的UEditor,下载 地址链接: <a href="https://pan.baidu.com/s/1ds-HyhXD5EFYCcp7uen2XA" target="_blank" rel="noopener">https://pan.baidu.com/s/1ds-HyhXD5EFYCcp7uen2XA</a> 提取码: s7ry</p>
<p>解压, 重命名文件夹为UEditor, 放入public文件夹下(如果是旧项目对应static文件夹)</p>
<p>在 main.js中引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import VueUeditorWrap from &#39;vue-ueditor-wrap&#39;</span><br><span class="line">Vue.component(&#39;vue-ueditor-wrap&#39;, VueUeditorWrap)</span><br></pre></td></tr></table></figure>

<p>然后再.vue文件中就可以使用啦</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;ueditor-page&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;ueditor-box&quot;&gt;</span><br><span class="line">      &lt;vue-ueditor-wrap v-model&#x3D;&quot;msg&quot; :config&#x3D;&quot;myConfig&quot; @before-init&#x3D;&quot;addCustomButtom&quot;&gt;&lt;&#x2F;vue-ueditor-wrap&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;Preview&quot; v-html&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        msg: &#39;&#39;,</span><br><span class="line">        myConfig: &#123;</span><br><span class="line">          &#x2F;&#x2F; 编辑器不自动被内容撑高</span><br><span class="line">          autoHeightEnabled: false,</span><br><span class="line">          &#x2F;&#x2F; 底部元素路径</span><br><span class="line">          elementPathEnabled : false,</span><br><span class="line">          &#x2F;&#x2F;是否开启字数统计</span><br><span class="line">          wordCount: true,</span><br><span class="line">          &#x2F;&#x2F; 初始容器高度</span><br><span class="line">          initialFrameHeight: &#39;100%&#39;,</span><br><span class="line">          &#x2F;&#x2F; 初始容器宽度</span><br><span class="line">          initialFrameWidth: &#39;100%&#39;,</span><br><span class="line">          &#x2F;&#x2F; 上传文件接口</span><br><span class="line">          serverUrl: &#39;http:&#x2F;&#x2F;10.100.2.127:8080&#x2F;webapi.php&#39;,</span><br><span class="line">          toolbars: [</span><br><span class="line">            [</span><br><span class="line">              &#39;anchor&#39;, &#x2F;&#x2F;锚点</span><br><span class="line">              &#39;undo&#39;, &#x2F;&#x2F;撤销</span><br><span class="line">              &#39;redo&#39;, &#x2F;&#x2F;重做</span><br><span class="line">              &#39;bold&#39;, &#x2F;&#x2F;加粗</span><br><span class="line">              &#39;indent&#39;, &#x2F;&#x2F;首行缩进</span><br><span class="line">              &#x2F;&#x2F; &#39;snapscreen&#39;, &#x2F;&#x2F;截图</span><br><span class="line">              &#39;italic&#39;, &#x2F;&#x2F;斜体</span><br><span class="line">              &#39;underline&#39;, &#x2F;&#x2F;下划线</span><br><span class="line">              &#39;strikethrough&#39;, &#x2F;&#x2F;删除线</span><br><span class="line">              &#39;subscript&#39;, &#x2F;&#x2F;下标</span><br><span class="line">              &#39;fontborder&#39;, &#x2F;&#x2F;字符边框</span><br><span class="line">              &#39;superscript&#39;, &#x2F;&#x2F;上标</span><br><span class="line">              &#39;formatmatch&#39;, &#x2F;&#x2F;格式刷</span><br><span class="line">              &#x2F;&#x2F; &#39;source&#39;, &#x2F;&#x2F;源代码</span><br><span class="line">              &#39;blockquote&#39;, &#x2F;&#x2F;引用</span><br><span class="line">              &#39;pasteplain&#39;, &#x2F;&#x2F;纯文本粘贴模式</span><br><span class="line">              &#39;selectall&#39;, &#x2F;&#x2F;全选</span><br><span class="line">              &#39;print&#39;, &#x2F;&#x2F;打印</span><br><span class="line">              &#x2F;&#x2F; &#39;preview&#39;, &#x2F;&#x2F;预览</span><br><span class="line">              &#39;horizontal&#39;, &#x2F;&#x2F;分隔线</span><br><span class="line">              &#39;removeformat&#39;, &#x2F;&#x2F;清除格式</span><br><span class="line">              &#39;time&#39;, &#x2F;&#x2F;时间</span><br><span class="line">              &#39;date&#39;, &#x2F;&#x2F;日期</span><br><span class="line">              &#39;unlink&#39;, &#x2F;&#x2F;取消链接</span><br><span class="line">              &#39;insertrow&#39;, &#x2F;&#x2F;前插入行</span><br><span class="line">              &#39;insertcol&#39;, &#x2F;&#x2F;前插入列</span><br><span class="line">              &#39;mergeright&#39;, &#x2F;&#x2F;右合并单元格</span><br><span class="line">              &#39;mergedown&#39;, &#x2F;&#x2F;下合并单元格</span><br><span class="line">              &#39;deleterow&#39;, &#x2F;&#x2F;删除行</span><br><span class="line">              &#39;deletecol&#39;, &#x2F;&#x2F;删除列</span><br><span class="line">              &#39;splittorows&#39;, &#x2F;&#x2F;拆分成行</span><br><span class="line">              &#39;splittocols&#39;, &#x2F;&#x2F;拆分成列</span><br><span class="line">              &#39;splittocells&#39;, &#x2F;&#x2F;完全拆分单元格</span><br><span class="line">              &#39;deletecaption&#39;, &#x2F;&#x2F;删除表格标题</span><br><span class="line">              &#39;inserttitle&#39;, &#x2F;&#x2F;插入标题</span><br><span class="line">              &#39;mergecells&#39;, &#x2F;&#x2F;合并多个单元格</span><br><span class="line">              &#39;deletetable&#39;, &#x2F;&#x2F;删除表格</span><br><span class="line">              &#39;cleardoc&#39;, &#x2F;&#x2F;清空文档</span><br><span class="line">              &#39;insertparagraphbeforetable&#39;, &#x2F;&#x2F;&quot;表格前插入行&quot;</span><br><span class="line">              &#x2F;&#x2F; &#39;insertcode&#39;, &#x2F;&#x2F;代码语言</span><br><span class="line">              &#39;fontfamily&#39;, &#x2F;&#x2F;字体</span><br><span class="line">              &#39;fontsize&#39;, &#x2F;&#x2F;字号</span><br><span class="line">              &#39;paragraph&#39;, &#x2F;&#x2F;段落格式</span><br><span class="line">              &#x2F;&#x2F; &#39;simpleupload&#39;, &#x2F;&#x2F;单图上传</span><br><span class="line">              &#x2F;&#x2F; &#39;insertimage&#39;, &#x2F;&#x2F;多图上传</span><br><span class="line">              &#x2F;&#x2F; &#39;edittable&#39;, &#x2F;&#x2F;表格属性</span><br><span class="line">              &#x2F;&#x2F; &#39;edittd&#39;, &#x2F;&#x2F;单元格属性</span><br><span class="line">              &#39;link&#39;, &#x2F;&#x2F;超链接</span><br><span class="line">              &#39;emotion&#39;, &#x2F;&#x2F;表情</span><br><span class="line">              &#39;spechars&#39;, &#x2F;&#x2F;特殊字符</span><br><span class="line">              &#39;searchreplace&#39;, &#x2F;&#x2F;查询替换</span><br><span class="line">              &#39;map&#39;, &#x2F;&#x2F;Baidu地图</span><br><span class="line">              &#x2F;&#x2F; &#39;gmap&#39;, &#x2F;&#x2F;Google地图</span><br><span class="line">              &#39;insertvideo&#39;, &#x2F;&#x2F;视频</span><br><span class="line">              &#39;help&#39;, &#x2F;&#x2F;帮助</span><br><span class="line">              &#39;justifyleft&#39;, &#x2F;&#x2F;居左对齐</span><br><span class="line">              &#39;justifyright&#39;, &#x2F;&#x2F;居右对齐</span><br><span class="line">              &#39;justifycenter&#39;, &#x2F;&#x2F;居中对齐</span><br><span class="line">              &#39;justifyjustify&#39;, &#x2F;&#x2F;两端对齐</span><br><span class="line">              &#39;forecolor&#39;, &#x2F;&#x2F;字体颜色</span><br><span class="line">              &#39;backcolor&#39;, &#x2F;&#x2F;背景色</span><br><span class="line">              &#39;insertorderedlist&#39;, &#x2F;&#x2F;有序列表</span><br><span class="line">              &#39;insertunorderedlist&#39;, &#x2F;&#x2F;无序列表</span><br><span class="line">              &#39;fullscreen&#39;, &#x2F;&#x2F;全屏</span><br><span class="line">              &#39;directionalityltr&#39;, &#x2F;&#x2F;从左向右输入</span><br><span class="line">              &#39;directionalityrtl&#39;, &#x2F;&#x2F;从右向左输入</span><br><span class="line">              &#39;rowspacingtop&#39;, &#x2F;&#x2F;段前距</span><br><span class="line">              &#39;rowspacingbottom&#39;, &#x2F;&#x2F;段后距</span><br><span class="line">              &#x2F;&#x2F; &#39;pagebreak&#39;, &#x2F;&#x2F;分页</span><br><span class="line">              &#39;insertframe&#39;, &#x2F;&#x2F;插入Iframe</span><br><span class="line">              &#39;imagenone&#39;, &#x2F;&#x2F;默认</span><br><span class="line">              &#39;imageleft&#39;, &#x2F;&#x2F;左浮动</span><br><span class="line">              &#39;imageright&#39;, &#x2F;&#x2F;右浮动</span><br><span class="line">              &#x2F;&#x2F; &#39;attachment&#39;, &#x2F;&#x2F;附件</span><br><span class="line">              &#39;imagecenter&#39;, &#x2F;&#x2F;居中</span><br><span class="line">              &#39;wordimage&#39;, &#x2F;&#x2F;图片转存</span><br><span class="line">              &#39;lineheight&#39;, &#x2F;&#x2F;行间距</span><br><span class="line">              &#39;edittip &#39;, &#x2F;&#x2F;编辑提示</span><br><span class="line">              &#x2F;&#x2F; &#39;customstyle&#39;, &#x2F;&#x2F;自定义标题</span><br><span class="line">              &#39;autotypeset&#39;, &#x2F;&#x2F;自动排版</span><br><span class="line">              &#x2F;&#x2F; &#39;webapp&#39;, &#x2F;&#x2F;百度应用</span><br><span class="line">              &#39;touppercase&#39;, &#x2F;&#x2F;字母大写</span><br><span class="line">              &#39;tolowercase&#39;, &#x2F;&#x2F;字母小写</span><br><span class="line">              &#x2F;&#x2F; &#39;background&#39;, &#x2F;&#x2F;背景</span><br><span class="line">              &#x2F;&#x2F; &#39;template&#39;, &#x2F;&#x2F;模板</span><br><span class="line">              &#x2F;&#x2F; &#39;scrawl&#39;, &#x2F;&#x2F;涂鸦</span><br><span class="line">              &#x2F;&#x2F; &#39;music&#39;, &#x2F;&#x2F;音乐</span><br><span class="line">              &#39;inserttable&#39;, &#x2F;&#x2F;插入表格</span><br><span class="line">              &#x2F;&#x2F; &#39;drafts&#39;, &#x2F;&#x2F; 从草稿箱加载</span><br><span class="line">              &#x2F;&#x2F; &#39;charts&#39;, &#x2F;&#x2F; 图表</span><br><span class="line">            ]</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      addCustomButtom (editorId) &#123;</span><br><span class="line">        let _this &#x3D; this</span><br><span class="line">        let img &#x3D; &#39;&#39;</span><br><span class="line">        window.UE.registerUI(&#39;test-button&#39;, function (editor, uiName) &#123;</span><br><span class="line">          &#x2F;&#x2F; 注册按钮执行时的 command 命令，使用命令默认就会带有回退操作</span><br><span class="line">          editor.registerCommand(uiName, &#123;</span><br><span class="line">            execCommand: function () &#123;</span><br><span class="line">              editor.execCommand(&#39;inserthtml&#39;, &#96;&lt;img src&#x3D;&quot;$&#123;img&#125;&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;&#96;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      </span><br><span class="line">          &#x2F;&#x2F; 创建一个 button</span><br><span class="line">          var btn &#x3D; new window.UE.ui.Button(&#123;</span><br><span class="line">            &#x2F;&#x2F; 按钮的名字</span><br><span class="line">            name: uiName,</span><br><span class="line">            &#x2F;&#x2F; 提示</span><br><span class="line">            title: &#39;单图上传&#39;,</span><br><span class="line">            &#x2F;&#x2F; 需要添加的额外样式，可指定 icon 图标，图标路径参考常见问题 2</span><br><span class="line">            cssRules: &quot;background-image: url(&#39;&#x2F;static&#x2F;icons.png&#39;)!important;background-position: -380px 0px;&quot;,</span><br><span class="line">            &#x2F;&#x2F; 点击时执行的命令</span><br><span class="line">            onclick: function () &#123;</span><br><span class="line">              &#x2F;&#x2F; 这里可以不用执行命令，做你自己的操作也可</span><br><span class="line">              &#x2F;&#x2F; editor.execCommand(uiName)</span><br><span class="line">              var input &#x3D; document.createElement(&#39;input&#39;)</span><br><span class="line">              input.type &#x3D; &quot;file&quot;</span><br><span class="line">              input.style.display &#x3D; &#39;none&#39;</span><br><span class="line">              document.body.appendChild(input)</span><br><span class="line">              input.click()</span><br><span class="line">              input.addEventListener(&#39;change&#39;,(e)&#x3D;&gt;&#123;</span><br><span class="line">                &#x2F;&#x2F; 利用 axios 上传，上传成功之后销毁 DOM</span><br><span class="line">                console.log(e.target.files)</span><br><span class="line">                let sendMsg &#x3D; &#123;</span><br><span class="line">                  action: &#39;material.MaterialSalesman.getImgUrl&#39;,</span><br><span class="line">                  files: e.target.files</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; return;</span><br><span class="line">                _this.$store.dispatch(&#39;Post&#39;, sendMsg).then((res) &#x3D;&gt; &#123;</span><br><span class="line">                  img &#x3D; res.data[0].data</span><br><span class="line">                  editor.execCommand(uiName)</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;) </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      </span><br><span class="line">          &#x2F;&#x2F; 当点到编辑内容上时，按钮要做的状态反射</span><br><span class="line">          editor.addListener(&#39;selectionchange&#39;, function () &#123;</span><br><span class="line">            var state &#x3D; editor.queryCommandState(uiName)</span><br><span class="line">            if (state &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">              btn.setDisabled(true)</span><br><span class="line">              btn.setChecked(false)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              btn.setDisabled(false)</span><br><span class="line">              btn.setChecked(state)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      </span><br><span class="line">          &#x2F;&#x2F; 因为你是添加 button，所以需要返回这个 button</span><br><span class="line">          return btn</span><br><span class="line">        &#125;, 0 &#x2F;* 指定添加到工具栏上的哪个位置，默认时追加到最后 *&#x2F;, editorId &#x2F;* 指定这个 UI 是哪个编辑器实例上的，默认是页面上所有的编辑器都会添加这个按钮 *&#x2F;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style lang&#x3D;&quot;css&quot;&gt;</span><br><span class="line">  .ueditor-page &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    display: flex;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">  &#125;</span><br><span class="line">  .ueditor-box &#123;</span><br><span class="line">    width: 50%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">  &#125;</span><br><span class="line">  .Preview &#123;</span><br><span class="line">    width: 50%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    margin-left: 20px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    overflow: auto;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>我这边还使用到了自定义按钮的功能,原理注释都在代码里面啦</p>
<p>以上就是我对富文本插件的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo添加看板娘</title>
    <url>/2020/07/27/135-hexo%E7%9C%8B%E6%9D%BF%E5%A8%98/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>何如给我们的博客添加一个会说话的看板娘呢</p>
</blockquote>
<a id="more"></a>

<h3 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h3><p>先安装插件</p>
<p>npm install –save hexo-helper-live2d</p>
<p><a href="https://github.com/summerscar/live2dDemo" target="_blank" rel="noopener">看板娘模型选择</a></p>
<p>选择一个看板娘的模型,继续下载 <code>npm install live2d-widget-model-z16 --save</code></p>
<p>然后在根目录下的_config.yml下配置live2d</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw&#x2F;</span><br><span class="line">  pluginJsPath: lib&#x2F;</span><br><span class="line">  pluginModelPath: assets&#x2F;</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-z16</span><br><span class="line">    # live2d-widget-model-wanko</span><br><span class="line">    # live2d-widget-model-z16</span><br><span class="line">  display:</span><br><span class="line">    position: left</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></table></figure>

<p>重新运行一下就好啦</p>
<h3 id="豪华版"><a href="#豪华版" class="headerlink" title="豪华版"></a>豪华版</h3><p>把之前的live2d卸载掉 <code>npm uninstall hexo-helper-live2d</code></p>
<p>下载大神的配置<a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">戳我戳我</a></p>
<p>下载好之后,在主目录\themes\next\source目录下新建目录live2d-widget</p>
<p>然后修改autoload.js文件，将路径改为绝对路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意：live2d_path 参数应使用绝对路径</span><br><span class="line">&#x2F;&#x2F;const live2d_path &#x3D; &quot;https:&#x2F;&#x2F;fastly.jsdelivr.net&#x2F;gh&#x2F;stevenjoezhang&#x2F;live2d-widget@latest&#x2F;&quot;;</span><br><span class="line">const live2d_path &#x3D; &quot;&#x2F;live2d-widget&#x2F;&quot;;</span><br></pre></td></tr></table></figure>

<p>之后就是引入链接了</p>
<p>有一些主题,路径在<code>/themes/主题名字/layout/_partial/head.ejs</code>目录下<br>我的next主题,是在<code>/themes/next/layout/_layout.swing</code>目录下</p>
<p>添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;fastly.jsdelivr.net&#x2F;npm&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;fastly.jsdelivr.net&#x2F;npm&#x2F;font-awesome&#x2F;css&#x2F;font-awesome.min.css&quot;&#x2F;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;&#x2F;live2d-widget&#x2F;autoload.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>想修改看板娘大小、位置、格式、文本内容等，可查看并修改 waifu-tips.js 、 waifu-tips.json 、waifu.css文件。</p>
<p>这样就有一个会说话,会换装的看板娘了,还可以召唤小飞机按空格键发射子弹</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用Valine评论</title>
    <url>/2020/07/29/136-hexo%E4%BD%BF%E7%94%A8Valine%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>关于这个评论系统,前前后后换了三四个,今天又换了一个,哎,评论又要被清空了</p>
</blockquote>
<a id="more"></a>

<p>最早使用的是来必力的,还不错,就是有点卡顿,还需要登录,后来不知道怎么回事,用不来了,就换了一个 </p>
<p>之后就换成了畅言,也是一个不错的评论系统,但是会给博客塞一些广告,一气之下,又换了一个</p>
<p>换成了git官方的一个插件,gitalk,可以在git仓库中看到评论,但是也是需要git登录之后才可以评论</p>
<p>于是换成了现在的Valine</p>
<p>Valine用的是LeanCloud作为数据,所以我们需要先打开LeanCloud去注册LeanCloud并创建一个开发版应用（免费）</p>
<p><a href="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener">戳我戳我,一键跳转</a></p>
<p>之后在LeanCloud -&gt; 存储 -&gt; 创建Class -&gt; 无限制的Class, class名称为：Comment</p>
<p>在LeanCloud-设置-把除数据存储其他选项都关闭。</p>
<p>然后再底下的安全域名中添加域名</p>
<p>之后在Next模板下的_config.yml搜索Valine进行填写appid和appkey</p>
<p>OK了,大功告成,就是这么简单,图我就不放出来了,相信大家都能找得到</p>
<p>感叹代码的进步,换评论系统一次比一次简单了,当初换个畅言评论,折腾了许久,又要备案,又要审核</p>
<p>哪里不懂的就在评论中提出来,我会不定时的看一看</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码学习-模板编译原理</title>
    <url>/2020/11/08/137-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>由于之前发生了一些事情,并且公司的项目也很赶,碰巧孩子出生了,所以忙的不可开交,,很久没有更新博客了,今天有时间,把欠下的博客都补上</p>
</blockquote>
<a id="more"></a>

<p>我们在学习Vue的时候,一直都说虚拟DOM,虚拟DOM,那么,什么是虚拟DOM,虚拟DOM又是怎么生成的呢?</p>
<p>虚拟DOM的生成大致上是分为这么几步的:</p>
<ol>
<li><p>template 通过正则转化为ast树</p>
</li>
<li><p>ast树通过codegen方法,转化为render函数</p>
</li>
<li><p>render函数,内部调用_c方法,( _c方法就是创建el) 转化为虚拟dom</p>
</li>
</ol>
<blockquote>
<p>用一个对象来描述一个DOM元素,这就是虚拟DOM</p>
</blockquote>
<p>知道了大致的流程,我们再去源码中看看具体的代码是怎么实现的(源码的位置在scr/compiler/index.js中)</p>
<p>首先,创建了一个编译器(createCompilerCreator),传入了一个 bsaeCompile函数,这个函数描述了模板是怎么转化成render函数的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function baseCompile(template: string, options: CompilerOptions) &#123;</span><br><span class="line">  const ast &#x3D; parse(template.trim(), options) &#x2F;&#x2F; 1.将模板转化成ast语法树  </span><br><span class="line">  if (options.optimize !&#x3D;&#x3D; false) &#123; &#x2F;&#x2F; 2.优化树    </span><br><span class="line">    optimize(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  const code &#x3D; generate(ast, options) &#x2F;&#x2F; 3.生成树  </span><br><span class="line">  return &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Vue的源码看起来有点乱,上百度找了大神整理好的,看看bsaeCompile展开后,还做了哪些操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ncname &#x3D; &#96;[a-zA-Z_][\\-\\.0-9_a-zA-Z]*&#96;;</span><br><span class="line">const qnameCapture &#x3D; &#96;((?:$&#123;ncname&#125;\\:)?$&#123;ncname&#125;)&#96;;</span><br><span class="line">const startTagOpen &#x3D; new RegExp(&#96;^&lt;$&#123;qnameCapture&#125;&#96;); &#x2F;&#x2F; 标签开头的正则 捕获的内容是 标签名 </span><br><span class="line">const endTag &#x3D; new RegExp(&#96;^&lt;\\&#x2F;$&#123;qnameCapture&#125;[^&gt;]*&gt;&#96;); &#x2F;&#x2F; 匹配标签结尾的  &lt;&#x2F;div&gt; </span><br><span class="line">const attribute &#x3D; &#x2F;^\s*([^\s&quot;&#39;&lt;&gt;\&#x2F;&#x3D;]+)(?:\s*(&#x3D;)\s*(?:&quot;([^&quot;]*)&quot;+|&#39;([^&#39;]*)&#39;+| ([^\s&quot;&#39;&#x3D;&lt;&gt;&#96;]+)))?&#x2F;; &#x2F;&#x2F; 匹配属性的 </span><br><span class="line">const startTagClose &#x3D; &#x2F;^\s*(\&#x2F;?)&gt;&#x2F;; &#x2F;&#x2F; 匹配标签结束的  &gt; </span><br><span class="line">let root;</span><br><span class="line">let currentParent;</span><br><span class="line">let stack &#x3D; []</span><br><span class="line"></span><br><span class="line">function createASTElement(tagName, attrs) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    tag: tagName,</span><br><span class="line">    type: 1,</span><br><span class="line">    children: [],</span><br><span class="line">    attrs,</span><br><span class="line">    parent: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function start(tagName, attrs) &#123;</span><br><span class="line">  let element &#x3D; createASTElement(tagName, attrs);</span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    root &#x3D; element;</span><br><span class="line">  &#125;</span><br><span class="line">  currentParent &#x3D; element;</span><br><span class="line">  stack.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function chars(text) &#123;</span><br><span class="line">  currentParent.children.push(&#123;</span><br><span class="line">    type: 3,</span><br><span class="line">    text</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function end(tagName) &#123;</span><br><span class="line">  const element &#x3D; stack[stack.length - 1];</span><br><span class="line">  stack.length--;</span><br><span class="line">  currentParent &#x3D; stack[stack.length - 1];</span><br><span class="line">  if (currentParent) &#123;</span><br><span class="line">    element.parent &#x3D; currentParent;</span><br><span class="line">    currentParent.children.push(element)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function parseHTML(html) &#123;</span><br><span class="line">  while (html) &#123;</span><br><span class="line">    let textEnd &#x3D; html.indexOf(&#39;&lt;&#39;);</span><br><span class="line">    if (textEnd &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      const startTagMatch &#x3D; parseStartTag();</span><br><span class="line">      if (startTagMatch) &#123;</span><br><span class="line">        start(startTagMatch.tagName, startTagMatch.attrs);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      const endTagMatch &#x3D; html.match(endTag);</span><br><span class="line">      if (endTagMatch) &#123;</span><br><span class="line">        advance(endTagMatch[0].length);</span><br><span class="line">        end(endTagMatch[1])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let text;</span><br><span class="line">    if (textEnd &gt;&#x3D; 0) &#123;</span><br><span class="line">      text &#x3D; html.substring(0, textEnd)</span><br><span class="line">    &#125;</span><br><span class="line">    if (text) &#123;</span><br><span class="line">      advance(text.length);</span><br><span class="line">      chars(text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function advance(n) &#123;</span><br><span class="line">    html &#x3D; html.substring(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function parseStartTag() &#123;</span><br><span class="line">    const start &#x3D; html.match(startTagOpen);</span><br><span class="line">    if (start) &#123;</span><br><span class="line">      const match &#x3D; &#123;</span><br><span class="line">        tagName: start[1],</span><br><span class="line">        attrs: []</span><br><span class="line">      &#125;</span><br><span class="line">      advance(start[0].length);</span><br><span class="line">      let attr, end</span><br><span class="line">      while (!(end &#x3D; html.match(startTagClose)) &amp;&amp; (attr &#x3D; html.match(attribute))) &#123;</span><br><span class="line">        advance(attr[0].length);</span><br><span class="line">        match.attrs.push(&#123;</span><br><span class="line">          name: attr[1],</span><br><span class="line">          value: attr[3]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      if (end) &#123;</span><br><span class="line">        advance(end[0].length);</span><br><span class="line">        return match</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 生成语法树 </span><br><span class="line">parseHTML(&#96;&lt;div id&#x3D;&quot;container&quot;&gt;&lt;p&gt;hello&lt;span&gt;zf&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&#96;);</span><br><span class="line"></span><br><span class="line">function gen(node) &#123;</span><br><span class="line">  if (node.type &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    return generate(node);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &#96;_v($&#123;JSON.stringify(node.text)&#125;)&#96;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genChildren(el) &#123;</span><br><span class="line">  const children &#x3D; el.children;</span><br><span class="line">  if (el.children) &#123;</span><br><span class="line">    return &#96;[$&#123;children.map(c&#x3D;&gt;gen(c)).join(&#39;,&#39;)&#125;]&#96;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genProps(attrs) &#123;</span><br><span class="line">  let str &#x3D; &#39;&#39;;</span><br><span class="line">  for (let i &#x3D; 0; i &lt; attrs.length; i++) &#123;</span><br><span class="line">    let attr &#x3D; attrs[i];</span><br><span class="line">    str +&#x3D; &#96;$&#123;attr.name&#125;:$&#123;attr.value&#125;,&#96;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#96;&#123;attrs:&#123;$&#123;str.slice(0,-1)&#125;&#125;&#125;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function generate(el) &#123;</span><br><span class="line">  let children &#x3D; genChildren(el);</span><br><span class="line">  let code &#x3D; &#96;_c(&#39;$&#123;el.tag&#125;&#39;$&#123;el.attrs.length?&#96;,$&#123;genProps(el.attrs)&#125;&#96;:&#39;&#39;&#125;$&#123;children? &#96;,$&#123;children&#125;&#96;:&#39;&#39;&#125;)&#96;;</span><br><span class="line">  return code;</span><br><span class="line">&#125; &#x2F;&#x2F; 根据语法树生成新的代码 </span><br><span class="line">let code &#x3D; generate(root);</span><br><span class="line">let render &#x3D; &#96;with(this)&#123;return $&#123;code&#125;&#125;&#96;;</span><br><span class="line">&#x2F;&#x2F; 包装成函数 </span><br><span class="line">let renderFn &#x3D; new Function(render);</span><br><span class="line">console.log(renderFn.toString());</span><br></pre></td></tr></table></figure>

<p>假设我们的template里面写了这个 <code>&lt;div id=&quot;container&quot;&gt;&lt;p&gt;hello&lt;span&gt;zf&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;</code></p>
<p>通过parseHTML函数,循环遍历里面的每一个字符串,判断是否为’&lt;’</p>
<blockquote>
<p>每次循环判断完之后,都会删除对应的长度</p>
</blockquote>
<p>匹配到了<code>&lt;div</code>后,生成一个对象,将’div’放入了tagName中,可能div会有属性,也生成一个attrs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 就是上面代码中的这一段 --&gt;</span><br><span class="line">const match &#x3D; &#123;</span><br><span class="line">  tagName: start[1],</span><br><span class="line">  attrs: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后会继续循环匹配,看看是否是 ‘&gt;’ 关闭标签,如果不是的话,继续循环</p>
<p>循环到了是一个 <code>id=&quot;container&quot;</code>,根据正则来判断是否是属性,放入了<code>attrs</code>中</p>
<p>再次循环匹配到是一个 ‘&gt;’ 关闭标签,返回这个对象</p>
<p>这时候字符串已经剩下这样的了 <code>&lt;p&gt;hello&lt;span&gt;zf&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;</code>, 前面的<code>&lt;div id=&quot;container&quot;&gt;</code> 都已经判断处理完了</p>
<p>再一次判断到是’&lt;’后,重复上面的操作</p>
<p>不一样的是,p标签中是一个’hello’字符串,通过正则判断后,是将这个hello传入chars中,代码中也有,就不写出来了</p>
<p>通过这样一步一步的循环遍历判断,最终会生成一个完整的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: &quot;div&quot;</span><br><span class="line">  type: 1,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    tag: &quot;p&quot;</span><br><span class="line">    type: 1,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      type: 3</span><br><span class="line">      text: &quot;hello&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      tag: &quot;span&quot;</span><br><span class="line">      type: 1,</span><br><span class="line">      children: [&#123;</span><br><span class="line">        type: 3</span><br><span class="line">        text: &quot;zf&quot;</span><br><span class="line">      &#125;],</span><br><span class="line">      attrs: [],</span><br><span class="line">      parent: &#39;&#39; &#x2F;&#x2F; 父级</span><br><span class="line">    &#125;],</span><br><span class="line">    attrs: [],</span><br><span class="line">    parent: &#39;&#39; &#x2F;&#x2F; 父级</span><br><span class="line">  &#125;],</span><br><span class="line">  attrs: [&#123;</span><br><span class="line">    name: &quot;id&quot;</span><br><span class="line">    value: &quot;container&quot;</span><br><span class="line">  &#125;],</span><br><span class="line">  parent: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以用一个对象来描述一个DOM元素</p>
<p>以上就是我对vue模板编译的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码学习-diff算法原理</title>
    <url>/2021/02/11/138-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-diff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>今天就是除夕了,也只有放假才有时间写一写博客,把欠下的博客都补上</p>
</blockquote>
<a id="more"></a>

<p>diff算法是我们在学习vue时经常听到的,像什么vue异步更新DOM,虚拟DOM的变化,都和diff算法有关,那什么是diff算法,他的作用又是什么呢</p>
<h3 id="diff算法的时间复杂度"><a href="#diff算法的时间复杂度" class="headerlink" title="diff算法的时间复杂度"></a>diff算法的时间复杂度</h3><p> 两个树的完全的 diff 算法是一个时间复杂度为 O(n3) , Vue 进行了优化·O(n3) 复杂度的问题转换成 O(n) 复杂度的问题(只比较同级不考虑跨级问题)  在前端当中， 你很少会跨越层级地移动Dom元素。 所 以 Virtual Dom只会对同一个层级的元素进行对比。</p>
<h3 id="diff算法原理"><a href="#diff算法原理" class="headerlink" title="diff算法原理"></a>diff算法原理</h3><blockquote>
<p>简单的来说,diff算法是为了比较新的DOM树和旧的DOM树,以此来算出,哪些DOM可以复用,新增哪些DOM,移除哪些DOM,优化DOM树的渲染</p>
</blockquote>
<p>自己总结的原理大概是这样的: </p>
<ol>
<li>目的: 比较 <code>新的树</code> 和 <code>旧的树</code></li>
</ol>
<blockquote>
<p>在新的树和旧的树头部插入指针, 尾部也插入指针, 进行双指针循环遍历比较</p>
</blockquote>
<ol start="2">
<li>如何进行比较: </li>
</ol>
<p>假设,旧的DOM树和新的DOM树开头相同,指针从开头比较(针对元素新增在末尾,前面相同的DOM元素可以复用)<br>如果开头不一样的话,指针从尾部开始比较(针对元素新增在开头,后面相同的DOM元素可以复用)<br>如果尾部也不一样,会比较新的头和旧的尾(针对末尾的DOM元素移动到了开头)<br>要是也不一样,比较新的尾和旧的头(针对开始的DOM元素移动到了末尾)<br>都不一样,从开头开始遍历(从头开始遍历父级节点和子级节点)</p>
<p>详细的图片在底下,可以比较图片进行理解</p>
<ol start="3">
<li>如何循环遍历: </li>
</ol>
<p>首先同级比较, 在比较子节点</p>
<blockquote>
<p>同级比较: 也就是父节点和父节点比较,子节点和子节点比较</p>
</blockquote>
<p>如果父级节点相同,再比较子节点</p>
<p>比较的时候,是这样判断的: </p>
<ul>
<li>新的有,旧的也有,使用旧的</li>
<li>新的有,旧的没有,插入新的</li>
<li>新的没有,旧的有,删除旧的</li>
<li>当比较父级的时候,判断子节点是否存在也是这样判断的,都存在的情况下,进行深入递归遍历</li>
</ul>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/138-diff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="示例图片"></p>
<p>看看图片中的最后一条</p>
<p>假设 旧的数据为 ABCD , 新的数据为 CDME</p>
<p>由于都不满足比较的四点基本判断,所以直接从开头开始遍历</p>
<ol>
<li>首先判断新的DOM树的第一个’C’,发现旧的有,移动到第一个</li>
<li>然后判断新的DOM树的第二个’D’,发现旧的有,移动到第二个</li>
<li>再判断’M’和’E’,发现都没有,直接插入</li>
<li>最后将AB直接删除</li>
</ol>
<blockquote>
<p>这就是为什么v-for要用Key,不加的话会使用上面的diff算法进行暴力比对</p>
</blockquote>
<p>知道了大致的流程,我们再去源码中看看具体的代码是怎么实现的(源码的位置在core/vdom/patch.js中)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const oldCh &#x3D; oldVnode.children &#x2F;&#x2F; 老的儿子 </span><br><span class="line">const ch &#x3D; vnode.children &#x2F;&#x2F; 新的儿子 </span><br><span class="line">if (isUndef(vnode.text)) &#123;</span><br><span class="line">  if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; &#x2F;&#x2F; 比较孩子        </span><br><span class="line">    if (oldCh !&#x3D;&#x3D; ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">  &#125; else if (isDef(ch)) &#123; &#x2F;&#x2F; 新的儿子有 老的没有        </span><br><span class="line">    if (isDef(oldVnode.text)) &#123;</span><br><span class="line">      nodeOps.setTextContent(elm, &#39;&#39;) &#x2F;&#x2F; 将老的清空   </span><br><span class="line">      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125; else if (isDef(oldCh)) &#123; &#x2F;&#x2F; 如果老的有新的没有 就删除        </span><br><span class="line">    removeVnodes(oldCh, 0, oldCh.length - 1)</span><br><span class="line">  &#125; else if (isDef(oldVnode.text)) &#123; &#x2F;&#x2F; 老的有文本 新的没文本</span><br><span class="line">    nodeOps.setTextContent(elm, &#39;&#39;) &#x2F;&#x2F; 将老的清空    </span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (oldVnode.text !&#x3D;&#x3D; vnode.text) &#123; &#x2F;&#x2F; 文本不相同替换   </span><br><span class="line">  nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">  let oldStartIdx &#x3D; 0</span><br><span class="line">  let newStartIdx &#x3D; 0</span><br><span class="line">  let oldEndIdx &#x3D; oldCh.length - 1</span><br><span class="line">  let oldStartVnode &#x3D; oldCh[0]</span><br><span class="line">  let oldEndVnode &#x3D; oldCh[oldEndIdx]</span><br><span class="line">  let newEndIdx &#x3D; newCh.length - 1</span><br><span class="line">  let newStartVnode &#x3D; newCh[0]</span><br><span class="line">  let newEndVnode &#x3D; newCh[newEndIdx]</span><br><span class="line">  let oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line">  &#x2F;&#x2F; removeOnly is a special flag used only by &lt;transition-group&gt;    </span><br><span class="line">  &#x2F;&#x2F; to ensure removed elements stay in correct relative positions    </span><br><span class="line">  &#x2F;&#x2F; during leaving transitions    </span><br><span class="line">  const canMove &#x3D; !removeOnly</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">    checkDuplicateKeys(newCh)</span><br><span class="line">  &#125;</span><br><span class="line">  while (oldStartIdx &lt;&#x3D; oldEndIdx &amp;&amp; newStartIdx &lt;&#x3D; newEndIdx) &#123;</span><br><span class="line">    if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode &#x3D; oldCh[++oldStartIdx] &#x2F;&#x2F; Vnode has been moved left     </span><br><span class="line">    &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode &#x3D; oldCh[++</span><br><span class="line">        oldStartIdx] newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode &#x3D; oldCh[--oldEndIdx] newEndVnode &#x3D;</span><br><span class="line">        newCh[--newEndIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; &#x2F;&#x2F; Vnode moved right        </span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(</span><br><span class="line">          parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode &#x3D; oldCh[++oldStartIdx] newEndVnode &#x3D;</span><br><span class="line">        newCh[--newEndIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; &#x2F;&#x2F; Vnode moved left        </span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(</span><br><span class="line">        parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode &#x3D; oldCh[--oldEndIdx] newStartVnode &#x3D; newCh[++</span><br><span class="line">        newStartIdx]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      if (isUndef(oldKeyToIdx)) oldKeyToIdx &#x3D; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld &#x3D; isDef(</span><br><span class="line">        newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx,</span><br><span class="line">        oldEndIdx) if (isUndef(idxInOld)) &#123; &#x2F;&#x2F; New element          </span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnodeToMove &#x3D; oldCh[idxInOld]</span><br><span class="line">        if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] &#x3D; undefined canMove &amp;&amp;</span><br><span class="line">            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; same key but different element. treat as new element           </span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm &#x3D; isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh,</span><br><span class="line">      newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125;</span><br><span class="line">  a</span><br><span class="line">  else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodes(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是我对diff算法的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>coding配置腾讯云证书</title>
    <url>/2021/02/11/139-coding%E9%85%8D%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>小小的记录,以免以后忘记了</p>
</blockquote>
<a id="more"></a>

<p>今天写完博客,发现网站的证书过期了,以往都是coding每次免费3个月的证书,但是现在coding和腾讯云合作了,要用腾讯云的证书了</p>
<ol>
<li><p>首先在coding中静态网站上看看自定义域名是否通过,因为coding的整体升级,于是CNAME指向也改了,我的域名是在阿里云上的,所以需要在阿里云的域名解析中重新添加</p>
</li>
<li><p>通过后就可以去申请腾讯云的证书了,他有免费一年的证书,可以找一找,然后填写一下资料,自己的域名和邮箱</p>
</li>
<li><p>第二步验证的方式使用DNS验证,同样的,在阿里云的域名解析中添加验证</p>
</li>
<li><p>成功后就会签发证书,就可以进行部署了</p>
</li>
<li><p>部署的时候选择腾讯云托管证书,在证书列表中选择刚刚签发的证书,回源协议选择HTTP或者HTTPS都可以</p>
</li>
<li><p>腾讯云证书部署成功后,在第一步的coding的静态网站中重新部署一下你的网站,这样就成功了(我最后一步一直没有重新部署,所以我一直以为我的证书部署失败了)</p>
</li>
<li><p>中途如果有部署失败的,应该是你的域名也指向了github,先把指向github的给暂停</p>
</li>
</ol>
<p>至此,博客的证书又可以白嫖一年了</p>
]]></content>
      <categories>
        <category>SSL证书</category>
      </categories>
      <tags>
        <tag>SSL证书</tag>
      </tags>
  </entry>
  <entry>
    <title>RequireJS插件的使用</title>
    <url>/2017/01/03/14-requireJs%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>RequireJS 是一个JavaScript模块加载器，使用RequireJS加载模块化脚本将提高代码的加载速度和质量。今天和大家分享一下RequireJS插件的使用</p>
</blockquote>
<a id="more"></a>

<p>关于RequireJS，我也还在学习中，下方贴出核心代码，和一下注释，更多详细的教程可以阮一峰老师的文档中看一看</p>
<h3 id="require-text插件"><a href="#require-text插件" class="headerlink" title="require text插件"></a>require text插件</h3><ol>
<li><p>需要导入 require.js 和 text.js</p>
</li>
<li><p>使用text!,可以得到文件中的内容,需要注意路径</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'libs/text!resource/textc.css'</span>,<span class="string">'libs/text!resource/texth.html'</span>,<span class="string">'libs/text!resource/textt.txt'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">cssStr,htmlStr,textStr</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(cssStr);</span><br><span class="line">	<span class="built_in">console</span>.log(htmlStr);</span><br><span class="line">	<span class="built_in">console</span>.log(textStr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">document</span>.getElementById(<span class="string">'st'</span>).innerHTML = cssStr;</span><br><span class="line">	<span class="built_in">document</span>.body.innerHTML = htmlStr + textStr;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="require-domReady插件"><a href="#require-domReady插件" class="headerlink" title="require domReady插件"></a>require domReady插件</h3><p>需要导入 require.js 和 domReady.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'libs/domReady'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">domReady</span>)</span>&#123;</span><br><span class="line">	domReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		domReady()会在html文件加载完成时调用</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="require-css插件"><a href="#require-css插件" class="headerlink" title="require css插件"></a>require css插件</h3><p>需要导入 require.js 和 css.js    —将css.js ! style.css 写在一起</p>
<p>如何利用 requireJs 加载 css 文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//libs/css --&gt; libs/css.js</span></span><br><span class="line"><span class="comment">//css/style --&gt; css/style.css</span></span><br><span class="line"><span class="comment">//中间以 '!' 隔开</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'libs/css!css/style'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 其实 css.js 实现原理很简单，读取 css 文件内容，创建 style</span></span><br><span class="line">	<span class="comment">// 标签，把 css 内容拼接进去，把 style 标签放到 head 中。</span></span><br><span class="line">	alert(<span class="string">'js和css资源加载完毕'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="require-使用模板插件"><a href="#require-使用模板插件" class="headerlink" title="require 使用模板插件"></a>require 使用模板插件</h3><p>需要导入 require.js 和 template-web.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里先引入template 和 模板</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'template-web'</span>,<span class="string">'text!template.html'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">template,templateStr</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> fun = template.compile(templateStr);<span class="comment">//template.compile()函数返回的是一个渲染的函数,参数是一个模板的字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> htmlStr = fun(data);<span class="comment">//通过一个渲染函数，可以将数据渲染到 渲染函数的模板上</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">document</span>.body.innerHTML = htmlStr;<span class="comment">//最终可以的到一个被渲染后的字符串</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="require-压缩合并"><a href="#require-压缩合并" class="headerlink" title="require 压缩合并"></a>require 压缩合并</h3><p>需要导入 require.js 和 r.js</p>
<p>这里是压缩js——–首先要配置bulid.js文件</p>
<h4 id="配置require"><a href="#配置require" class="headerlink" title="配置require"></a>配置require</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">	paths:&#123;-------使用<span class="built_in">require</span>.js 进行js优化时，不能加载网络文件</span><br><span class="line"></span><br><span class="line">		requireLib:<span class="string">'require'</span>,-----如果要将<span class="built_in">require</span>.js也压缩，那需要在paths中加上</span><br><span class="line"></span><br><span class="line">		jquery:<span class="string">'empty:'</span>---如果不想压缩某个js，就可以将其配置成：empty:</span><br><span class="line">	&#125;,</span><br><span class="line">	include:[<span class="string">'requireLib'</span>,<span class="string">'jquery'</span>],---include 相当于引入哪些文件，需要压缩合并的文件</span><br><span class="line"></span><br><span class="line">	name:<span class="string">'index'</span>,---设置优化的js文件入口  ---这里的index.js将要压缩的js都导入进来<span class="built_in">require</span>([<span class="string">'js1'</span>])</span><br><span class="line"></span><br><span class="line">	out:<span class="string">'index-build.js'</span>---生成优化后的文件名字及路径</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<pre><code>在命令行输入(先cd到当前文件夹)

node r.js -o build.js  ---这是压缩合并的

node r.js -o build.js optimize=none ----合并不压缩</code></pre><p>踩坑！！！！！ 有时候文件里的注释会导致压缩失败</p>
<pre><code>全局安装require

npm i -g requirejs

cd 文件夹

node r.js -o build.js</code></pre><h4 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h4><pre><code>先新建一个index.css----@import url(&quot;css/css1.css&quot;);

node r.js -o cssIn=index.css out=index-bulid.css</code></pre><p>以上就是我对requireJs插件的一些理解,不足之处希望大牛们多提一些意见,感激不尽</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于CSS的一些事(2)</title>
    <url>/2021/02/11/140-%E5%85%B3%E4%BA%8ECSS%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B(2)/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>记录一些实用的CSS</p>
</blockquote>
<a id="more"></a>

<h3 id="全屏灰色（特殊日期使用）"><a href="#全屏灰色（特殊日期使用）" class="headerlink" title="全屏灰色（特殊日期使用）"></a>全屏灰色（特殊日期使用）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.filter &#123;</span><br><span class="line">  -webkit-filter: grayscale(100%); &#x2F;* webkit *&#x2F;</span><br><span class="line">  -moz-filter: grayscale(100%); &#x2F;*firefox*&#x2F;</span><br><span class="line">  -ms-filter: grayscale(100%); &#x2F;*ie9*&#x2F;</span><br><span class="line">  -o-filter: grayscale(100%); &#x2F;*opera*&#x2F;</span><br><span class="line">  filter: grayscale(100%);</span><br><span class="line">  filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale&#x3D;1); &#x2F;*ie*&#x2F;</span><br><span class="line">  filter: gray; &#x2F;*ie9- *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;html class&#x3D;&quot;filter&quot;&gt;</span><br><span class="line">  &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;cdn.pixabay.com&#x2F;photo&#x2F;2015&#x2F;04&#x2F;20&#x2F;17&#x2F;01&#x2F;flower-731830_960_720.jpg&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="卡券贴"><a href="#卡券贴" class="headerlink" title="卡券贴"></a>卡券贴</h3><p>在CSS3当中，background添加了background-size属性，控制背景图片的大小，配合background-position属性，可以在一个背景下面展示多张图片。</p>
<p>卡券贴的核心是使用透明白色径向渐变radial-gradient，分别让4张背景图中的左下角、右下角、右上角和左下角出现缺省，再利用drop-shadow实现元素阴影，从而达到效果。</p>
<p>radial-gradient语法如下：</p>
<blockquote>
<p>radial-gradient(shape size at position, start-color, …, last-color)</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-0e2b43fad0beebc5c13b3c7983b5ca45_720w.jpg" alt="属性说明"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.coupon&#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 80px;</span><br><span class="line">  background: radial-gradient(circle at right bottom, transparent 10px, #ffffff 0) top right &#x2F; 50% 40px no-repeat,</span><br><span class="line">    radial-gradient(circle at left bottom, transparent 10px, #ffffff 0) top left &#x2F; 50% 40px no-repeat,</span><br><span class="line">    radial-gradient(circle at right top, transparent 10px, #ffffff 0) bottom right &#x2F; 50% 40px no-repeat,</span><br><span class="line">    radial-gradient(circle at left top, transparent 10px, #ffffff 0) bottom left &#x2F; 50% 40px no-repeat;</span><br><span class="line">  filter: drop-shadow(3px 3px 3px #c5c5c5);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;coupon&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="文本溢出自动省略号"><a href="#文本溢出自动省略号" class="headerlink" title="文本溢出自动省略号"></a>文本溢出自动省略号</h3><p>这个在项目中经常用到,但是一直都记不住</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.ellipsis &#123;</span><br><span class="line">  width: 500px;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;ellipsis&quot;&gt;</span><br><span class="line">  明月几时有，把酒问青天。不知天上宫阙，今夕是何年。我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间。</span><br><span class="line">  转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="记录其他的好的链接"><a href="#记录其他的好的链接" class="headerlink" title="记录其他的好的链接"></a>记录其他的好的链接</h3><p>大神的作品,转载知乎</p>
<p><a href="https://zhuanlan.zhihu.com/p/158672754" target="_blank" rel="noopener">戳我跳转</a></p>
<p>总是记不住,但是要用到的样式 </p>
<p><a href="https://zhuanlan.zhihu.com/p/231014167" target="_blank" rel="noopener">戳我跳转</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp与webview之间的相互传值</title>
    <url>/2021/04/19/141-uniapp%E4%B8%8Ewebview%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>在uniApp中,有时候我们需要外嵌一个H5在我们的webview中,那怎么让他们之前进行相互传值</p>
</blockquote>
<a id="more"></a>

<div class="note primary">
            <p>以下代码都是在真机调试中测试的,有一些方法是只有uniapp运行到真机中才可以使用的</p>
          </div>

<h3 id="引入的H5文件"><a href="#引入的H5文件" class="headerlink" title="引入的H5文件"></a>引入的H5文件</h3><p>这个H5的例子官方是已经有了的,需要注意的就是引入的<code>uni.webview.1.5.2.js</code></p>
<p>我不知道为什么引入外部cdn(<a href="https://js.cdn.aliyun.dcloud.net.cn/dev/uni-app/uni.webview.1.5.2.js" target="_blank" rel="noopener">https://js.cdn.aliyun.dcloud.net.cn/dev/uni-app/uni.webview.1.5.2.js</a>) 会失效,所以我都是将js下载下来,进行本地引入</p>
<p>H5的源码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">		&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">		&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">			.btn &#123;</span><br><span class="line">				display: block;</span><br><span class="line">				margin: 20px auto;</span><br><span class="line">				padding: 5px;</span><br><span class="line">				background-color: #007aff;</span><br><span class="line">				border: 0;</span><br><span class="line">				color: #ffffff;</span><br><span class="line">				height: 40px;</span><br><span class="line">				width: 200px;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			.btn-red &#123;</span><br><span class="line">				background-color: #dd524d;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			.btn-yellow &#123;</span><br><span class="line">				background-color: #f0ad4e;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			.desc &#123;</span><br><span class="line">				padding: 10px;</span><br><span class="line">				color: #999999;</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;&#x2F;style&gt;</span><br><span class="line">	&lt;&#x2F;head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;p class&#x3D;&quot;desc&quot;&gt;web-view 组件加载本地 html 示例，仅在 App 环境下生效。点击下列按钮，跳转至其它页面。&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;mui-content&quot;&gt;</span><br><span class="line">        &lt;div id&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; capture&#x3D;&#39;camera&#39; accept&#x3D;&#39;image&#x2F;*&#39;&gt;</span><br><span class="line">		&lt;div class&#x3D;&quot;btn-list&quot;&gt;</span><br><span class="line">			&lt;button class&#x3D;&quot;btn&quot; type&#x3D;&quot;button&quot; data-action&#x3D;&quot;navigateTo&quot;&gt;navigateTo&lt;&#x2F;button&gt;</span><br><span class="line">			&lt;button class&#x3D;&quot;btn&quot; type&#x3D;&quot;button&quot; data-action&#x3D;&quot;redirectTo&quot;&gt;redirectTo&lt;&#x2F;button&gt;</span><br><span class="line">			&lt;button class&#x3D;&quot;btn&quot; type&#x3D;&quot;button&quot; data-action&#x3D;&quot;navigateBack&quot;&gt;navigateBack&lt;&#x2F;button&gt;</span><br><span class="line">			&lt;button class&#x3D;&quot;btn&quot; type&#x3D;&quot;button&quot; data-action&#x3D;&quot;reLaunch&quot;&gt;reLaunch&lt;&#x2F;button&gt;</span><br><span class="line">			&lt;button class&#x3D;&quot;btn&quot; type&#x3D;&quot;button&quot; data-action&#x3D;&quot;switchTab&quot;&gt;switchTab&lt;&#x2F;button&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;p class&#x3D;&quot;desc&quot;&gt;网页向应用发送消息。注意：小程序端应用会在此页面后退时接收到消息。&lt;&#x2F;p&gt;</span><br><span class="line">		&lt;div class&#x3D;&quot;btn-list&quot;&gt;</span><br><span class="line">			&lt;button class&#x3D;&quot;btn btn-red&quot; type&#x3D;&quot;button&quot; id&#x3D;&quot;postMessage&quot;&gt;postMessage&lt;&#x2F;button&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;!-- uni 的 SDK --&gt;</span><br><span class="line">		&lt;!-- &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;js.cdn.aliyun.dcloud.net.cn&#x2F;dev&#x2F;uni-app&#x2F;uni.webview.1.5.2.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;uni.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">		&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">			document.addEventListener(&#39;UniAppJSBridgeReady&#39;, function() &#123;</span><br><span class="line">				document.querySelector(&#39;.btn-list&#39;).addEventListener(&#39;click&#39;, function(evt) &#123;</span><br><span class="line">					var target &#x3D; evt.target;</span><br><span class="line">					if (target.tagName &#x3D;&#x3D;&#x3D; &#39;BUTTON&#39;) &#123;</span><br><span class="line">						var action &#x3D; target.getAttribute(&#39;data-action&#39;);</span><br><span class="line">						switch (action) &#123;</span><br><span class="line">							case &#39;switchTab&#39;:</span><br><span class="line">								uni.switchTab(&#123;</span><br><span class="line">									url: &#39;&#x2F;pages&#x2F;tabBar&#x2F;API&#x2F;API&#39;</span><br><span class="line">								&#125;);</span><br><span class="line">								break;</span><br><span class="line">							case &#39;reLaunch&#39;:</span><br><span class="line">								uni.reLaunch(&#123;</span><br><span class="line">									url: &#39;&#x2F;pages&#x2F;tabBar&#x2F;API&#x2F;API&#39;</span><br><span class="line">								&#125;);</span><br><span class="line">								break;</span><br><span class="line">							case &#39;navigateBack&#39;:</span><br><span class="line">								uni.navigateBack(&#123;</span><br><span class="line">									delta: 1</span><br><span class="line">								&#125;);</span><br><span class="line">								break;</span><br><span class="line">							default:</span><br><span class="line">								uni[action](&#123;</span><br><span class="line">									url: &#39;&#x2F;pages&#x2F;component&#x2F;button&#x2F;button&#39;</span><br><span class="line">								&#125;);</span><br><span class="line">								break;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				document.querySelector(&quot;#postMessage&quot;).addEventListener(&#39;click&#39;, function() &#123;</span><br><span class="line">					uni.postMessage(&#123;</span><br><span class="line">						data: &#123;</span><br><span class="line">							action: &#39;message&#39;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;);</span><br><span class="line">      function ajaxRequest(a)&#123;</span><br><span class="line">        alert(&#39;接收到的参数: &#39;, a);</span><br><span class="line">      &#125;</span><br><span class="line">		&lt;&#x2F;script&gt;</span><br><span class="line">	&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="H5-发送数据到-uniapp"><a href="#H5-发送数据到-uniapp" class="headerlink" title="H5 发送数据到 uniapp"></a>H5 发送数据到 uniapp</h3><ul>
<li>H5使用uni.postMessage发送数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uni.postMessage(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    action: &#39;message&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>webview使用@message进行监听</li>
</ul>
<p>具体源码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;web-view ref&#x3D;&#39;webview&#39; src&#x3D;&quot;&#x2F;hybrid&#x2F;html&#x2F;local.html&quot;	@message&#x3D;&quot;handleMessage&quot; &gt;&lt;&#x2F;web-view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleMessage(evt) &#123;</span><br><span class="line">      console.log(&#39;接收到的消息：&#39; + JSON.stringify(evt.detail.data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>H5页面的postMessage就是向uniapp发送消息</p>
<div class="note info">
            <p>需要注意的是这里的src引入,我这里引入的是本地文件,所以跟着官方的文档走,放在<code>/hybrid/html/</code>的路径下</p>
          </div>

<h3 id="uniapp-发送数据到-H5"><a href="#uniapp-发送数据到-H5" class="headerlink" title="uniapp 发送数据到 H5"></a>uniapp 发送数据到 H5</h3><p>百度上大部分的答案都是 通过url就可以向H5进行传参 </p>
<p>这种当然也可以,在H5中,再去获取url中的参数值,但是这种方法只能用在第一次</p>
<p>接下来后续应该怎么传递参数呢</p>
<blockquote>
<p>获取到这个webview的元素,然后就可以使用evalJS方法了</p>
</blockquote>
<p>但是这一步卡了我很久</p>
<p>因为百度到的都是<code>this.$mp.page.$getAppWebview()</code>这样的方法</p>
<p>但是 uniapp编译app时使用的都是webview,this.$mp.page.$getAppWebview()获取的是父webview. 所以一直没有evalJS方法</p>
<p>需要打点<code>.children()[0];</code>获取到子级,才是当前的webview</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webview &#x3D; this.$mp.page.$getAppWebview().children()[0]; </span><br><span class="line">var name &#x3D; &#39;mike&#39;;</span><br><span class="line">webview.evalJS(&quot;ajaxRequest(&#39;&quot; + name + &quot;&#39;)&quot;);</span><br></pre></td></tr></table></figure>

<p>然后使用<code>evalJS</code>去调用方法就行</p>
<div class="note warning">
            <p>注意evalJS方法里的 单引号 和 双引号</p>
          </div>

<p>在H5中,只要有对应的方法就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ajaxRequest(a)&#123;</span><br><span class="line">  alert(&#39;接收到的参数: &#39;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取当前的webview,也可以使用下面这种方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pages &#x3D; getCurrentPages();  </span><br><span class="line">var page &#x3D; pages[pages.length - 1];  </span><br><span class="line">var webview &#x3D; page.$getAppWebview(); &#x2F;&#x2F;页面栈最顶层就是当前webview</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>getCurrentPages() 方法是 uniapp 中自带的</p>
          </div>

<p>以上就是我对uniapp与webview之间的相互传值的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>uniApp</category>
      </categories>
      <tags>
        <tag>uniApp</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解垃圾回收原理</title>
    <url>/2021/08/30/142-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>前一阵子由于网站拿去ICP的备案,所以停了一段时间,现在备案下来了,我们来学习一下垃圾回收</p>
</blockquote>
<a id="more"></a>

<h3 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h3><p>垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要时，就应该予以释放，以让出内存。</p>
<p>直白点讲，就是程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量、函数等只有产生没有消亡的过程，那迟早内存有被完全占用的时候。</p>
<p>这个时候，不仅自己的程序无法正常运行，连其他程序也会受到影响。</p>
<p>所以，在计算机中，我们需要垃圾回收。需要注意的是，定义中的“自动”的意思是语言可以帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果操作失当，JavaScript 中依旧会出现内存溢出的情况。</p>
<h3 id="垃圾回收原理"><a href="#垃圾回收原理" class="headerlink" title="垃圾回收原理"></a>垃圾回收原理</h3><p>垃圾回收基于两个原理：</p>
<ul>
<li>考虑某个变量或对象在未来的程序运行中将不会被访问</li>
<li>向这些对象要求归还内存</li>
</ul>
<p>而这两个原理中，最主要的也是最艰难的部分就是找到“所分配的内存确实已经不再需要了”。</p>
<p>在解释这些之前,我们要先了解一下名词-GC</p>
<h3 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a>什么是GC</h3><p>GC可以理解为在追踪仍然使用的所有对象，并将其余对象标记为垃圾然后进行回收，这样的一个过程称之为GC，所有的GC系统可以从如下几个方面进行实现</p>
<ul>
<li>GC判断策略（例如引用计数，对象可达）</li>
<li>GC收集算法（标记清除法，标记清除整理法，标记复制清除法，分带法）</li>
<li>GC收集器（例如Serial，Parallel，CMS，G1）</li>
</ul>
<h3 id="V8垃圾回收策略"><a href="#V8垃圾回收策略" class="headerlink" title="V8垃圾回收策略"></a>V8垃圾回收策略</h3><p>V8的垃圾回收策略基于分代回收机制，该机制又基于<a href="https://www.memorymanagement.org/glossary/g.html#generational%20hypothesis" target="_blank" rel="noopener">世代假说</a>。该假说有两个特点：</p>
<ul>
<li>大部分新生对象倾向于早死；</li>
<li>不死的对象，会活得更久。</li>
</ul>
<p>基于这个理论，现代垃圾回收算法根据对象的存活时间将内存进行了分代，并对不同分代的内存采用不同的高效算法进行垃圾回收。</p>
<h3 id="V8的内存分代"><a href="#V8的内存分代" class="headerlink" title="V8的内存分代"></a>V8的内存分代</h3><p>在V8中，将内存分为了新生代（new space）和老生代（old space）。它们特点如下：</p>
<ul>
<li>新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。</li>
<li>老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。</li>
</ul>
<blockquote>
<p>V8堆的空间等于新生代空间加上老生代空间，默认设置下，64位系统的老生代大小为1400M，32位系统为700M。</p>
</blockquote>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="Stop-The-World-（全停顿）"><a href="#Stop-The-World-（全停顿）" class="headerlink" title="Stop The World （全停顿）"></a>Stop The World （全停顿）</h4><p>在介绍垃圾回收算法之前，我们先了解一下「全停顿」。垃圾回收算法在执行前，需要将应用逻辑暂停，执行完垃圾回收后再执行应用逻辑，这种行为称为 「全停顿」（Stop The World）</p>
<p>全停顿的目的，是为了解决应用逻辑与垃圾回收器看到的情况不一致的问题。举个例子，在自助餐厅吃饭，高高兴兴地取完食物回来时，结果发现自己餐具被服务员收走了。这里，服务员好比垃圾回收器，餐具就像是分配的对象，我们就是应用逻辑。在我们看来，只是将餐具临时放在桌上，但是服务员看来觉得你已经不需要使用了，因此就收走了。你与服务员对于同一个事物看到的情况是不一致，导致服务员做了与我们不期望的事情。因此，为避免应用逻辑与垃圾回收器看到的情况不一致，垃圾回收算法在执行时，需要停止应用逻辑。</p>
<h4 id="引用计数（reference-counting）"><a href="#引用计数（reference-counting）" class="headerlink" title="引用计数（reference counting）"></a>引用计数（reference counting）</h4><p>在V8回收之前,低版本 IE大多数用的是这种的方法</p>
<p>在内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。上例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj1 &#x3D; &#123; a: 1 &#125;; &#x2F;&#x2F; 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1 </span><br><span class="line">let obj2 &#x3D; obj1; &#x2F;&#x2F; A 的引用个数变为 2</span><br><span class="line"></span><br><span class="line">obj1 &#x3D; 0; &#x2F;&#x2F; A 的引用个数变为 1</span><br><span class="line">obj2 &#x3D; 0; &#x2F;&#x2F; A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了</span><br></pre></td></tr></table></figure>

<p>但是引用计数有个最大的问题： 循环引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">  let obj1 &#x3D; &#123;&#125;;</span><br><span class="line">  let obj2 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  obj1.a &#x3D; obj2; &#x2F;&#x2F; obj1 引用 obj2</span><br><span class="line">  obj2.a &#x3D; obj1; &#x2F;&#x2F; obj2 引用 obj1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。</p>
<p>要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。上面的例子可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj1 &#x3D; null;</span><br><span class="line">obj2 &#x3D; null;</span><br></pre></td></tr></table></figure>

<p>这个方法被称为“解除引用”。</p>
<h4 id="Scavenge算法"><a href="#Scavenge算法" class="headerlink" title="Scavenge算法"></a>Scavenge算法</h4><p>在分代的基础上,新生代中的对象主要通过Scavenge算法进行垃圾回收,在Scavenge的具体 实现中,主要采用了Cheney算法</p>
<p>Cheney算法采用复制的方式进行垃圾回收。它将堆内存一分为二，每一部分空间称为 semispace。这两个空间，只有一个空间处于使用中，另一个则处于闲置。使用中的 semispace 称为 「From 空间」，闲置的 semispace 称为 「To 空间」。</p>
<p>过程如下: </p>
<ol>
<li>从 From 空间分配对象，若 semispace 被分配满，则执行 Scavenge 算法进行垃圾回收。</li>
<li>检查 From 空间的存活对象，若对象存活，则检查对象是否符合晋升条件，若符合条件则晋升到老生代，否则将对象从 From 空间复制到 To 空间。</li>
<li>若对象不存活，则释放不存活对象的空间。</li>
<li>完成复制后，将 From 空间与 To 空间进行角色翻转（flip）。</li>
</ol>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/142-1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.jpg" alt="算法示意图"></p>
<h5 id="对象晋升"><a href="#对象晋升" class="headerlink" title="对象晋升"></a>对象晋升</h5><p>第二点提到的对象晋升,条件有两个: </p>
<ul>
<li>对象是否经历过Scavenge回收。</li>
<li>To 空间的内存使用占比是否超过限制(25%)。</li>
</ul>
<blockquote>
<p>Scavenge 算法的缺点是，它的算法机制决定了只能利用一半的内存空间。但是新生代中的对象生存周期短、存活对象少，进行对象复制的成本不是很高，因而非常适合这种场景。</p>
</blockquote>
<h4 id="标记-清除（mark-and-sweep）"><a href="#标记-清除（mark-and-sweep）" class="headerlink" title="标记-清除（mark and sweep）"></a>标记-清除（mark and sweep）</h4><p>这是 JavaScript 中最常见的垃圾回收方式</p>
<p>从 2012 年起，所有现代浏览器都使用了标记-清除的垃圾回收方法，除了低版本 IE…它们采用的是引用计数方法。</p>
<p>那什么叫标记清除呢？JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些活着的对象进行标记，这是标记阶段。清除阶段会对标记的对象会与内存中的对象进行比较，然后清除内存中那些没有标记的对象。</p>
<p>标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/142-2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.jpg.jpg" alt="算法示意图"></p>
<h4 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h4><p>在新生代中，由于存活对象少，垃圾回收效率高，全停顿时间短，造成的影响小。但是老生代中，存活对象多，垃圾回收时间长，全停顿造成的影响大。为了减少全停顿的时间，V8对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记。</p>
<blockquote>
<p>长时间的GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。从2011年起，v8就将「全暂停」标记换成了增量标记。改进后的标记方式，最大停顿时间减少到原来的1/6。</p>
</blockquote>
<p>以上就是我对垃圾回收的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SSH上传部署</title>
    <url>/2021/08/31/143-%E4%BD%BF%E7%94%A8SSH%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>上传git或者coding时使用ssh</p>
</blockquote>
<a id="more"></a>

<p>因为太久没有上传博客了,所以提交代码的时候发现git报错了,查了一下百度,发现git已经不能使用账户和密码了,需要使用账户和token</p>
<p>嫌太麻烦了,所以统一使用ssh来上传部署</p>
<h3 id="获取电脑的ssh公钥"><a href="#获取电脑的ssh公钥" class="headerlink" title="获取电脑的ssh公钥"></a>获取电脑的ssh公钥</h3><p>打开 C盘/用户/.ssh/ 用文本编辑器打开 id_rsa.pub 文件（此处是生成公钥的默认名称，如果生成公钥时采用了其他名称，打开相对应的文件即可），复制全部内容。</p>
<h3 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h3><ul>
<li>登录 CODING ，点击右上角【个人设置】，选择菜单【SSH 公钥】，点击【新增公钥】按钮</li>
<li>将第一步中复制的内容填写到【公钥内容】一栏，公钥名称按需填写即可。</li>
<li>设定公钥有效期，可选择具体日期或设置永久有效。</li>
<li>点击【添加】，然后输入账户密码即可成功添加公钥。</li>
<li>完成后在命令行测试，首次建立链接会要求信任主机。命令 ssh -T <a href="mailto:git@e.coding.net">git@e.coding.net</a></li>
</ul>
<h4 id="添加部署公钥"><a href="#添加部署公钥" class="headerlink" title="添加部署公钥"></a>添加部署公钥</h4><ul>
<li>登录 CODING，进入目标项目，点击【代码仓库】-&gt; 【仓库设置】-&gt; 【部署公钥】-&gt;【新建部署公钥】</li>
<li>将第一步中复制的内容填写到【公钥内容】一栏，公钥名称自定义。</li>
<li>点击【新建】，然后输入账户密码即可成功添加部署公钥</li>
<li>部署公钥默认拥有该项目的只读权限，如果需要获取推送权限，请勾选部署公钥设置里的【授予推送权限】</li>
</ul>
<blockquote>
<p>配置好后,在仓库设置的基本设置里可以找到自己的SSH地址, SSH 协议的 Git 仓库地址示例所示：<a href="mailto:git@e.coding.net">git@e.coding.net</a>:team-name/project-name.git</p>
</blockquote>
<p><a href="https://help.coding.net/docs/project-settings/ssh.html" target="_blank" rel="noopener">coding官网配置ssh</a></p>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>其他的配置都和coding一样,这里就不重复说明了,说一下git在哪里配置的</p>
<p><a href="https://img-blog.csdnimg.cn/20201223152106902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbGVuY2VfcGlub3Q=,size_16,color_FFFFFF,t_70#pic_center#pic_center" target="_blank" rel="noopener">gittu</a></p>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>都OK了的话,在hexo的_config.yml写一下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 使用SSh公钥来配置</span><br><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: </span><br><span class="line">      github: git@github.com:name&#x2F;project.github.io.git</span><br><span class="line">      coding: git@e.coding.net:team-name&#x2F;project-name.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>

<p>以上就是我对SSH上传部署的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>axios在XP系统的兼容问题</title>
    <url>/2021/09/01/144-axios%E5%9C%A8XP%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>vue-cli 使用 axios 兼容 xp</p>
</blockquote>
<a id="more"></a>

<p>项目需要兼容XP,控制台查看报错发现是 <code>promise is undefined</code>, 项目中调用接口使用的是axios, axios又是基于promise上</p>
<p>所以需要添加一些插件进行兼容</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>看到一篇博客说可以使用bluebird.js解决。直接在页面引入bluebird.js问题就解决了。</p>
<p><a href="https://fastly.jsdelivr.net/bluebird/latest/bluebird.js" target="_blank" rel="noopener">bluebird.js下载地址</a></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><code>npm install --save babel-polyfill</code></p>
<p>安装成功以后需要在main.js 中引入 babel-polyfill</p>
<p>一般会配置 webpack.base.config.js 中 entry</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  context: path.resolve(__dirname, &#39;..&#x2F;&#39;),</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: [&quot;babel-polyfill&quot;, &quot;.&#x2F;src&#x2F;main.js&quot;] </span><br><span class="line">    &#x2F;&#x2F; app: &#39;.&#x2F;src&#x2F;main.js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搞定……</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>html高频考题</title>
    <url>/2021/09/01/145-html%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>整理了一下常见的HTML的问题</p>
</blockquote>
<a id="more"></a>

<h3 id="DOCTYPE-的作用是什么"><a href="#DOCTYPE-的作用是什么" class="headerlink" title="DOCTYPE 的作用是什么?"></a>DOCTYPE 的作用是什么?</h3><!DOCTYPE><p>声明位于 HTML 文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。</p>
<p>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</p>
<h3 id="标准模式与兼容模式各有什么区别"><a href="#标准模式与兼容模式各有什么区别" class="headerlink" title="标准模式与兼容模式各有什么区别?"></a>标准模式与兼容模式各有什么区别?</h3><p>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。</p>
<p>在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</p>
<h3 id="页面导入样式时，使用-link-和-import-有什么区别"><a href="#页面导入样式时，使用-link-和-import-有什么区别" class="headerlink" title="页面导入样式时，使用 link 和 @import 有什么区别?"></a>页面导入样式时，使用 link 和 @import 有什么区别?</h3><ul>
<li>从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。</li>
<li>加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。</li>
<li>兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容性问题。</li>
<li>DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于DOM 方法是基于文档的，无法使用 @import 的方式插入样式。</li>
<li>link方式的样式的权重 高于@import的权重.</li>
</ul>
<h3 id="从敲入-URL-到渲染完成的整个过程"><a href="#从敲入-URL-到渲染完成的整个过程" class="headerlink" title="从敲入 URL 到渲染完成的整个过程"></a>从敲入 URL 到渲染完成的整个过程</h3><ul>
<li>用户输入 url 地址，浏览器根据域名寻找 IP 地址</li>
<li>浏览器向服务器发送 http 请求，如果服务器段返回以 301 之类的重定向，浏览器根据相应头中的 location 再次发送请求</li>
<li>服务器端接受请求，处理请求生成 html 代码，返回给浏览器，这时的 html 页面代码可能是经过压缩的</li>
<li>浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染</li>
<li>解析渲染该过程主要分为以下步骤：解析 HTML、构建 DOM 树、DOM 树与 CSS 样式进行附着构造呈现树</li>
<li>布局</li>
<li>绘制</li>
</ul>
<h3 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h3><ul>
<li>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</li>
<li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。</li>
</ul>
<blockquote>
<p>BOM 的核心是 window, window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</p>
</blockquote>
<h3 id="浏览器的渲染原理-渲染引擎"><a href="#浏览器的渲染原理-渲染引擎" class="headerlink" title="浏览器的渲染原理(渲染引擎)"></a>浏览器的渲染原理(渲染引擎)</h3><ul>
<li>首先解析收到的文档，根据文档定义构建一颗 DOM 树，DOM 树是由DOM 元素及属性节点组成的；</li>
<li>然后对 CSS 进行解析，生成 CSSOM 规则树；</li>
<li>根据 DOM 树和 CSSOM 规则树构建 Render Tree。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和DOM 对象相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。</li>
<li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情就是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>
<li>布局阶段结束后是绘制阶段，比那里渲染树并调用对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>
</ul>
<p>所有的 html 解析完成之后再去构建和布局 render tree。它是解析完一部分内容就显示一部分内容，同时可能还在网络下载其余内容。</p>
<h3 id="浏览器解析过程-JS-引擎"><a href="#浏览器解析过程-JS-引擎" class="headerlink" title="浏览器解析过程(JS 引擎)"></a>浏览器解析过程(JS 引擎)</h3><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p>
<p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p>
<h3 id="什么是重绘和回流"><a href="#什么是重绘和回流" class="headerlink" title="什么是重绘和回流?"></a>什么是重绘和回流?</h3><p>重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background color，我们将这样的操作称为重绘。<br>回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。</p>
<p>常见引起回流属性和方法:</p>
<blockquote>
<p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p>
</blockquote>
<ol>
<li>添加或者删除可见的 DOM 元素；</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度</li>
<li>内容变化，比如用户在 input 框中输入文字</li>
<li>浏览器窗口尺寸改变——resize 事件发生时</li>
<li>计算 offsetWidth 和 offsetHeight 属性</li>
<li>设置 style 属性的值</li>
<li>当你修改网页的默认字体时。</li>
</ol>
<p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p>
<h3 id="Canvas-和-SVG-有什么区别"><a href="#Canvas-和-SVG-有什么区别" class="headerlink" title="Canvas 和 SVG 有什么区别?"></a>Canvas 和 SVG 有什么区别?</h3><p>Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。</p>
<p>SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。</p>
<h3 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h3><ul>
<li>用户界面<ul>
<li>主进程</li>
<li>内核<ul>
<li>渲染引擎</li>
<li>JS 引擎<ul>
<li>执行栈</li>
</ul>
</li>
</ul>
</li>
<li>事件触发线程<ul>
<li>消息队列<ul>
<li>微任务</li>
<li>宏任务</li>
</ul>
</li>
</ul>
</li>
<li>网络异步线程</li>
<li>定时器线程</li>
</ul>
</li>
</ul>
<h3 id="常用的-meta-标签"><a href="#常用的-meta-标签" class="headerlink" title="常用的 meta 标签"></a>常用的 meta 标签</h3><p><a href="https://www.chensheng.group/2018/03/02/59-html5%E5%B8%B8%E7%94%A8%E7%9A%84meta%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93/">点击跳转</a></p>
<h3 id="disabled-和-readonly-的区别？"><a href="#disabled-和-readonly-的区别？" class="headerlink" title="disabled 和 readonly 的区别？"></a>disabled 和 readonly 的区别？</h3><ul>
<li>disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。</li>
<li>readonly 规定输入字段为只读。input 内容会随着表单提交。</li>
<li>无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value</li>
</ul>
<h3 id="扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"><a href="#扫描二维码登录网页是什么原理，前后两个事件是如何联系的？" class="headerlink" title="扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"></a>扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</h3><p>浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server 的帐号信息进行展示。并在客户端点击确认后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。</p>
<h3 id="get-请求传参长度的误区"><a href="#get-请求传参长度的误区" class="headerlink" title="get 请求传参长度的误区"></a>get 请求传参长度的误区</h3><p>误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</p>
<p>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。</p>
<ol>
<li>HTTP 协议未规定 GET 和 POST 的长度限制</li>
<li>GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li>
<li>不同的浏览器和 WEB 服务器，限制的最大长度不一样</li>
<li>要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度8182byte</li>
</ol>
<p>(…未完待续)</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>css高频考题</title>
    <url>/2021/09/01/146-css%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>整理了一下常见的css的问题</p>
</blockquote>
<a id="more"></a>

<h3 id="介绍一下标准的-CSS-的盒子模型"><a href="#介绍一下标准的-CSS-的盒子模型" class="headerlink" title="介绍一下标准的 CSS 的盒子模型"></a>介绍一下标准的 CSS 的盒子模型</h3><ul>
<li>有两种盒子模型：IE 盒模型（border-box）、W3C 标准盒模型（content-box）</li>
<li>盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分</li>
</ul>
<p>IE 盒模型和 W3C 标准盒模型的区别：</p>
<ul>
<li>W3C 标准盒模型：属性 width，height 只包含内容 content，不包含 border 和 padding</li>
<li>IE 盒模型：属性 width，height 包含 content、border 和 padding，指的是 content + padding + border。</li>
</ul>
<blockquote>
<p>如果将 box-sizing 设为 border-box 则用的是 IE 盒模型。</p>
</blockquote>
<h3 id="CSS-选择符有哪些"><a href="#CSS-选择符有哪些" class="headerlink" title="CSS 选择符有哪些?"></a>CSS 选择符有哪些?</h3><ol>
<li>id 选择器（#myid）</li>
<li>类选择器（.myclassname）</li>
<li>标签选择器（div,h1,p）</li>
<li>后代选择器（h1 p）</li>
<li>相邻后代选择器（子）选择器（ul&gt;li）</li>
<li>兄弟选择器（li~a）</li>
<li>相邻兄弟选择器（li+a）</li>
<li>属性选择器（a[rel=”external”]）</li>
<li>伪类选择器（a:hover,li:nth-child）</li>
<li>伪元素选择器（::before、::after）</li>
<li>通配符选择器（*）</li>
</ol>
<h3 id="CSS-中哪些属性可以继承"><a href="#CSS-中哪些属性可以继承" class="headerlink" title="CSS 中哪些属性可以继承"></a>CSS 中哪些属性可以继承</h3><ul>
<li><p>字体系列属性<br>font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</p>
</li>
<li><p>文本系列属性<br>text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color</p>
</li>
<li><p>表格布局属性<br>caption-sideborder-collapseempty-cells</p>
</li>
<li><p>列表属性<br>list-style-type、list-style-image、list-style-position、list-style</p>
</li>
<li><p>光标属性<br>cursor</p>
</li>
<li><p>元素可见性<br>visibility</p>
</li>
</ul>
<h3 id="CSS3-新增伪类有那些"><a href="#CSS3-新增伪类有那些" class="headerlink" title="CSS3 新增伪类有那些?"></a>CSS3 新增伪类有那些?</h3><ul>
<li>elem:nth-child(n)选中父元素下的第 n 个子元素，并且这个子元素的标签名为 elem，n可以接受具体的数值，也可以接受函数。</li>
<li>elem:nth-last-child(n)作用同上，不过是从后开始查找。</li>
<li>elem:last-child 选中最后一个子元素。</li>
<li>elem:only-child 如果 elem 是父元素下唯一的子元素，则选中之。</li>
<li>elem:nth-of-type(n)选中父元素下第 n 个 elem 类型元素，n 可以接受具体的数值，也可以接受函数。</li>
<li>elem:first-of-type 选中父元素下第一个 elem 类型元素。</li>
<li>elem:last-of-type 选中父元素下最后一个 elem 类型元素。</li>
<li>elem:only-of-type 如果父元素下的子元素只有一个 elem 类型元素，则选中该元素。</li>
<li>elem:empty 选中不包含子元素和内容的 elem 类型元素。</li>
<li>elem:target 选择当前活动的 elem 元素。</li>
<li>:not(elem)选择非 elem 元素的每个元素。</li>
<li>:enabled 控制表单控件的禁用状态。</li>
<li>:disabled 控制表单控件的禁用状态。</li>
<li>:checked 单选框或复选框被选中。</li>
</ul>
<h3 id="CSS3-有哪些新特性？"><a href="#CSS3-有哪些新特性？" class="headerlink" title="CSS3 有哪些新特性？"></a>CSS3 有哪些新特性？</h3><ul>
<li>圆角 （border-radius:8px）</li>
<li>多列布局 （multi-column layout）</li>
<li>阴影和反射 （Shadow\Reflect）</li>
<li>文字特效 （text-shadow）</li>
<li>文字渲染 （Text-decoration）</li>
<li>线性渐变 （gradient）</li>
<li>过渡 （transform）缩放，定位，倾斜，动画，多背景</li>
</ul>
<h3 id="解释一下-CSS3-的-Flexbox（弹性盒布局模型）"><a href="#解释一下-CSS3-的-Flexbox（弹性盒布局模型）" class="headerlink" title="解释一下 CSS3 的 Flexbox（弹性盒布局模型）"></a>解释一下 CSS3 的 Flexbox（弹性盒布局模型）</h3><p><a href="https://www.chensheng.group/2018/08/08/62-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E6%B7%B1%E5%85%A5/">弹性布局深入</a></p>
<h3 id="width-auto-和-width-100-的区别"><a href="#width-auto-和-width-100-的区别" class="headerlink" title="width:auto 和 width:100%的区别"></a>width:auto 和 width:100%的区别</h3><ul>
<li><p>width:100%会使元素 box 的宽度等于父元素的 contentbox 的宽度。</p>
</li>
<li><p>width:auto 会使元素撑满整个父元素，margin、border、padding、content 区域会自动分配水平空间。</p>
</li>
</ul>
<h3 id="BFC规范的理解-css中常见的兼容性问题-margin-重叠问题的理解-怎么让-Chrome-支持小于-12px-的文字"><a href="#BFC规范的理解-css中常见的兼容性问题-margin-重叠问题的理解-怎么让-Chrome-支持小于-12px-的文字" class="headerlink" title="BFC规范的理解?css中常见的兼容性问题?margin 重叠问题的理解?怎么让 Chrome 支持小于 12px 的文字?"></a>BFC规范的理解?css中常见的兼容性问题?margin 重叠问题的理解?怎么让 Chrome 支持小于 12px 的文字?</h3><p><a href="https://www.chensheng.group/2018/02/24/55-%E5%85%B3%E4%BA%8ECSS%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/">那些你不知道的CSS</a></p>
<h3 id="CSS-优化、提高性能的方法有哪些"><a href="#CSS-优化、提高性能的方法有哪些" class="headerlink" title="CSS 优化、提高性能的方法有哪些?"></a>CSS 优化、提高性能的方法有哪些?</h3><p>加载性能：</p>
<ol>
<li>css 压缩：将写好的 css 进行打包压缩，可以减少很多的体积。</li>
<li>css 单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bottom;margin-left:left;执行的效率更高。</li>
<li>减少使用@import,而建议使用 link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li>
</ol>
<p>选择器性能：</p>
<ol>
<li>关键选择器（keyselector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS 选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</li>
<li>如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</li>
<li>避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。</li>
<li>尽量少的去对标签进行选择，而是用 class。</li>
<li>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li>
<li>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</li>
</ol>
<p>渲染性能：</p>
<ol>
<li>慎重使用高性能属性：浮动、定位。</li>
<li>尽量减少页面重排、重绘。</li>
<li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少 css 文档体积。</li>
<li>属性值为 0 时，不加单位。</li>
<li>属性值为浮动小数 0.**，可以省略小数点之前的 0。</li>
<li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li>
<li>不使用@import 前缀，它会影响 css 的加载速度。</li>
<li>选择器优化嵌套，尽量避免层级过深。</li>
<li>css 雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li>
<li>正确使用 display 的属性，由于 display 的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li>
<li>不滥用 web 字体。对于中文网站来说 WebFonts 可能很陌生，国外却很流行。webfonts通常体积庞大，而且一些浏览器在下载 webfonts 时会阻塞页面渲染损伤性能。</li>
</ol>
<p>可维护性、健壮性：</p>
<ol>
<li>将具有相同属性的样式抽离出来，整合并通过 class 在页面中进行使用，提高 css 的可维护性。</li>
<li>样式与内容分离：将 css 代码定义到外部 css 中。</li>
</ol>
<blockquote>
<p>上面的选择器性能的第一条,为什么CSS 选择符是从右到左进行匹配的 试想一下，如果采用从左至右的方式读取 CSS 规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配</p>
</blockquote>
<h3 id="在网页中应该使用奇数还是偶数的字体？为什么呢？"><a href="#在网页中应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="在网页中应该使用奇数还是偶数的字体？为什么呢？"></a>在网页中应该使用奇数还是偶数的字体？为什么呢？</h3><ol>
<li>偶数字号相对更容易和 web 设计的其他部分构成比例关系。比如：当我用了 14px 的正文字号，我可能会在一些地方用 14×0.5=7px 的 margin，在另一些地方用 14×1.5=21px 的标题字号。</li>
<li>浏览器缘故，低版本的浏览器 ie6 会把奇数字体强制转化为偶数，即 13px 渲染为 14px。</li>
<li>系统差别，早期的 Windows 里，中易宋体点阵只有 12 和 14、15、16px，唯独缺少 13px。</li>
</ol>
<h3 id="如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>如何修改 chrome 记住密码后自动填充表单的黄色背景？</h3><p>chrome 表单自动填充后，input 文本框的背景会变成黄色的，通过审查元素可以看到这是由于 chrome 会默认给自动填充的 input 表单加上 input:-webkit-autofill 私有属性，然后对其赋予以下样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  background-color:rgb(250,255,189)!important;</span><br><span class="line">  background-image:none!important;</span><br><span class="line">  color:rgb(0,0,0)!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 chrome 默认定义的 background-color，background-image，color 使用 important 是不能提高其优先级的，但是其他属性可使用</p>
<p>使用足够大的纯色内阴影来覆盖 input 输入框的黄色背景，处理如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill&#123;</span><br><span class="line">  -webkit-box-shadow: 000px 1000px white inset;</span><br><span class="line">  border: 1px solid #CCC !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="让页面里的字体变清晰，变细用 CSS 怎么做？"></a>让页面里的字体变清晰，变细用 CSS 怎么做？</h3><p>webkit 内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。</p>
<p>在 MacOS 测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设</p>
<h3 id="使用-rem-布局的优缺点"><a href="#使用-rem-布局的优缺点" class="headerlink" title="使用 rem 布局的优缺点"></a>使用 rem 布局的优缺点</h3><p>优点：<br>在屏幕分辨率千差万别的时代，只要将 rem 与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持 rem 了，兼容性也非常的好。</p>
<p>缺点：</p>
<ol>
<li>在奇葩的 dpr 设备上表现效果不太好，比如一些华为的高端机型用 rem 布局会出现错乱。</li>
<li>使用 iframe 引用也会出现问题。</li>
<li>rem 在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。</li>
</ol>
<p>(…未完待续)</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2021/09/03/147-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>节流与防抖就像重绘和回流一样重要,都是为了提高性能,一直以为博客里面已经写了,结果发现没有,现在补一下</p>
</blockquote>
<a id="more"></a>

<h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h3><p>函数防抖：在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</p>
<p>分解一下需求：</p>
<ul>
<li>持续触发不执行</li>
<li>不触发的一段时间之后再执行</li>
</ul>
<p>我们什么场景下会用到呢</p>
<p>举个例子,我们想要让搜索的输入框输入后,开始查询,调用后端的接口,但是直接监听input的change事件,每按一下键盘,就去调用接口了,但是这个时候,用户其实并没有输入完他的关键字,这个时候,就需要用到函数防抖了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数防抖的实现</span><br><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">  var timer &#x3D; null;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context &#x3D; this,</span><br><span class="line">    args &#x3D; arguments;</span><br><span class="line">    &#x2F;&#x2F; 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置定时器，使事件间隔指定事件后执行</span><br><span class="line">    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h3><p>函数节流：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</p>
<p>分解一下需求：</p>
<ul>
<li>持续触发并不会执行多次</li>
<li>到一定时间再去执行</li>
</ul>
<p>假设,刚刚的那个需求变了,产品发现有一些用户疯狂的敲键盘输入,但是我们的搜索列表就是为空,所以希望每隔一定的时候就要去调用接口,所以当我们监听input的change事件的时候,需要使用到函数节流了,持续触发不会执行,但是到了一定的时间就会开始执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数节流的实现;</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  var preTime &#x3D; Date.now();</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context &#x3D; this,</span><br><span class="line">    args &#x3D; arguments,</span><br><span class="line">    nowTime &#x3D; Date.now();</span><br><span class="line">    &#x2F;&#x2F; 如果两次时间间隔超过了指定时间，则执行函数。</span><br><span class="line">    if (nowTime - preTime &gt;&#x3D; delay) &#123;</span><br><span class="line">      preTime &#x3D; Date.now();</span><br><span class="line">      return fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
</blockquote>
<blockquote>
<p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p>
</blockquote>
<p>以上就是我对防抖和节流的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>微信开发学习</title>
    <url>/2021/10/07/148-%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>简单的介绍一下微信开发的一些注意事项</p>
</blockquote>
<a id="more"></a>

<p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html#1" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="什么是OpenID-UnionID"><a href="#什么是OpenID-UnionID" class="headerlink" title="什么是OpenID,UnionID"></a>什么是OpenID,UnionID</h3><p>做微信开发,绕不过两个名词 OpenID,UnionID</p>
<ul>
<li>OpenID</li>
</ul>
<p>获取OpenID是我们在做微信开发必须要做的一件事情,OpenID就理解成用户的唯一标识</p>
<ul>
<li>UnionID</li>
</ul>
<p>如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下<br>绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，<br>只有一个UnionID，可以在用户管理-获取用户基本信息（UnionID机制）</p>
<h3 id="什么是Access-token"><a href="#什么是Access-token" class="headerlink" title="什么是Access token"></a>什么是Access token</h3><p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。</p>
<p>公众号和小程序均可以使用AppID和AppSecret调用本接口来获取access_token。AppID和AppSecret可在“微信公众平台-开发-基本配置”页中获得。</p>
<p>调用接口时，请登录“微信公众平台-开发-基本配置”提前将服务器IP地址添加到IP白名单中，点击查看设置方法，否则将无法调用成功。</p>
<h3 id="网页授权-公众号"><a href="#网页授权-公众号" class="headerlink" title="网页授权(公众号)"></a>网页授权(公众号)</h3><p>接下来看看如何授权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let link &#x3D; window.location.href;</span><br><span class="line">let appid &#x3D; &#39;appid&#39;;</span><br><span class="line">let uri &#x3D; encodeURIComponent(link);</span><br><span class="line">let authURL &#x3D; &#96;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorize?appid&#x3D;$&#123;appid&#125;&amp;redirect_uri&#x3D;$&#123;uri&#125;&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_userinfo&amp;state&#x3D;123#wechat_redirect&#96;;</span><br><span class="line">window.location.href &#x3D; authURL;</span><br></pre></td></tr></table></figure>

<p>通过代码可以看出,公众号使用跳转的方式进行网页授权,获取到用户的code,后端通过code,获取用户的openid</p>
<blockquote>
<p>关于网页授权的两种scope的区别说明</p>
</blockquote>
<ol>
<li><p>以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）</p>
</li>
<li><p>以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</p>
</li>
<li><p>用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p>
</li>
</ol>
<blockquote>
<p>关于特殊场景下的静默授权</p>
</blockquote>
<p>为什么我们的项目,使用的是snsapi_userinfo,也没有弹出授权?</p>
<ol>
<li><p>上面已经提到，对于以snsapi_base为scope的网页授权，就静默授权的，用户无感知；</p>
</li>
<li><p>对于已关注公众号的用户，如果用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是scope为snsapi_userinfo，也是静默授权，用户无感知。</p>
</li>
</ol>
<p>对于公众号授权步骤,分为四步</p>
<ol>
<li><p>引导用户进入授权页面同意授权，获取code</p>
</li>
<li><p>通过code换取网页授权access_token（与基础支持中的access_token不同）</p>
</li>
<li><p>如果需要，开发者可以刷新网页授权access_token，避免过期</p>
</li>
<li><p>通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）</p>
</li>
</ol>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>这里强调一下开发中可能会遇到的问题</p>
<ul>
<li>回调的链接问题</li>
</ul>
<ol>
<li><p>若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。</p>
</li>
<li><p>由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问</p>
</li>
<li><p>跳转回调redirect_uri，应当使用https链接来确保授权code的安全性。</p>
</li>
<li><p>回调的链接不支持 hash模式,需要做特殊处理</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let href &#x3D; &#39;&#39;;</span><br><span class="line">const w &#x3D; location.href.indexOf(&#39;?&#39;);</span><br><span class="line">const j &#x3D; location.href.indexOf(&#39;#&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理微信回调url, 重新获取code</span><br><span class="line">if (w !&#x3D;&#x3D; -1 &amp;&amp; j &gt; w) &#123;</span><br><span class="line">  href &#x3D; location.href.substr(0, w) + location.href.substr(j, location.href.length) + location.search.replace(&#x2F;\?&#x2F;, &quot;&amp;&quot;);</span><br><span class="line">  location.href &#x3D; href;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取access_token问题</li>
</ul>
<ol>
<li><p>通过code获取access_token,微信公众号配置IP白名单,才可以进行请求</p>
</li>
<li><p>由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起。</p>
</li>
</ol>
<h4 id="拉取用户信息-需scope为-snsapi-userinfo"><a href="#拉取用户信息-需scope为-snsapi-userinfo" class="headerlink" title="拉取用户信息(需scope为 snsapi_userinfo)"></a>拉取用户信息(需scope为 snsapi_userinfo)</h4><p>如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了。</p>
<p>到这里,公众号完成了基本的网页授权</p>
<h3 id="公众号使用微信JS-SDK"><a href="#公众号使用微信JS-SDK" class="headerlink" title="公众号使用微信JS-SDK"></a>公众号使用微信JS-SDK</h3><p>JSSDK使用步骤</p>
<h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。</p>
<p>备注：登录后可在“开发者中心”查看对应的接口权限。</p>
<h4 id="引入JS文件"><a href="#引入JS文件" class="headerlink" title="引入JS文件"></a>引入JS文件</h4><ol>
<li><p>在需要调用JS接口的页面引入如下JS文件，（支持https）：<a href="http://res.wx.qq.com/open/js/jweixin-1.6.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.6.0.js</a></p>
</li>
<li><p>也可以直接导入npm包<br>首先安装 weixin-js-sdk, 之后引入进来 import wx from ‘weixin-js-sdk’</p>
</li>
<li><p>也可以使用微信浏览器自带的方法(WeixinJSBridge)</p>
</li>
</ol>
<h4 id="通过config接口注入权限验证配置"><a href="#通过config接口注入权限验证配置" class="headerlink" title="通过config接口注入权限验证配置"></a>通过config接口注入权限验证配置</h4><p>所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">  debug: true, &#x2F;&#x2F; 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">  appId: &#39;&#39;, &#x2F;&#x2F; 必填，公众号的唯一标识</span><br><span class="line">  timestamp: , &#x2F;&#x2F; 必填，生成签名的时间戳</span><br><span class="line">  nonceStr: &#39;&#39;, &#x2F;&#x2F; 必填，生成签名的随机串</span><br><span class="line">  signature: &#39;&#39;,&#x2F;&#x2F; 必填，签名</span><br><span class="line">  jsApiList: [] &#x2F;&#x2F; 必填，需要使用的JS接口列表</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="通过ready接口处理成功验证"><a href="#通过ready接口处理成功验证" class="headerlink" title="通过ready接口处理成功验证"></a>通过ready接口处理成功验证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.ready(function()&#123;</span><br><span class="line">  &#x2F;&#x2F; config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="通过error接口处理失败验证"><a href="#通过error接口处理失败验证" class="headerlink" title="通过error接口处理失败验证"></a>通过error接口处理失败验证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.error(function(res)&#123;</span><br><span class="line">  &#x2F;&#x2F; config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>到这里,微信公众号的JS-SDK就可以正常使用了,分享功能,音频接口,指纹识别,微信支付等可以在其他的博客看到使用的详细方法,更多的可以看看官方文档</p>
<h3 id="小程序授权-微信小程序"><a href="#小程序授权-微信小程序" class="headerlink" title="小程序授权(微信小程序)"></a>小程序授权(微信小程序)</h3><p>在说到小程序之前,先说一下它和公众号的区别</p>
<p>网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作.</p>
<p>而小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。</p>
<h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><p>各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的：</p>
<p>在 iOS、iPadOS 和 Mac OS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，环境有 iOS 14、iPad OS 14、Mac OS 11.4 等；<br>在 Android 上，小程序逻辑层的 javascript 代码运行在 V8 中，视图层是由基于 Mobile Chrome 内核的自研 XWeb 引擎来渲染的；<br>在 Windows 上，小程序逻辑层 javascript 和视图层 javascript 都是用 Chrome 内核；<br>在 开发工具上，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium Webview 来渲染的。</p>
<table>
<thead>
<tr>
<th>运行环境</th>
<th>逻辑层</th>
<th>渲染层</th>
</tr>
</thead>
<tbody><tr>
<td>iOS</td>
<td>JavaScriptCore</td>
<td>WKWebView</td>
</tr>
<tr>
<td>安卓</td>
<td>V8</td>
<td>chromium定制内核</td>
</tr>
<tr>
<td>小程序开发者工具</td>
<td>NWJS</td>
<td>Chrome WebView</td>
</tr>
</tbody></table>
<p>由于视图渲染的方式不一致,还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现</p>
<p>除了样式的差异,在js上也有一定的区别</p>
<h5 id="Promise-时序差异"><a href="#Promise-时序差异" class="headerlink" title="Promise 时序差异"></a>Promise 时序差异</h5><p>由于实现原因与 iOS JavaScriptCore 限制，iOS 环境下的 Promise 是一个使用 setTimeout 模拟的 Polyfill。这意味着 Promise 触发的任务为普通任务，而非微任务，进而导致 在 iOS 下的 Promise 时序会和标准存在差异。</p>
<blockquote>
<p>具体的宏任务和微任务的差别,这里不细讲了,博客的其他文章中有</p>
</blockquote>
<h4 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h4><p>回归正传,看看小程序的授权流程,上图</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg" alt="登录流程时序"></p>
<p>微信小程序的登录比较简单,简单来说只有几步</p>
<ol>
<li>调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。</li>
<li>调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 、用户在微信开放平台帐号下的唯一标识UnionID 和 会话密钥 session_key。</li>
</ol>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>部分接口需要经过用户授权同意才能调用。我们把这些接口按使用范围分成多个scope，用户选择对scope来进行授权，当授权给一个 scope 之后，其对应的所有接口都可以直接使用。</p>
<table>
<thead>
<tr>
<th>scope</th>
<th>对应接口</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>scope.userInfo</td>
<td>wx.getUserInfo</td>
<td>用户信息</td>
</tr>
<tr>
<td>scope.userLocation</td>
<td>wx.getLocation, wx.chooseLocation</td>
<td>地理位置</td>
</tr>
<tr>
<td>scope.userLocationBackground</td>
<td>wx.startLocationUpdateBackground</td>
<td>后台定位</td>
</tr>
<tr>
<td>scope.werun</td>
<td>wx.getWeRunData</td>
<td>微信运动步数</td>
</tr>
<tr>
<td>scope.record</td>
<td>wx.startRecord</td>
<td>录音功能</td>
</tr>
<tr>
<td>scope.writePhotosAlbum</td>
<td>wx.saveImageToPhotosAlbum, wx.saveVideoToPhotosAlbum</td>
<td>保存到相册</td>
</tr>
<tr>
<td>scope.camera</td>
<td>camera 组件</td>
<td>保存到相册</td>
</tr>
</tbody></table>
<p>此类接口调用时：</p>
<ul>
<li>如果用户未接受，会弹窗询问用户，用户点击同意后方可调用接口；</li>
<li>如果用户已授权，可以直接调用接口；</li>
<li>如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口 fail 回调。请开发者兼容用户拒绝授权的场景。</li>
</ul>
<p>开发者可以使用 wx.getSetting 获取用户当前的授权状态。然后判断用户是否拒绝授权,弹窗二次提醒用户是否授权,开发者可以调用 wx.openSetting 打开设置界面，引导用户开启授权。</p>
<p><a href="https://developers.weixin.qq.com/community/develop/doc/000cea2305cc5047af5733de751008" target="_blank" rel="noopener">openSetting接口调整</a><br><a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserProfile.html#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">getUserInfo接口调整</a><br><a href="https://developers.weixin.qq.com/community/develop/doc/000aee91a98d206bc6dbe722b51801" target="_blank" rel="noopener">getLocation接口调整</a></p>
<blockquote>
<p>需要注意的是, getUserProfile获取用户昵称头像等,需要用户手动触发,每次调用都会弹窗</p>
</blockquote>
<h4 id="获取手机号"><a href="#获取手机号" class="headerlink" title="获取手机号"></a>获取手机号</h4><p>因为需要用户主动触发才能发起获取手机号接口，所以该功能不由 API 来调用，需用 button 组件的点击来触发。</p>
<p>需要将 button 组件 open-type 的值设置为 getPhoneNumber，当用户点击并同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据， 然后在第三方服务端结合 session_key 以及 app_id 进行解密获取手机号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button open-type&#x3D;&quot;getPhoneNumber&quot; bindgetphonenumber&#x3D;&quot;getPhoneNumber&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">getPhoneNumber (e) &#123;</span><br><span class="line">  console.log(e.detail.errMsg)</span><br><span class="line">  console.log(e.detail.iv)</span><br><span class="line">  console.log(e.detail.encryptedData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取到的加密数据给到后端,获取手机号</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在回调中调用 wx.login 登录，可能会刷新登录态。此时服务器使用 code 换取的 sessionKey 不是加密时使用的 sessionKey，导致解密失败。建议开发者提前进行 login；或者在回调中先使用 checkSession 进行登录态检查，避免 login 刷新登录态。</p>
</blockquote>
<h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><p>上传图片,下载,地图等功能,需要服务器配置安全域名</p>
<blockquote>
<p>地图有的时候需要用到<code>https://apis.map.qq.com</code>,也要配置域名</p>
</blockquote>
<p>如果项目中有用到web-view组件,H5的链接需要配置业务域名,配置时校验文件需要放在域名的根目录</p>
<h4 id="服务器域名配置"><a href="#服务器域名配置" class="headerlink" title="服务器域名配置"></a>服务器域名配置</h4><p>服务器域名请在 「小程序后台-开发-开发设置-服务器域名」 中进行配置，配置时需要注意：</p>
<ul>
<li>域名只支持 https (wx.request、wx.uploadFile、wx.downloadFile) 和 wss (wx.connectSocket) 协议；</li>
<li>域名不能使用 IP 地址（小程序的局域网 IP 除外）或 localhost；</li>
<li>域名必须经过 ICP 备案；</li>
<li>出于安全考虑，api.weixin.qq.com 不能被配置为服务器域名，相关API也不能在小程序内调用。 开发者应将 AppSecret 保存到后台服务器中，通过服务器使用 getAccessToken 接口获取 access_token，并调用相关 API；</li>
<li>不支持配置父域名，使用子域名。</li>
</ul>
<h4 id="HTTPS-证书"><a href="#HTTPS-证书" class="headerlink" title="HTTPS 证书"></a>HTTPS 证书</h4><p>小程序必须使用 HTTPS/WSS 发起网络请求。请求时系统会对服务器域名使用的 HTTPS 证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议开发者按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。</p>
<p>对证书要求如下：</p>
<ul>
<li>HTTPS 证书必须有效；<ul>
<li>证书必须被系统信任，即根证书被已系统内置</li>
<li>部署 SSL 证书的网站域名必须与证书颁发的域名一致</li>
<li>证书必须在有效期内</li>
<li>证书的信任链必需完整（需要服务器配置）</li>
</ul>
</li>
<li>iOS 不支持自签名证书;</li>
<li>iOS 下证书必须满足苹果 App Transport Security (ATS) 的要求;</li>
<li>TLS 必须支持 1.2 及以上版本。部分旧 Android 机型还未支持 TLS 1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;</li>
<li>部分 CA 可能不被操作系统信任，请开发者在选择证书时注意小程序和各系统的相关通告。<ul>
<li>Chrome 56/57 内核对 WoSign、StartCom 证书限制周知</li>
</ul>
</li>
</ul>
<p>(…未完待续)</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2021/11/01/149-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>一起学习一下函数柯里化,感谢百度上各位大佬们的无私奉献</p>
</blockquote>
<a id="more"></a>

<h3 id="什么是柯里化"><a href="#什么是柯里化" class="headerlink" title="什么是柯里化"></a>什么是柯里化</h3><p>柯里化，是函数式编程的一个重要概念。它既能减少代码冗余，也能增加可读性。另外，附带着还能用来装逼。</p>
<p>先给出柯里化的定义：在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<p>理论上的东西总是抽象的,直接看最简单的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 普通的add函数</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Currying后</span><br><span class="line">function curryingAdd(x) &#123;</span><br><span class="line">  return function (y) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 2)           &#x2F;&#x2F; 3</span><br><span class="line">curryingAdd(1)(2)   &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上就是把add函数的x，y两个参数变成了先用一个函数接收x然后返回一个函数去处理y参数。现在思路应该就比较清晰了，就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
</blockquote>
<p>例如有一个简单的加法函数，他能够将自身的三个参数加起来并返回计算结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a, b, c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么add函数的柯里化函数_add则可以如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function _add(a) &#123;</span><br><span class="line">    return function(b) &#123;</span><br><span class="line">        return function(c) &#123;</span><br><span class="line">            return a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的运算方式是等价的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(1, 2, 3);</span><br><span class="line">_add(1)(2)(3);</span><br></pre></td></tr></table></figure>

<p>靠眼力封装的柯里化函数自由度偏低，柯里化通用式具备更加强大的能力。因此我们需要知道如何去封装这样一个柯里化的通用式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 简单实现，参数只能从右到左传递</span><br><span class="line">function curry(fn, args) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取函数需要的参数长度</span><br><span class="line">  let length &#x3D; fn.length;</span><br><span class="line">  args &#x3D; args || [];</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let subArgs &#x3D; args.slice(0);</span><br><span class="line">    &#x2F;&#x2F; 拼接得到现有的所有参数</span><br><span class="line">    for (let i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">      subArgs.push(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 判断参数的长度是否已经满足函数所需参数的长度</span><br><span class="line">    if (subArgs.length &gt;&#x3D; length) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果满足，执行函数</span><br><span class="line">      return fn.apply(this, subArgs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果不满足，递归返回科里化的函数，等待参数的传入</span><br><span class="line">      &#x2F;&#x2F; 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span><br><span class="line">      return curry.call(this, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用es6的语法,就更简单了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">  return fn.length &lt;&#x3D; args.length ? fn(...args) : curry.bind(null,fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是我对函数柯里化的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie与Storage的使用</title>
    <url>/2017/01/15/15-cookie%E4%B8%8EStorage%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>很多小伙伴都知道，本地存储用的大多数是cookie,还有用的是sessionStorage和localStorage,当时他们具体是怎么使用的呢，又有哪些区别？</p>
</blockquote>
<a id="more"></a>

<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>一、 使用cookie(cookie存储大小约4K)</p>
<pre><code>在使用cookie之前首先导入 jquery.js 和 jquery.cookie.js 文件，</code></pre><p>二、 DOM 原生方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存:</span></span><br><span class="line">	<span class="built_in">document</span>.cookie = <span class="string">'name=小白'</span>;		</span><br><span class="line"><span class="comment">//取:</span></span><br><span class="line">	<span class="built_in">document</span>.cookie.split(<span class="string">";"</span>)[<span class="number">0</span>].split(<span class="string">"="</span>)[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>三、 jquery 方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存:</span></span><br><span class="line">	$.cookie(<span class="string">'name'</span>,<span class="string">'小白'</span>,&#123;<span class="attr">expires</span>:n&#125;);</span><br><span class="line"><span class="comment">//取:</span></span><br><span class="line">	$.cookie(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure>

<p>注意:第三个参数可以是{expires:n},表示存储多少天,否则关闭浏览器后消失</p>
<h4 id="使用cookie的弊端"><a href="#使用cookie的弊端" class="headerlink" title="使用cookie的弊端"></a>使用cookie的弊端</h4><ol>
<li><p>Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。</p>
</li>
<li><p>安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p>
</li>
<li><p>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p>
</li>
</ol>
<h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><h4 id="sessionStorage的使用-大小约为5MB"><a href="#sessionStorage的使用-大小约为5MB" class="headerlink" title="sessionStorage的使用    (大小约为5MB)"></a>sessionStorage的使用    (大小约为5MB)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存:</span></span><br><span class="line">	sessionStorage.setItem(<span class="string">"name"</span>,<span class="string">"白白"</span>);</span><br><span class="line"><span class="comment">//取:</span></span><br><span class="line">	sessionStorage为一个对象，可以打点取值</span><br><span class="line">	<span class="built_in">console</span>.log(sessionStorage.name);</span><br><span class="line">	<span class="built_in">console</span>.log(sessionStorage.getItem(<span class="string">"name"</span>));</span><br><span class="line">	</span><br><span class="line"><span class="comment">//查看存储个数：</span></span><br><span class="line">	sessionStorage.lenght</span><br><span class="line"><span class="comment">//删除单个:</span></span><br><span class="line">	sessionStorage.removeItem(<span class="string">"name"</span>)</span><br><span class="line"><span class="comment">//清空所有:</span></span><br><span class="line">	sessionStorage.clear();</span><br><span class="line"><span class="comment">//循环输出:</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> sessionStorage)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(sessionStorage[i])			</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//可以用JSON进行转化,否则只能存取字符串:------可以进行封装</span></span><br><span class="line">	sessionStorage.setItem(<span class="string">"obj"</span>,<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>:<span class="number">10</span>,<span class="attr">b</span>:<span class="number">20</span>&#125;));</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(sessionStorage.getItem(<span class="string">"obj"</span>)));</span><br></pre></td></tr></table></figure>

<h4 id="localStorage的使用-本地储存"><a href="#localStorage的使用-本地储存" class="headerlink" title="localStorage的使用(本地储存)"></a>localStorage的使用(本地储存)</h4><pre><code>有效期-除非手动清除,否则会一直存在，同一个域使用

localStorage 与    sessionStorage     的使用方法一样</code></pre><h3 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h3><pre><code>首先npm init 和 express

第一步：html里manifest  设置离线文件
    &lt;html manifest=&quot;index.manifest&quot;&gt;~~~=号里的是文件的名字

第二步:配置index.manifest文件

    CACHE MANIFEST # 这句一定要写    #是注释符号

    # 2017-08-23    v1.0.0

    # 缓存文件列表-----缓存什么就写什么
    CACHE：
    index.html
    images/0.jpg
    jquery/jquery.js
    js/Music.js
    mp3/click.mp3 

    # 不缓存的文件列表
    NETWORK:
    index.manifest 

    # 离线失败时显示的页面
    FALLBACK:
    html/index.html


第三步:
    文件改变，用户不会手动清缓存,如果index.manifest 文件发生改变，会自动执行下面监听方法</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.applicationCache.addEventListener(<span class="string">'updateready'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'改变了'</span>)</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">window</span>.applicationCache.status == <span class="built_in">window</span>.applicationCache.UPDATEREADY)&#123;</span><br><span class="line">		<span class="keyword">if</span>(confirm(<span class="string">'新版本发布了，是否现在更新最新版本'</span>))&#123;</span><br><span class="line">			<span class="comment">//更新替换缓存</span></span><br><span class="line">			<span class="built_in">window</span>.applicationCache.update();</span><br><span class="line">			<span class="comment">//刷新页面</span></span><br><span class="line">			<span class="built_in">window</span>.location.reload()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充一个MD5加密</p>
</blockquote>
<pre><code>//首先要有md5.js
var name = hex_md5(&quot;陈晟&quot;);
//得到一串乱码，不能逆向</code></pre><p>以上就是我对Cookie的一些理解,不足之处希望大牛们多提一些意见,感激不尽</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Storage</tag>
      </tags>
  </entry>
  <entry>
    <title>手写Promise</title>
    <url>/2021/11/01/150-%E6%89%8B%E5%86%99promise/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Promise我们都很熟悉了,也都会使用了,如果自己实现一个promise,要怎么做</p>
</blockquote>
<a id="more"></a>

<p>不做解释了,代码里面都有注释,直接上代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PENDING &#x3D; &quot;pending&quot;;</span><br><span class="line">const RESOLVED &#x3D; &quot;resolved&quot;;</span><br><span class="line">const REJECTED &#x3D; &quot;rejected&quot;;</span><br><span class="line"></span><br><span class="line">function MyPromise(fn) &#123;</span><br><span class="line">  &#x2F;&#x2F; 保存初始化状态</span><br><span class="line">  var self &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 初始化状态</span><br><span class="line">  this.state &#x3D; PENDING;</span><br><span class="line">  &#x2F;&#x2F; 用于保存 resolve 或者 rejected 传入的值</span><br><span class="line">  this.value &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 用于保存 resolve 的回调函数</span><br><span class="line">  this.resolvedCallbacks &#x3D; [];</span><br><span class="line">  &#x2F;&#x2F; 用于保存 reject 的回调函数</span><br><span class="line">  this.rejectedCallbacks &#x3D; [];</span><br><span class="line">  &#x2F;&#x2F; 状态转变为 resolved 方法</span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br><span class="line">    if (value instanceof MyPromise) &#123;</span><br><span class="line">      return value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 只有状态为 pending 时才能转变，</span><br><span class="line">      if (self.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        &#x2F;&#x2F; 修改状态</span><br><span class="line">        self.state &#x3D; RESOLVED;</span><br><span class="line">        &#x2F;&#x2F; 设置传入的值</span><br><span class="line">        self.value &#x3D; value;</span><br><span class="line">        &#x2F;&#x2F; 执行回调函数</span><br><span class="line">        self.resolvedCallbacks.forEach(callback &#x3D;&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 状态转变为 rejected 方法</span><br><span class="line">  function reject(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 只有状态为 pending 时才能转变</span><br><span class="line">      if (self.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        &#x2F;&#x2F; 修改状态</span><br><span class="line">        self.state &#x3D; REJECTED;</span><br><span class="line">        &#x2F;&#x2F; 设置传入的值</span><br><span class="line">        self.value &#x3D; value;</span><br><span class="line">        &#x2F;&#x2F; 执行回调函数</span><br><span class="line">        self.rejectedCallbacks.forEach(callback &#x3D;&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 将两个方法传入函数执行</span><br><span class="line">  try &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    &#x2F;&#x2F; 遇到错误时，捕获错误，执行 reject 函数</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then &#x3D; function(onResolved, onRejected) &#123;</span><br><span class="line">  &#x2F;&#x2F; 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br><span class="line">  onResolved &#x3D;</span><br><span class="line">    typeof onResolved &#x3D;&#x3D;&#x3D; &quot;function&quot; ?</span><br><span class="line">    onResolved :</span><br><span class="line">    function(value) &#123;</span><br><span class="line">      return value;</span><br><span class="line">    &#125;;</span><br><span class="line">  onRejected &#x3D;</span><br><span class="line">    typeof onRejected &#x3D;&#x3D;&#x3D; &quot;function&quot; ?</span><br><span class="line">    onRejected :</span><br><span class="line">    function(error) &#123;</span><br><span class="line">      throw error;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#x2F;&#x2F; 如果是等待状态，则将函数加入对应列表中</span><br><span class="line">  if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">    this.resolvedCallbacks.push(onResolved);</span><br><span class="line">    this.rejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 如果状态已经凝固，则直接执行对应状态的函数</span><br><span class="line">  if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">    onResolved(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;</span><br><span class="line">    onRejected(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码忘记是从哪里copy来的,感谢大佬们的分享</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端网络安全</title>
    <url>/2021/11/02/151-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>项目都是用的vue的框架,输入框之类的都已经帮我们做了大部分的安全处理,但是还是要了解一下</p>
</blockquote>
<a id="more"></a>

<p><a href="https://www.jianshu.com/p/233874b6de0d" target="_blank" rel="noopener">原文链接</a></p>
<p>网络安全是前端工程师需要考虑的问题，大多数我们会面对以下几点</p>
<ul>
<li>什么是 XSS 攻击？如何防范 XSS 攻击？</li>
<li>内容安全策略csp</li>
<li>什么是 CSRF 攻击？如何防范 CSRF 攻击？</li>
<li>什么是点击劫持？如何防范点击劫持？</li>
<li>SQL 注入攻击？</li>
</ul>
<h3 id="1-XSS"><a href="#1-XSS" class="headerlink" title="1. XSS"></a>1. XSS</h3><p>XSS，Cross-site script，跨站脚本攻击。是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</p>
<p>它可以分为两类：反射型和持久型。</p>
<ul>
<li>反射型XSS攻击场景：用户点击嵌入恶意脚本的链接，攻击者可以获取用户的cookie信息或密码等重要信息，进行恶性操作。</li>
</ul>
<blockquote>
<p>解决：开启cookie的HttpOnly属性，禁止JavaScript脚本读取cookie信息。</p>
</blockquote>
<ul>
<li>持久型XSS攻击场景：攻击者提交含有恶意脚本的请求（通常使用<script>标签），此脚本被保存在数据库中。用户再次浏览页面，包含恶意脚本的页面会自动执行脚本，从而达到攻击效果。这种攻击常见于论坛，博客等应用中。</li>
</ul>
<blockquote>
<p>解决：前端提交请求时，转义<为&lt，转义>为&gt；或者后台存储数据时进行特殊字符转义。</p>
</blockquote>
<h3 id="3-CSRF"><a href="#3-CSRF" class="headerlink" title="3.CSRF"></a>3.CSRF</h3><p>CSRF，Cross-site request forgery，跨站请求伪造。这种方式是利用浏览器的cookie或服务器的session策略，盗取用户信息，模拟用户向第三方网站发送恶意请求。</p>
<blockquote>
<p>再次强调一下cookie的机制：浏览器向一个域名发起http请求时（GET请求）会带上浏览器保存的关于那个域名的cookies，而不管你从哪个网站发请求。</p>
</blockquote>
<p>解决方法: </p>
<ol>
<li>同源检测</li>
</ol>
<p>既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。可以通过origin header或者referer header判断请求源.</p>
<ol start="2">
<li>CSRF token验证</li>
</ol>
<p>提交请求中携带token，并且每次请求的token值都是合法的随机数</p>
<ol start="3">
<li>开启cookie SameSite 强校验</li>
</ol>
<p>Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪。</p>
<h3 id="4-网络请求劫持"><a href="#4-网络请求劫持" class="headerlink" title="4. 网络请求劫持"></a>4. 网络请求劫持</h3><p>请求劫持是指网站资源在请求过程中因为人为原因而没有加载到正确的资源。</p>
<ul>
<li>DNS劫持</li>
</ul>
<p>在浏览器输入URL，浏览器完成连接准备之后，第一件事情就是DNS查询。如果本地没有缓存，那么需要向DNS服务商请求该域名的IP地址。这个过程中如果发生恶意劫持，都导致正确的网址不能得到正确解析，且用户可能访问了一个非法服务器获取到恶意资源。</p>
<blockquote>
<p>解决方案：DNS over HTTP（用 HTTP 协议来传输 DNS ）</p>
</blockquote>
<ul>
<li>HTTP劫持</li>
</ul>
<p>在用户浏览器和目标服务器之间建立的网络数据传输通道中的任何环节，比如，网关，防火墙等，发生的恶意劫持。从而在用户浏览器上展示了广告或其他内容（常见插入iframe）。最可能的劫持方就是ISP（internet service provider互联网服务商）。</p>
<blockquote>
<p>解决方案: 改为https</p>
</blockquote>
<h3 id="5-SQL注入"><a href="#5-SQL注入" class="headerlink" title="5.SQL注入"></a>5.SQL注入</h3><p>攻击者在HTTP请求中注入恶意SQL命令，例如，drop table users，服务器用请求参数构造数据库SQL命令时，恶意SQL被执行。</p>
<blockquote>
<p>解决：后台处理，例如，使用预编译语句PreparedStatement进行预处理。</p>
</blockquote>
<p>感谢大佬们的无私分享</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>uni-app使用echart</title>
    <url>/2021/11/02/152-uni-app%E4%BD%BF%E7%94%A8echart/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>echart我们在web端都使用过很多次了,看看在uni-app的项目中要怎么使用echart</p>
</blockquote>
<a id="more"></a>

<p>uni-app推荐使用uchart,但是个人认为没有echart的功能多,所以还是想要用echart来实现</p>
<p>一开始的时候,我以为和web端一样,正常的引入进来就可以使用了,打开浏览器调试一下,完美,真机运行发现,一片空白</p>
<p>百度之后发现,运行的平台不一样,渲染层也不同,所以针对不同的运行环境,需要不同的方法</p>
<p>上代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;view class&#x3D;&quot;trend-box&quot; style&#x3D;&quot;height: 415rpx;&quot;&gt;</span><br><span class="line">      &lt;!-- #ifdef  MP-WEIXIN --&gt;</span><br><span class="line">      &lt;uniEcCanvas class&#x3D;&quot;uni-ec-canvas&quot; :force-use-old-canvas&#x3D;&quot;true&quot; canvas-id&#x3D;&quot;multi-charts-bar&quot; :ec&#x3D;&quot;dealEc&quot;&gt;&lt;&#x2F;uniEcCanvas&gt;</span><br><span class="line">      &lt;!-- #endif --&gt;</span><br><span class="line">      &lt;!-- #ifdef H5||APP-PLUS --&gt;</span><br><span class="line">      &lt;h5echart style&#x3D;&quot;height: 100%&quot; :option&#x3D;&quot;dealEc.option&quot;&gt;&lt;&#x2F;h5echart&gt;</span><br><span class="line">      &lt;!-- #endif --&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt; </span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import uniEcCanvas from &#39;@&#x2F;components&#x2F;uni-ec-canvas&#x2F;uni-ec-canvas&#39;</span><br><span class="line">  import h5echart from &#39;@&#x2F;components&#x2F;h5-echart&#x2F;echarts.vue&#39;</span><br><span class="line">	export default &#123;</span><br><span class="line">		components: &#123;</span><br><span class="line">			uniEcCanvas,</span><br><span class="line">      h5echart</span><br><span class="line">		&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用法和echart一样的,需要注意的是,一个入参传入option,一个传入整个数据</p>
</blockquote>
<h3 id="ec-canvas"><a href="#ec-canvas" class="headerlink" title="ec-canvas"></a>ec-canvas</h3><p>这个组件是为了适配小程序的</p>
<p>首先，下载 GitHub 上的 <a href="https://github.com/ecomfe/echarts-for-weixin%5D" target="_blank" rel="noopener">ecomfe/echarts-for-weixin</a> 项目。</p>
<p>ec-canvas 目录下有一个 echarts.js，可以改成自己需要的。</p>
<h3 id="h5-echart"><a href="#h5-echart" class="headerlink" title="h5-echart"></a>h5-echart</h3><p>因为APP上没有办法操作dom,所以需要设置 script 节点的 lang 为 renderjs,在视图层操作dom</p>
<p>大致的用法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script module&#x3D;&quot;echarts&quot; lang&#x3D;&quot;renderjs&quot;&gt;</span><br><span class="line">    let myChart</span><br><span class="line">    export default &#123;</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            if (typeof window.echarts &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                myChart &#x3D; echarts.init(document.getElementById(&#39;echarts&#39;))</span><br><span class="line">                &#x2F;&#x2F; 观测更新的数据在 view 层可以直接访问到</span><br><span class="line">                myChart.setOption(this.option)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 动态引入较大类库避免影响页面展示</span><br><span class="line">                const script &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line">                &#x2F;&#x2F; view 层的页面运行在 www 根目录，其相对路径相对于 www 计算</span><br><span class="line">                script.src &#x3D; &#39;static&#x2F;echarts.js&#39;</span><br><span class="line">                &#x2F;&#x2F;script标签的onload事件都是在外部js文件被加载完成并执行完成后才被触发的</span><br><span class="line">                script.onload &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">                    myChart &#x3D; echarts.init(document.getElementById(&#39;echarts&#39;),)</span><br><span class="line">                    myChart.setOption(this.option)</span><br><span class="line">                &#125;</span><br><span class="line">                document.head.appendChild(script)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这两个插件上百度搜都有,没有找到的,可以去我的网盘上下载</p>
<p>链接: <a href="https://pan.baidu.com/s/12jNg3Qs53Gl1PcNFGyFUlA" target="_blank" rel="noopener">https://pan.baidu.com/s/12jNg3Qs53Gl1PcNFGyFUlA</a> </p>
<p>是我对uni-app使用echart的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js高频考题</title>
    <url>/2021/11/02/153-js%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>整理了一下常见的js的问题</p>
</blockquote>
<a id="more"></a>

<h2 id="1-10"><a href="#1-10" class="headerlink" title="1~10"></a>1~10</h2><h3 id="JavaScript-有几种类型的值-你能简单说一下他们的区别吗"><a href="#JavaScript-有几种类型的值-你能简单说一下他们的区别吗" class="headerlink" title="JavaScript 有几种类型的值? 你能简单说一下他们的区别吗?"></a>JavaScript 有几种类型的值? 你能简单说一下他们的区别吗?</h3><ul>
<li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
</ul>
<p>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。</p>
<h3 id="JavaScript-原型，原型链-有什么特点"><a href="#JavaScript-原型，原型链-有什么特点" class="headerlink" title="JavaScript 原型，原型链? 有什么特点?"></a>JavaScript 原型，原型链? 有什么特点?</h3><p><a href="https://www.chensheng.group/2016/09/20/04-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/">戳我跳转</a></p>
<h3 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h3><ul>
<li>p.<strong>proto</strong></li>
<li>p.constructor.prototype</li>
<li>Object.getPrototypeOf(p)</li>
</ul>
<h3 id="在-js-中不同进制数字的表示方式"><a href="#在-js-中不同进制数字的表示方式" class="headerlink" title="在 js 中不同进制数字的表示方式"></a>在 js 中不同进制数字的表示方式</h3><ul>
<li>以 0X、0x 开头的表示为十六进制。</li>
<li>以 0、0O、0o 开头的表示为八进制。</li>
<li>以 0B、0b 开头的表示为二进制格式。</li>
</ul>
<h3 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h3><p>NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<p>typeof NaN; // “number”</p>
<p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN 为 true。</p>
<h3 id="javascript-创建对象的几种方式？"><a href="#javascript-创建对象的几种方式？" class="headerlink" title="javascript 创建对象的几种方式？"></a>javascript 创建对象的几种方式？</h3><p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。</p>
<ul>
<li>工厂模式</li>
</ul>
<p>工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p>
<ul>
<li>构造函数模式</li>
</ul>
<p>只要一个函数是通过 new来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。</p>
<blockquote>
<p>构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型</p>
</blockquote>
<ul>
<li>原型模式</li>
</ul>
<p>因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用</p>
<h3 id="JavaScript-继承的几种实现方式"><a href="#JavaScript-继承的几种实现方式" class="headerlink" title="JavaScript 继承的几种实现方式"></a>JavaScript 继承的几种实现方式</h3><p><a href="https://www.chensheng.group/2016/09/15/03-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/">戳我跳转</a></p>
<h3 id="谈谈-This-对象的理解。什么是闭包-说一下闭包。"><a href="#谈谈-This-对象的理解。什么是闭包-说一下闭包。" class="headerlink" title="谈谈 This 对象的理解。什么是闭包,说一下闭包。"></a>谈谈 This 对象的理解。什么是闭包,说一下闭包。</h3><p><a href="https://www.chensheng.group/2016/09/24/05-This%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%E4%B8%8E%E9%97%AD%E5%8C%85/">戳我跳转</a></p>
<h3 id="“1”-“2”-“3”-map-parseInt-答案是多少"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少?"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少?</h3><p>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (string, radix)</p>
<p>其中radix 表示要解析的数字的基数。(该值介于 2 ~ 36 之间)</p>
<blockquote>
<p>如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</p>
</blockquote>
<p>由于map传参默认有三个(currentValue, index, arr)</p>
<p>所以传入到parseInt中去之后,就变成了下面这样了,后面的0,1,2 对应的就是index索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(&#39;1&#39;, 0);</span><br><span class="line">parseInt(&#39;2&#39;, 1);</span><br><span class="line">parseInt(&#39;3&#39;, 2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>
</blockquote>
<p>所以答案是 [1, NaN, NaN]</p>
<h3 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h3><ol>
<li>使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li>
<li>可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li>
<li>如果需要判断的是某个内置的引用类型的话，可以使用Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li>
</ol>
<h2 id="11-20"><a href="#11-20" class="headerlink" title="11~20"></a>11~20</h2><h3 id="new-操作符具体干了什么呢？如何实现？"><a href="#new-操作符具体干了什么呢？如何实现？" class="headerlink" title="new 操作符具体干了什么呢？如何实现？"></a>new 操作符具体干了什么呢？如何实现？</h3><p><a href="https://www.chensheng.group/2019/10/10/106-JS%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E5%88%86%E4%BA%AB/">戳我跳转</a></p>
<h3 id="一行代码学习js"><a href="#一行代码学习js" class="headerlink" title="一行代码学习js"></a>一行代码学习js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline&#x3D;&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</span><br></pre></td></tr></table></figure>

<p>解释一下上面这段代码的意思</p>
<ol>
<li>选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。</li>
<li>循环遍历 DOM 元素</li>
<li>给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加outline 并不会影响元素的大小和页面的布局。</li>
<li>生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</li>
</ol>
<h3 id="如何创建一个-Ajax"><a href="#如何创建一个-Ajax" class="headerlink" title="如何创建一个 Ajax"></a>如何创建一个 Ajax</h3><ol>
<li>创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li>
<li>创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li>
<li>设置响应 HTTP 请求状态变化的函数</li>
<li>发送 HTTP 请求</li>
<li>获取异步调用返回的数据</li>
<li>使用 JavaScript 和 DOM 实现局部刷新</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const SERVER_URL &#x3D; &quot;&#x2F;server&quot;;</span><br><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">&#x2F;&#x2F; 创建 Http 请求 </span><br><span class="line">xhr.open(&quot;GET&quot;, SERVER_URL, true);</span><br><span class="line">&#x2F;&#x2F; 设置状态监听函数 </span><br><span class="line">xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">  if (this.readyState !&#x3D;&#x3D; 4) return;</span><br><span class="line">  &#x2F;&#x2F; 当请求成功时</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    handle(this.response);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.error(this.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 设置请求失败时的监听函数 </span><br><span class="line">xhr.onerror &#x3D; function() &#123;</span><br><span class="line">  console.error(this.statusText);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 设置请求头信息 </span><br><span class="line">xhr.responseType &#x3D; &quot;json&quot;;</span><br><span class="line">xhr.setRequestHeader(&quot;Accept&quot;, &quot;application&#x2F;json&quot;);</span><br><span class="line">&#x2F;&#x2F; 发送 Http 请求 </span><br><span class="line">xhr.send(null);</span><br><span class="line">&#x2F;&#x2F; promise 封装实现：</span><br><span class="line">function getJSON(url) &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建一个 promise 对象</span><br><span class="line">  let promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    &#x2F;&#x2F; 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">    &#x2F;&#x2F; 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">      if (this.readyState !&#x3D;&#x3D; 4) return;</span><br><span class="line">      &#x2F;&#x2F; 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 设置错误监听函数</span><br><span class="line">    xhr.onerror &#x3D; function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 设置响应的数据类型</span><br><span class="line">    xhr.responseType &#x3D; &quot;json&quot;;</span><br><span class="line">    &#x2F;&#x2F; 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application&#x2F;json&quot;);</span><br><span class="line">    &#x2F;&#x2F; 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JS事件循环机制"><a href="#JS事件循环机制" class="headerlink" title="JS事件循环机制"></a>JS事件循环机制</h3><p><a href="https://www.chensheng.group/2020/07/04/133-JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">戳我跳转</a></p>
<h3 id="什么是浏览器的同源政策？如何解决跨域问题？"><a href="#什么是浏览器的同源政策？如何解决跨域问题？" class="headerlink" title="什么是浏览器的同源政策？如何解决跨域问题？"></a>什么是浏览器的同源政策？如何解决跨域问题？</h3><p><a href="https://www.chensheng.group/2018/01/19/49-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">戳我跳转</a></p>
<p><a href="https://www.chensheng.group/2018/10/10/63-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%B7%B1%E5%85%A5/">戳我跳转</a></p>
<h3 id="简单介绍几种模块规范"><a href="#简单介绍几种模块规范" class="headerlink" title="简单介绍几种模块规范"></a>简单介绍几种模块规范</h3><ul>
<li>CommonJS 方案</li>
</ul>
<p>它通过 require 来引入模块，通过 module.exports 定义模块的输出接口</p>
<ul>
<li>AMD 方案</li>
</ul>
<p>采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p>
<ul>
<li>CMD 方案</li>
</ul>
<p>这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</p>
<ul>
<li>ES6 模块化</li>
</ul>
<p>使用 import 和 export 的形式来导入导出模块。</p>
<h3 id="AMD-和-CMD-规范的区别？"><a href="#AMD-和-CMD-规范的区别？" class="headerlink" title="AMD 和 CMD 规范的区别？"></a>AMD 和 CMD 规范的区别？</h3><ul>
<li>在模块定义时对依赖的处理不同</li>
</ul>
<p>AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。<br>CMD 推崇 就近依赖，只有在用到某个模块的时候再去 require。</p>
<ul>
<li>对依赖模块的执行时机处理不同。</li>
</ul>
<p>首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机</p>
<p>AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致<br>CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p>
<h3 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><ul>
<li><p>创建新节点</p>
<ul>
<li>createDocumentFragment(node);</li>
<li>createElement(node);</li>
<li>createTextNode(text);</li>
</ul>
</li>
<li><p>添加、移除、替换、插入</p>
<ul>
<li>appendChild(node)</li>
<li>removeChild(node)</li>
<li>replaceChild(new,old)</li>
<li>insertBefore(new,old)</li>
</ul>
</li>
<li><p>查找</p>
<ul>
<li>getElementById();</li>
<li>getElementsByName();</li>
<li>getElementsByTagName();</li>
<li>getElementsByClassName();</li>
<li>querySelector();</li>
<li>querySelectorAll();</li>
</ul>
</li>
<li><p>属性操作</p>
<ul>
<li>getAttribute(key);</li>
<li>setAttribute(key,value);</li>
<li>hasAttribute(key);</li>
<li>removeAttribute(key);</li>
</ul>
</li>
</ul>
<h3 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title=".call() 和 .apply() 的区别？"></a>.call() 和 .apply() 的区别？</h3><p><a href="https://www.chensheng.group/2016/09/15/03-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/">戳我跳转</a></p>
<h3 id="的长度？"><a href="#的长度？" class="headerlink" title="[,,,] 的长度？"></a>[,,,] 的长度？</h3><p>尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</p>
<p>如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数量。</p>
<h2 id="21-30"><a href="#21-30" class="headerlink" title="21~30"></a>21~30</h2><h3 id="JavaScript-中的作用域与变量声明提升？"><a href="#JavaScript-中的作用域与变量声明提升？" class="headerlink" title=". JavaScript 中的作用域与变量声明提升？"></a>. JavaScript 中的作用域与变量声明提升？</h3><p><a href="https://www.chensheng.group/2018/12/04/69-ES6%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/">戳我跳转</a></p>
<h3 id="深入理解垃圾回收原理"><a href="#深入理解垃圾回收原理" class="headerlink" title="深入理解垃圾回收原理"></a>深入理解垃圾回收原理</h3><p><a href="https://www.chensheng.group/2021/08/30/142-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86/">戳我跳转</a></p>
<h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p><a href="https://www.chensheng.group/2019/10/10/106-JS%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E5%88%86%E4%BA%AB/">戳我跳转</a></p>
<h3 id="移动端为什么会有点击延迟，怎么解决"><a href="#移动端为什么会有点击延迟，怎么解决" class="headerlink" title="移动端为什么会有点击延迟，怎么解决"></a>移动端为什么会有点击延迟，怎么解决</h3><p><a href="https://www.chensheng.group/2021/11/02/155-点击穿透/">戳我跳转</a></p>
<h3 id="使用-JS-实现获取文件扩展名？"><a href="#使用-JS-实现获取文件扩展名？" class="headerlink" title="使用 JS 实现获取文件扩展名？"></a>使用 JS 实现获取文件扩展名？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; String.lastIndexOf() 方法返回指定值（本例中的&#39;.&#39;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对于 &#39;filename&#39; 和 &#39;.hiddenfile&#39; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</span><br><span class="line"></span><br><span class="line">function getFileExtension(filename) &#123;</span><br><span class="line">  return filename.slice(((filename.lastIndexOf(&quot;.&quot;) - 1) &gt;&gt;&gt; 0) + 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="介绍一下-js-的节流与防抖"><a href="#介绍一下-js-的节流与防抖" class="headerlink" title="介绍一下 js 的节流与防抖"></a>介绍一下 js 的节流与防抖</h3><p><a href="https://www.chensheng.group/2021/09/03/147-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">戳我跳转</a></p>
<h3 id="Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h3><p><a href="https://www.chensheng.group/2019/01/10/77-ES6%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/">戳我跳转</a></p>
<h3 id="js-的事件循环是什么？"><a href="#js-的事件循环是什么？" class="headerlink" title="js 的事件循环是什么？"></a>js 的事件循环是什么？</h3><p><a href="https://www.chensheng.group/2020/07/04/133-JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">戳我跳转</a></p>
<h3 id="js-中的深浅拷贝实现？"><a href="#js-中的深浅拷贝实现？" class="headerlink" title="js 中的深浅拷贝实现？"></a>js 中的深浅拷贝实现？</h3><p>浅拷贝的实现;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function shallowCopy(object) &#123;</span><br><span class="line">  &#x2F;&#x2F; 只拷贝对象</span><br><span class="line">  if (!object || typeof object !&#x3D;&#x3D; &quot;object&quot;) return;</span><br><span class="line">    &#x2F;&#x2F; 根据 object 的类型判断是新建一个数组还是对象</span><br><span class="line">    let newObject &#x3D; Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F; 遍历 object，并且判断是 object 的属性才拷贝</span><br><span class="line">    for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] &#x3D; object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深拷贝的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepCopy(object) &#123;</span><br><span class="line">  if (!object || typeof object !&#x3D;&#x3D; &quot;object&quot;) return;</span><br><span class="line">  let newObject &#x3D; Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] &#x3D;</span><br><span class="line">      typeof object[key] &#x3D;&#x3D;&#x3D; &quot;object&quot; ? deepCopy(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h3><p><a href="https://www.chensheng.group/2021/11/01/149-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/">戳我戳我</a></p>
<h2 id="31-40"><a href="#31-40" class="headerlink" title="31~40"></a>31~40</h2><h3 id="为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="为什么 0.1 + 0.2 != 0.3？如何解决这个问题？"></a>为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</h3><p><a href="https://www.chensheng.group/2018/12/12/73-ES6%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/">戳我跳转</a></p>
<h3 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h3><p><a href="https://www.chensheng.group/2021/11/02/151-前端网络安全/">戳我跳转</a></p>
<h3 id="offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？"></a>offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</h3><p>clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。<br>clientTop 返回的是上边框的宽度。clientLeft 返回的左边框的宽度。</p>
<p>offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。<br>offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。</p>
<p>scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。<br>scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。scrollLeft 属性返回的是元素滚动条到元素左边的距离。</p>
<h3 id="什么是-Promise-对象"><a href="#什么是-Promise-对象" class="headerlink" title="什么是 Promise 对象?"></a>什么是 Promise 对象?</h3><p><a href="https://www.chensheng.group/2019/02/19/82-ES6%20Promise/">戳我戳我</a></p>
<h3 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h3><p><a href="https://www.chensheng.group/2021/11/01/150-%E6%89%8B%E5%86%99promise/">戳我戳我</a></p>
<h3 id="js-设计模式"><a href="#js-设计模式" class="headerlink" title="js 设计模式"></a>js 设计模式</h3><ul>
<li>单例模式</li>
</ul>
<p>单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。</p>
<ul>
<li>策略模式</li>
</ul>
<p>策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。</p>
<ul>
<li>代理模式</li>
</ul>
<p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</p>
<ul>
<li>中介者模式</li>
</ul>
<p>中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</p>
<ul>
<li>适配器模式</li>
</ul>
<p>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。</p>
<ul>
<li>观察者模式</li>
</ul>
<p>发布订阅模式其实属于广义上的观察者模式, 在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</p>
<ul>
<li>发布订阅模式</li>
</ul>
<p>而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦</p>
<p>更详细的可以看看我朋友的博客<a href="https://www.chenkl.vip/%E5%B8%B8%E8%A7%81%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">戳我跳转</a></p>
<h3 id="开发中常用的几种-Content-Type-？"><a href="#开发中常用的几种-Content-Type-？" class="headerlink" title="开发中常用的几种 Content-Type ？"></a>开发中常用的几种 Content-Type ？</h3><ul>
<li>application/x-www-form-urlencoded</li>
</ul>
<p>浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以<br>application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，<br>数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p>
<ul>
<li>multipart/form-data</li>
</ul>
<p>该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p>
<ul>
<li>application/json</li>
</ul>
<p>告诉服务器消息主体是序列化后的 JSON 字符串。</p>
<ul>
<li>text/xml</li>
</ul>
<p>该种方式主要用来提交 XML 格式的数据。</p>
<h3 id="如何封装一个-javascript-的类型判断函数？"><a href="#如何封装一个-javascript-的类型判断函数？" class="headerlink" title="如何封装一个 javascript 的类型判断函数？"></a>如何封装一个 javascript 的类型判断函数？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getType(value) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断数据是 null 的情况</span><br><span class="line">  if (value &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    return value + &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 判断数据是引用类型的情况</span><br><span class="line">  if (typeof value &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class="line">    let valueClass &#x3D; Object.prototype.toString.call(value),</span><br><span class="line">      type &#x3D; valueClass.split(&quot; &quot;)[1].split(&quot;&quot;);</span><br><span class="line">    type.pop();</span><br><span class="line">    return type.join(&quot;&quot;).toLowerCase();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断数据是基本数据类型的情况和函数的情况</span><br><span class="line">    return typeof value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(未完待续…)</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue高频考题</title>
    <url>/2021/11/02/154-vue%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>整理了一下常见的vue的问题</p>
</blockquote>
<a id="more"></a>

<p>vue的问题整理的不太多,一些基础的并没有整理出来</p>
<h3 id="什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h3><p>阮老师说的就很详细 <a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">戳我戳我</a></p>
<h3 id="Vue-的各个生命阶段是什么"><a href="#Vue-的各个生命阶段是什么" class="headerlink" title="Vue 的各个生命阶段是什么?"></a>Vue 的各个生命阶段是什么?</h3><p><a href="https://www.chensheng.group/2019/09/13/45-vue-cli%E6%80%BB%E7%BB%93/">戳我跳转搜索生命周期</a></p>
<h3 id="Vue-组件间的参数传递方式"><a href="#Vue-组件间的参数传递方式" class="headerlink" title="Vue 组件间的参数传递方式"></a>Vue 组件间的参数传递方式</h3><p>普通的组件传值可以去我其他的博客搜一下,这里重点说一下 多个子组件嵌套</p>
<p>使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</p>
<h3 id="computed-和-watch-的差异"><a href="#computed-和-watch-的差异" class="headerlink" title="computed 和 watch 的差异"></a>computed 和 watch 的差异</h3><ol>
<li><p>computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。</p>
</li>
<li><p>computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。</p>
</li>
<li><p>从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。</p>
</li>
</ol>
<h3 id="v-model的实现原理以及如何自定义v-model"><a href="#v-model的实现原理以及如何自定义v-model" class="headerlink" title="v-model的实现原理以及如何自定义v-model"></a>v-model的实现原理以及如何自定义v-model</h3><p><a href="https://www.chensheng.group/2019/10/09/104-Vue随笔记录/">戳我跳转</a></p>
<h3 id="vue响应式数据原理？"><a href="#vue响应式数据原理？" class="headerlink" title="vue响应式数据原理？"></a>vue响应式数据原理？</h3><p><a href="https://www.chensheng.group/2020/05/31/127-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/">戳我跳转</a></p>
<h3 id="什么是-Virtual-DOM？如何比较两个-DOM-树的差异？"><a href="#什么是-Virtual-DOM？如何比较两个-DOM-树的差异？" class="headerlink" title="什么是 Virtual DOM？如何比较两个 DOM 树的差异？"></a>什么是 Virtual DOM？如何比较两个 DOM 树的差异？</h3><p><a href="https://www.chensheng.group/2021/02/11/138-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-diff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/">戳我跳转</a></p>
<h3 id="vue-中-key-值的作用？"><a href="#vue-中-key-值的作用？" class="headerlink" title="vue 中 key 值的作用？"></a>vue 中 key 值的作用？</h3><p>vue 中 key 值的作用可以分为两种情况来考虑。</p>
<p>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而<br>不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类<br>型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不<br>会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个<br>情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</p>
<p>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地<br>复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，<br>而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元<br>素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</p>
<h3 id="没有整理的题目"><a href="#没有整理的题目" class="headerlink" title="没有整理的题目"></a>没有整理的题目</h3><ul>
<li>Vue中如何检测数组变化</li>
<li>为何Vue采用异步处理</li>
<li>nextTick的实现原理</li>
<li>Vue中v-html会导致哪些问题</li>
<li>组件中的data为什么是一个函数</li>
<li>Vue中常见性能优化</li>
<li>keep-alive的了解</li>
<li>如何实现hash路由和history路由</li>
</ul>
<p>(未完待续…)</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端点击延迟问题</title>
    <url>/2021/11/02/155-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>本来是放在js面试题里面的,但是内容太多了,所以还是再分出来单独讲</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</p>
</blockquote>
<p>怎么处理呢?</p>
<ul>
<li><p>通过 meta 标签禁用网页的缩放。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;user-scalable&#x3D;no&quot;&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;initial-scale&#x3D;1,maximum-scale&#x3D;1&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 meta 标签将网页的 viewport 设置为 ideal viewport。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width&quot;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方案相比上一个的好处在于，它没有完全禁用缩放，而只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面。</p>
</blockquote>
<ul>
<li>CSS touch-action</li>
</ul>
<p>touch-action这个CSS属性。这个属性指定了相应元素上能够触发的用户代理（也就是浏览器）的默认行为。</p>
<p>如果将该属性值设置为touch-action: none，那么表示在该元素上的操作不会触发用户代理的任何默认行为，就无需进行300ms的延迟判断。</p>
<ul>
<li>调用一些 js 库，比如 FastClick</li>
</ul>
<h3 id="点击穿透问题"><a href="#点击穿透问题" class="headerlink" title="点击穿透问题"></a>点击穿透问题</h3><p>说完移动端点击300ms延迟的问题，还不得不提一下移动端点击穿透的问题。可能有人会想，既然click点击有300ms的延迟，那对于触摸屏，我们直接监听touchstart事件不就好了吗？</p>
<p>使用touchstart去代替click事件有两个不好的地方。</p>
<p>第一：touchstart是手指触摸屏幕就触发，有时候用户只是想滑动屏幕，却触发了touchstart事件，这不是我们想要的结果；<br>第二：使用touchstart事件在某些场景下可能会出现点击穿透的现象。</p>
<h3 id="什么是点击穿透？"><a href="#什么是点击穿透？" class="headerlink" title="什么是点击穿透？"></a>什么是点击穿透？</h3><p>假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。</p>
<p>这是因为在移动端浏览器，事件执行的顺序是touchstart &gt; touchend &gt; click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。</p>
<blockquote>
<p>浏览器事件触发的顺序 touchstart –&gt; mouseover(有的浏览器没有实现) –&gt; mousemove(一次) –&gt;mousedown –&gt; mouseup –&gt; click –&gt;touchend</p>
</blockquote>
<p>说完了,告辞…</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>分线程操作</title>
    <url>/2017/01/22/16-%E5%88%86%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Web Workers 是 HTML5 提供的一个javascript多线程解决方案，我们可以将一些大计算量的代码交由web Worker运行而不冻结用户界面。</p>
</blockquote>
<a id="more"></a>

<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul>
<li>进程:<ul>
<li>打开一个app相当于打开了一个进程,进程是由线程说组成的(最少也得有一个主线程)  </li>
</ul>
</li>
<li>线程:<ul>
<li>主线程和分线程(多线程开发)  </li>
</ul>
</li>
<li>耗时太多的操作(发送网络请求,读取文件)一定得放在异步执行,否则就会造成线程的卡死–卡屏</li>
</ul>
<h3 id="如何使用Worker"><a href="#如何使用Worker" class="headerlink" title="如何使用Worker"></a>如何使用Worker</h3><h4 id="newThread-js界面"><a href="#newThread-js界面" class="headerlink" title="newThread.js界面"></a>newThread.js界面</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(event.data);</span><br><span class="line">	postMessage(<span class="string">'传回主线程的值'</span>);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="html页面"><a href="#html页面" class="headerlink" title="html页面"></a>html页面</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> thread = <span class="keyword">new</span> Worker(<span class="string">'newThread.js'</span>);</span><br><span class="line">thread.postMessage(<span class="string">'这里是要传的值'</span>)</span><br><span class="line">thread.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(event.data);<span class="comment">//newThread传来的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开启分线程的步骤"><a href="#开启分线程的步骤" class="headerlink" title="开启分线程的步骤"></a>开启分线程的步骤</h3><p>一、 开启分线程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> thread = <span class="keyword">new</span> Worker(<span class="string">'newThread.js'</span>);  <span class="comment">//这里的js文件时新创建的</span></span><br></pre></td></tr></table></figure>

<p>二、 线程之前的传值(线程与线程之间的作用域是独立的 不能相互访问)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">thread.postMessage(这里是要传的值)</span><br></pre></td></tr></table></figure>

<p>三、 接受线程的传值(其他线程通过postMessage()传递值时触发onmessage)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//event.data	//值在data中</span></span><br><span class="line">	postMessage(传回主线程的值)	<span class="comment">//第四步的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、 分线程传值回主线程</p>
<pre><code>由于线程之间的作用域是独立的,所以分线程不能访问主线程的变量
postMessage(&apos;传回主线程的值&apos;);</code></pre><p>五、 主线程接收分线程传回的值</p>
<blockquote>
<p>(当分线程postMessage 时 ,会触发分线程中的onmessage)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">thread.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	event.data	<span class="comment">//值在data中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>六、 中断分线程(分线程关闭后,未执行完的代码会立刻停止,而且不会给主线程发消息)</p>
<pre><code>thread.terminate();        </code></pre><h3 id="Web-Worker的优缺点"><a href="#Web-Worker的优缺点" class="headerlink" title="Web Worker的优缺点"></a>Web Worker的优缺点</h3><p>我们可以做什么：</p>
<p>1.可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信</p>
<p>2.可以在worker中通过importScripts(url)加载另外的脚本文件</p>
<p>3.可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval()</p>
<p>4.可以使用XMLHttpRequest来发送请求</p>
<p>5.可以访问navigator的部分属性</p>
<p>有哪些局限性：</p>
<p>1.不能跨域加载JS</p>
<p>2.worker内代码不能访问DOM</p>
<p>3.各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行</p>
<p>4.不是每个浏览器都支持这个新特性</p>
<p>以上就是我对分线程的一些理解,不足之处希望大牛们多提一些意见,感激不尽</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>Web Worker</tag>
        <tag>分线程</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义抛出错误</title>
    <url>/2017/01/27/17-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>使用抛出异常机制能让代码结构更加的简洁，减少很多的逻辑判断，并且能够得到出错时的详细错误信息，今天要说的就是在js中抛出（throw）异常。</p>
</blockquote>
<a id="more"></a>

<h3 id="报错的类别"><a href="#报错的类别" class="headerlink" title="报错的类别"></a>报错的类别</h3><p>一、引用报错 (ReferenceError)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<p>二、 类型错误 (TypeError)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a.speak();</span><br></pre></td></tr></table></figure>

<p>三、 语法错误 SyntaxError)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10.</span>speak()</span><br></pre></td></tr></table></figure>

<p>四、 范围错误—非法数组长度(RangeError)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="抛出错误的方法"><a href="#抛出错误的方法" class="headerlink" title="抛出错误的方法"></a>抛出错误的方法</h3><h4 id="常见的几种抛出错误的方法"><a href="#常见的几种抛出错误的方法" class="headerlink" title="常见的几种抛出错误的方法"></a>常见的几种抛出错误的方法</h4><ol>
<li><p>console.error(‘第一个错误’);</p>
</li>
<li><p>$.Error();</p>
</li>
<li><p>可以定义抛出错误的类型:</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'第三个错误'</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">'第三个错误'</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'第三个错误'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="自定义抛出"><a href="#自定义抛出" class="headerlink" title="自定义抛出"></a>自定义抛出</h4><blockquote>
<p>错误类型是可以自定义的(注意的是:Error类型不可以直接继承)</p>
</blockquote>
<p>下面是自定义错误的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RangeError</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(msg);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//错误的行号</span></span><br><span class="line">	<span class="keyword">this</span>.lineNumber = err.lineNumber;</span><br><span class="line">	<span class="comment">//错误的列号</span></span><br><span class="line">	<span class="keyword">this</span>.columnNumber = err.columnNumber;</span><br><span class="line">	<span class="comment">//错误的文件</span></span><br><span class="line">	<span class="keyword">this</span>.fileName = err.fileName;</span><br><span class="line">	<span class="comment">//错误的类型</span></span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'RangeError'</span>;</span><br><span class="line">	<span class="comment">//错误的消息</span></span><br><span class="line">	<span class="keyword">this</span>.message = err.message;</span><br><span class="line">	<span class="comment">//错误的栈信息</span></span><br><span class="line">	<span class="keyword">this</span>.stack = err.stack;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">RangeError</span>.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);  </span><br><span class="line"><span class="built_in">RangeError</span>.prototype.constructor = <span class="built_in">RangeError</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'自定义错误'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="传统的捕获错误的方法"><a href="#传统的捕获错误的方法" class="headerlink" title="传统的捕获错误的方法"></a>传统的捕获错误的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">			</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="comment">//TODO 这里的TODO是一个记事本,可以在行数中看到记录的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局监听错误信息"><a href="#全局监听错误信息" class="headerlink" title="全局监听错误信息"></a>全局监听错误信息</h3><p>window.onerror 当全局代码中出现错误时触发</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一共有五个参数：错误类型，错误文件，行号，列号，错误堆栈信息</span></span><br><span class="line">	</span><br><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">name,filename,lineNumber,columuNumber,stack</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//通过 return true;可以不再控制台显示错误提示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是我对自定义抛出错误的一些理解,不足之处希望大牛们多提一些意见,感激不尽</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>throw</tag>
      </tags>
  </entry>
  <entry>
    <title>js延时对象Promise</title>
    <url>/2017/02/05/18-js%E5%BB%B6%E6%97%B6%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。ES6新特性利用Promise解决JS异步执行时候回调函数嵌套回调函数的问题，更简洁地控制函数执行流程。</p>
</blockquote>
<a id="more"></a>

<p>本文只是简单的分享一下学习过程中的心得，具体的内容推荐阅读阮一峰老师的博客 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">点我跳转</a></p>
<h3 id="js延时对象Promise"><a href="#js延时对象Promise" class="headerlink" title="js延时对象Promise"></a>js延时对象Promise</h3><h4 id="创建一个延时对象"><a href="#创建一个延时对象" class="headerlink" title="创建一个延时对象"></a>创建一个延时对象</h4><p>通过new实例化Promise，构造函数需要两个参数，第一个参数为函数执行成功以后执行的函数resolve，第二个函数为函数执行失败以后执行的函数reject。</p>
<ul>
<li>new Promise 的时候会立刻执行回调函数</li>
<li>resolve()–解决当Promise 对象中异步任务成功时触发成功的回调</li>
<li>reject()–解决任务失败时的回调</li>
</ul>
<p>举一个简单的小例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p =<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Math</span>.random() &lt;<span class="number">0.5</span>)&#123;</span><br><span class="line">			<span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">			<span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">			resolve(div)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			reject(<span class="string">'创建div失败'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,<span class="number">1000</span>);	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>踩坑，注意Promise的状态</p>
</blockquote>
<p>Promise 在创建时，没有状态的，通过resolve可以改变为成功，通过reject改变为失败，<br>Promise状态一旦确定了之后，就不能再做任何修改了</p>
<p>then() 设置Promise 对象，第一个参数为任务成功时回调，第二个是失败时回调</p>
<p>方法一(使用then())</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">div</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//成功</span></span><br><span class="line">	div.style.backgroundColor = <span class="string">'yellow'</span>;</span><br><span class="line">	</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//失败</span></span><br><span class="line">	alert(str)	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>方法二(使用catch())</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//catch() 设置任务失败时回调</span></span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">div</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//成功</span></span><br><span class="line">	div.style.backgroundColor = <span class="string">'yellow'</span>;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//失败</span></span><br><span class="line">	alert(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>以上只是Promise的一些基础知识， 还有一些其他的知识点， 因为能力有限不一一介绍了</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery延时对象deferred</title>
    <url>/2017/02/10/19-jq%E5%BB%B6%E6%97%B6%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行。</p>
</blockquote>
<a id="more"></a>

<p>本文只是简单的分享一下学习过程中的心得，具体的内容推荐阅读阮一峰老师的博客 <a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html" target="_blank" rel="noopener">点我跳转</a></p>
<h3 id="创建jquery延时对象deferred"><a href="#创建jquery延时对象deferred" class="headerlink" title="创建jquery延时对象deferred"></a>创建jquery延时对象deferred</h3><h4 id="创建一个延时对象"><a href="#创建一个延时对象" class="headerlink" title="创建一个延时对象"></a>创建一个延时对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> def = $.Deferred(<span class="function"><span class="keyword">function</span>(<span class="params">deferred</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(deferred);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//传入一个函数，在函数内部写触发事件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="在函数内部写入触发事件"><a href="#在函数内部写入触发事件" class="headerlink" title="在函数内部写入触发事件"></a>在函数内部写入触发事件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">deferred.notify();   <span class="comment">// 调用正在延迟对象上进行的回调函数</span></span><br><span class="line">deferred.resolve();  <span class="comment">// 改变deferred对象的执行状态--成功</span></span><br><span class="line">deferred.reject();	 <span class="comment">// 改变deferred对象的执行状态--失败</span></span><br></pre></td></tr></table></figure>

<h4 id="对应的代码"><a href="#对应的代码" class="headerlink" title="对应的代码"></a>对应的代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> def = $.Deferred(<span class="function"><span class="keyword">function</span>(<span class="params">deferred</span>)</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		deferred.notify(<span class="string">'请稍后，正在创建中...'</span>);</span><br><span class="line">	&#125;,<span class="number">500</span>);</span><br><span class="line">	</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		clearInterval(timer);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>)&#123;</span><br><span class="line">			<span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">			div.style.width = <span class="string">'100px'</span>;</span><br><span class="line">			div.style.height = <span class="string">'100px'</span>;</span><br><span class="line">			div.style.border = <span class="string">'1px solid black'</span>;</span><br><span class="line">			<span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">			deferred.resolve(div);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			deferred.reject(<span class="string">'创建失败'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;,<span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="def对象调用方法–用来监听触发事件的执行结果-可以参考ajax"><a href="#def对象调用方法–用来监听触发事件的执行结果-可以参考ajax" class="headerlink" title="def对象调用方法–用来监听触发事件的执行结果,可以参考ajax"></a>def对象调用方法–用来监听触发事件的执行结果,可以参考ajax</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持链式调用</span></span><br><span class="line">def.progress(<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(str);<span class="comment">//progress 任务有进度时由 notify 来触发</span></span><br><span class="line">	</span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params">div</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	div.style.backgroundColor = <span class="string">'red'</span>;</span><br><span class="line">	alert(<span class="string">'创建成功'</span>);<span class="comment">//done 任务成功时由 resolve 来触发</span></span><br><span class="line">	</span><br><span class="line">&#125;).fail(<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	alert(str);<span class="comment">//fail 任务失败时由 reject 来触发</span></span><br><span class="line">	</span><br><span class="line">&#125;).always(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	alert(<span class="string">'任务结束'</span>);<span class="comment">//always 无论成功还是失败都会触发</span></span><br><span class="line">	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>以上只是deferred的一些基础知识， 还有一些其他的知识点， 因为能力有限不一一介绍了</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>deferred</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的入门及介绍</title>
    <url>/2017/02/15/20-Vue%E7%9A%84%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>最近开始接触用户界面的渐进式框架-Vue。Vue采用自底向上增量开发的设计，是一个轻量级框架 。这里先给出<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue的官网</a></p>
</blockquote>
<a id="more"></a>

<h3 id="Vue介绍"><a href="#Vue介绍" class="headerlink" title="Vue介绍"></a>Vue介绍</h3><p>Vue是JavaScript的一个框架，是国内个人开发的,虽然是轻量级,但是功能强大。</p>
<p>渐进式框架：没有非常强的主张</p>
<p>使用的是MVVM的模式：提供高效的数据绑定和灵活的组件系统。</p>
<h3 id="使用Vue-使用版为2-4"><a href="#使用Vue-使用版为2-4" class="headerlink" title="使用Vue (使用版为2.4.*)"></a>使用Vue (使用版为2.4.*)</h3><p>开始学习Vue时我们先不适用Vue-cli进行搭建项目，使用cdn来引入Vue进行单页面的学习</p>
<p>稍微介绍一下大致具有哪些属性，这里只列出常用的几种</p>
<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><ol>
<li><p>采用双大括号插入值,原样式输出(不编译标签,纯文本) </p>
</li>
<li><p>v-html 插入 html内容(编译标签)</p>
</li>
<li><p>v-bind: 动态添加属性 (缩写: v-bind: =&gt; :)</p>
</li>
<li><p>v-on:click 绑定事件 (缩写: v-on:click =&gt; :@click)</p>
</li>
</ol>
<blockquote>
<p>注意：双大括号中是单个表达式，可以写入简单的javascript代码，不能使用多行的if/else，可以使用三元运算符进行判断</p>
</blockquote>
<p>这里先贴出Vue单页面的代码，在代码中进行介绍各个属性的含义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">		&lt;title&gt;Vue的入门及介绍&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">		&lt;script src="https:/</span><span class="regexp">/fastly.jsdelivr.net/</span>npm/vue<span class="string">" type="</span>text/javascript<span class="string">" charset="</span>utf<span class="number">-8</span><span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">	&lt;/head&gt;</span></span><br><span class="line"><span class="string">	&lt;body&gt;</span></span><br><span class="line"><span class="string">		&lt;div id="</span>app<span class="string">"&gt;</span></span><br><span class="line"><span class="string">			&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt; // &#123;&#123; &#125;&#125; 用来插入值</span></span><br><span class="line"><span class="string">			//标签内可以插入Vue的指令</span></span><br><span class="line"><span class="string">		&lt;/div&gt;</span></span><br><span class="line"><span class="string">	&lt;/body&gt;</span></span><br><span class="line"><span class="string">	&lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">		//如果使用vue 可以创建一个Vue的实例</span></span><br><span class="line"><span class="string">		var app = new Vue(&#123;</span></span><br><span class="line"><span class="string">			el: '#app',  //el:制定模版，主模板不能指定到body</span></span><br><span class="line"><span class="string">			data: &#123;</span></span><br><span class="line"><span class="string">				message: '你好 世界' //data 里面是数据</span></span><br><span class="line"><span class="string">			&#125;,</span></span><br><span class="line"><span class="string">			methods:&#123;</span></span><br><span class="line"><span class="string">				//methods里面写入函数</span></span><br><span class="line"><span class="string">			&#125;,</span></span><br><span class="line"><span class="string">			filters:&#123;</span></span><br><span class="line"><span class="string">				//filters里面写入过滤器</span></span><br><span class="line"><span class="string">			&#125;,</span></span><br><span class="line"><span class="string">			computed:&#123;</span></span><br><span class="line"><span class="string">				//computed里面写入计算属性</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;)</span></span><br><span class="line"><span class="string">	&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令 (Directives) 是带有 v- 前缀的特殊属性。指令属性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)</p>
<ul>
<li><p>只有指令名 (v-if=”值”)</p>
</li>
<li><p>带有参数的,:后面是参数 (v-bind:title)</p>
</li>
<li><p>带参数的,:后面是参数;带修饰符的 .后面是修饰符 (v-on:click.prevent)</p>
</li>
</ul>
<p>还有很多指令，在后面会提到。</p>
<p>给个例子，在代码中可以更直观的看出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">	&lt;!-- <span class="number">1.</span> v-<span class="keyword">if</span> 指令,当为<span class="literal">true</span>时候渲染这个标签--&gt;</span><br><span class="line">	&lt;p v-<span class="keyword">if</span>=<span class="string">"true"</span>&gt;能不能看到我&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">	</span></span><br><span class="line"><span class="regexp">	&lt;!-- 2. v-bind 指令: 带有参数的指令 --&gt;</span></span><br><span class="line"><span class="regexp">	&lt;p v-bind:title="message"&gt;标签上有标题&lt;/</span>p&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- <span class="number">3.</span> v-on 指令 绑定事件--&gt;</span><br><span class="line">	&lt;button v-on:click=<span class="string">"go($event)"</span>&gt;求点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">	</span></span><br><span class="line"><span class="regexp">	&lt;!-- 4. 需要阻止默认事件 可以使用v-on:click.prevent .prevent是修饰符 --&gt;</span></span><br><span class="line"><span class="regexp">	&lt;a href="http:/</span><span class="regexp">/www.baidu.com" v-on:click.prevent="go"&gt;点击进入百度&lt;/</span>a&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用方法时 加()和不加()的区别</p>
</blockquote>
<ul>
<li>什么都不加,就是传递一个event事件</li>
<li>加()什么都不写,就是不传递参数</li>
<li>加(),()里写参数就是传递参数,$event就是传递事件</li>
</ul>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器可以串联：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>可以接收多个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA(<span class="string">'arg1'</span>, arg2) &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>给个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">	&lt;!--第一个是参数 | 第二个是方法的名字--&gt;		</span><br><span class="line">	</span><br><span class="line">	&lt;p&gt;<span class="number">2</span>的三次方等于&#123;&#123; <span class="number">2</span> | pow(<span class="number">3</span>) &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">	</span></span><br><span class="line"><span class="regexp">	&lt;p&gt;2加3 加5等于&#123;&#123; 2 | add(3,5) &#125;&#125;&lt;/</span>p&gt;<span class="comment">//多个参数的时候可以直接在第二个后面跟</span></span><br><span class="line">	</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意!!! 过滤器函数,必须要有一个参数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">filters:&#123;</span><br><span class="line">	pow(num1,num2)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Math</span>.pow(num1,num2)</span><br><span class="line">	&#125;,</span><br><span class="line">	add(n1,n2,n3)&#123;</span><br><span class="line">		<span class="keyword">return</span> n1 + n2 + n3</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>正在学习Vue中，讲的不是太详细清楚，有好的博客欢迎和我分享一下</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的基础知识</title>
    <url>/2017/02/20/21-Vue%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>今天分享一下Vue的其他一些基础知识，计算属性，Style绑定以及条件渲染</p>
</blockquote>
<a id="more"></a>

<h3 id="了解computed-和-methods-的区别"><a href="#了解computed-和-methods-的区别" class="headerlink" title="了解computed 和 methods 的区别"></a>了解computed 和 methods 的区别</h3><p>计算属性与函数的写入类似，不同之处在于函数的调用需要手动执行,不管值有没有改变都回去执行函数，而计算属性,在值发生改变的时候执行</p>
<p>因为计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。</p>
<p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter </p>
<p>举个例子</p>
<p>如果想设置值,传一个对象,里面有get和set方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">age: &#123;</span><br><span class="line">    <span class="comment">// 不需要age.get,获取的时候自动执行</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">	    <span class="keyword">var</span> year = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">		<span class="keyword">return</span> year - <span class="keyword">this</span>.birtYear	</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>(Value) &#123;</span><br><span class="line">    	<span class="keyword">var</span> year = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()</span><br><span class="line">    	<span class="keyword">this</span>.birtYear = year - Value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置值的时候不需要调用set方法,会自动识别</span></span><br><span class="line">app.age = <span class="number">30</span></span><br></pre></td></tr></table></figure>

<h3 id="绑定class属性及改变样式"><a href="#绑定class属性及改变样式" class="headerlink" title="绑定class属性及改变样式"></a>绑定class属性及改变样式</h3><h4 id="绑定class属性-可以直接用字符串"><a href="#绑定class属性-可以直接用字符串" class="headerlink" title="绑定class属性,可以直接用字符串"></a>绑定class属性,可以直接用字符串</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:title=<span class="string">"title"</span>  :<span class="class"><span class="keyword">class</span></span>=<span class="string">"classStr"</span>&gt;这是一个盒子&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过对象绑定class-如果有class-那么会将其合并"><a href="#通过对象绑定class-如果有class-那么会将其合并" class="headerlink" title="通过对象绑定class,如果有class 那么会将其合并"></a>通过对象绑定class,如果有class 那么会将其合并</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"font-size25"</span> :<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;通过对象绑定&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过数组绑定class属性"><a href="#通过数组绑定class属性" class="headerlink" title="通过数组绑定class属性"></a>通过数组绑定class属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div :<span class="class"><span class="keyword">class</span></span>=<span class="string">"classArr"</span>&gt;通过数组绑定<span class="class"><span class="keyword">class</span>&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="通过对象来绑定-style-改变样式"><a href="#通过对象来绑定-style-改变样式" class="headerlink" title="通过对象来绑定 style 改变样式"></a>通过对象来绑定 style 改变样式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div :style=<span class="string">"styleObject"</span>&gt;通过对象来绑定 style 改变样式&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过数组style数组-改变样式"><a href="#通过数组style数组-改变样式" class="headerlink" title="通过数组style数组 改变样式"></a>通过数组style数组 改变样式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div :style=<span class="string">"[styleObject,styleObject2]"</span>&gt;通过style数组 改变样式&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面是需要的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el:<span class="string">'#app'</span>,</span><br><span class="line">	data:&#123;</span><br><span class="line">		classStr: <span class="string">'red font-size25'</span>,</span><br><span class="line">		removered:<span class="literal">true</span>,</span><br><span class="line">		<span class="comment">//对象绑定class</span></span><br><span class="line">		classObject:&#123;</span><br><span class="line">			<span class="comment">//以class的名字作为键名.使用布尔值控制class是否显示</span></span><br><span class="line">			<span class="string">'red'</span>:<span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		classArr:[&#123;<span class="attr">red</span> : removered &#125;,font-size25],</span><br><span class="line">		styleObject: &#123;</span><br><span class="line">		    color: <span class="string">'blue'</span>,</span><br><span class="line">		    fontSize: <span class="string">'30px'</span>,</span><br><span class="line">		    lineHeight:<span class="string">'100px'</span></span><br><span class="line">		&#125;,</span><br><span class="line">		styleObject2: &#123;</span><br><span class="line">		    color: <span class="string">'green'</span>,</span><br><span class="line">		    fontSize: <span class="string">'60px'</span>,</span><br><span class="line">		    backgroundColor:<span class="string">'red'</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="if与else"><a href="#if与else" class="headerlink" title="if与else"></a>if与else</h3><ul>
<li>v-if 和 v-else 之间不能有其他标签 ,v-else-if 要加中间</li>
<li>使用标签包住时使用 template ,用div时,div也会被渲染</li>
<li>v-if能过条件判断  是否创建这个dom元素</li>
<li>v-show 一定会创建这个dom元素   只是通过 样式来控制这个元素是否显示(display:none)</li>
</ul>
<p>具体的例子可以看一下官方的文档，这里就不给出了</p>
<h3 id="v-for循环的使用"><a href="#v-for循环的使用" class="headerlink" title="v-for循环的使用"></a>v-for循环的使用</h3><p>假设boys是一个数组，里面有name这个对象，使用v-for可以将其遍历出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;tr v-<span class="keyword">for</span>=<span class="string">"(student,index) in boys"</span>&gt;</span><br><span class="line">	&lt;td&gt;&#123;&#123;index&#125;&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">	&lt;td&gt;&#123;&#123;student.name&#125;&#125;&lt;/</span>td&gt;</span><br><span class="line">&lt;<span class="regexp">/tr&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-for循环的方式"><a href="#v-for循环的方式" class="headerlink" title="v-for循环的方式"></a>v-for循环的方式</h4><ol>
<li>普通循环 v-for=”(student, index) in students” 循环里还可以套一层</li>
<li>对象的迭代 v-for=”(value,key,index) in students[0]”</li>
<li>整数的迭代 v-for=”n in 10”</li>
<li>数组迭代 v-for=”vl in numbers”</li>
</ol>
<p>以上就是我的Vue一些基础知识的理解，希望大神们可以指出错误，谢谢</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的表单控件的使用</title>
    <url>/2017/02/25/22-Vue%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Vue最方便的地方就在于它可以很轻松的实现双向数据绑定，现在就来看一下吧</p>
</blockquote>
<a id="more"></a>

<h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a>v-model 指令</h3><p>v-model 指令就是Vue用来实现双向数据绑定的，它也有一些特性：</p>
<ol>
<li><p>v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</p>
</li>
<li><p>v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值。因为它会选择 Vue 实例数据来作为具体的值。你应该通过 JavaScript 在组件的 data 选项中声明初始值。</p>
</li>
</ol>
<p>先来看一下v-model 指令在表单控件中的一些基本使用</p>
<h4 id="text文本"><a href="#text文本" class="headerlink" title="text文本"></a>text文本</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">"text"</span> placeholder=<span class="string">"请输入"</span>&gt;</span><br><span class="line">&lt;p&gt;你输入的是: &#123;&#123; text &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/text在data中为字符串</span></span><br></pre></td></tr></table></figure>

<p>当你在输入框中输入文字的时候，在下面可以马上的显示出你输入的信息</p>
<h4 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;textarea v-model=<span class="string">"message"</span>&gt;&lt;<span class="regexp">/textarea&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;</span></span><br><span class="line"><span class="regexp">	你输入的文字为:</span></span><br><span class="line"><span class="regexp">	&lt;pre&gt;</span></span><br><span class="line"><span class="regexp">		&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>pre&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/message在data中为字符串</span></span><br></pre></td></tr></table></figure>

<h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;input type=<span class="string">"checkbox"</span> v-model=<span class="string">"sex"</span>&gt;</span><br><span class="line">	&#123;&#123; sex &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/sex在data中为布尔型</span></span><br></pre></td></tr></table></figure>

<h3 id="多个复选框-绑定到同一个数组"><a href="#多个复选框-绑定到同一个数组" class="headerlink" title="多个复选框(绑定到同一个数组)"></a>多个复选框(绑定到同一个数组)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	爱好选项:</span><br><span class="line">	&lt;label <span class="keyword">for</span>=<span class="string">""</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"敲代码"</span> <span class="attr">v-model</span>=<span class="string">"hobbies"</span>/&gt;</span></span>敲代码&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">	&lt;label for=""&gt;&lt;input type="checkbox" value="阅读" v-model="hobbies"/</span>&gt;阅读&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">	&lt;br /</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">	你的选择:</span><br><span class="line">		&lt;span v-<span class="keyword">for</span>=<span class="string">"(v,i) in hobbies"</span>&gt;</span><br><span class="line">			&lt;!--<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"i == hobbies.length - 1"</span>&gt;</span></span></span><br><span class="line"><span class="xml">				&#123;&#123; i + 1 &#125;&#125;.&#123;&#123; v &#125;&#125;						</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>--&gt;</span><br><span class="line">			&lt;template v-<span class="keyword">if</span>=<span class="string">"i != 0"</span>&gt;,&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">			&lt;span&gt;</span></span><br><span class="line"><span class="regexp">				&#123;&#123; i + 1 &#125;&#125;.&#123;&#123; v &#125;&#125;							</span></span><br><span class="line"><span class="regexp">			&lt;/</span>span&gt;</span><br><span class="line">		&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hobbies在data中为数组</span></span><br></pre></td></tr></table></figure>


<h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"one"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span>  <span class="attr">value</span>=<span class="string">"男"</span> <span class="attr">v-model</span>=<span class="string">"male"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span>		  </span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"two"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span>  <span class="attr">value</span>=<span class="string">"女"</span> <span class="attr">v-model</span>=<span class="string">"male"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">&lt;span&gt;性别: &#123;&#123; male &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">	</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/male在data中为字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="选择列表"><a href="#选择列表" class="headerlink" title="选择列表"></a>选择列表</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;select v-model=<span class="string">"stname"</span> multiple style=<span class="string">"width: 50px"</span>&gt;</span><br><span class="line">		&lt;option value=<span class="string">"你好"</span>&gt;你好&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">		&lt;option value="世界"&gt;世界&lt;/</span>option&gt;</span><br><span class="line">	&lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">	选择了:&#123;&#123; stname &#125;&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stname在data中为字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="表单控件的修饰符"><a href="#表单控件的修饰符" class="headerlink" title="表单控件的修饰符"></a>表单控件的修饰符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--.lazy 输入时不会改变,离开文本框改变--&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> v-model.lazy=<span class="string">"msg"</span> /&gt;</span><br><span class="line">&lt;div&gt; 输入的是 : &#123;&#123; msg &#125;&#125; &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!--.number将值转化为number--&gt;</span></span><br><span class="line"><span class="regexp">&lt;input type="number" v-model.number="num" /</span>&gt;</span><br><span class="line">&lt;div&gt; 输入的是 : &#123;&#123; num + <span class="number">1</span> &#125;&#125; &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!--.trim 去掉首尾空格--&gt;</span></span><br><span class="line"><span class="regexp">&lt;input type="text" v-model.trim="message" /</span>&gt;</span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>绑定的值自行在data中添加一下</p>
<p>以上就是我的Vue表单控件的一些理解，希望大神们可以指出错误，谢谢</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue修饰符</title>
    <url>/2017/03/02/23-Vue%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Vue的修饰符往往能起到许多意向不到的作用，和大家分享一下吧</p>
</blockquote>
<a id="more"></a>

<p>Vue的修饰符分为鼠标修饰符和键值修饰符，鼠标按钮修饰符还有系统修饰符以及Vue 2.5.0新增的exact 修饰符，各有各的用法</p>
<h3 id="鼠标的修饰符"><a href="#鼠标的修饰符" class="headerlink" title="鼠标的修饰符"></a>鼠标的修饰符</h3><ol>
<li>.stop     阻止单击事件冒泡</li>
<li>.prevent 阻止默认事件</li>
<li>.capture 添加事件侦听器时使用事件捕获模式</li>
<li>.self      只当事件在该元素本身（比如不是子元素）触发时触发回调</li>
<li>修饰符可以串联使用,不过要注意前后关系(用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止元素上的点击。)</li>
<li>.once     事件只触发一次</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class="line">&lt;a v-on:click.stop=<span class="string">"doThis"</span>&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=<span class="string">"doThat"</span>&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;form v-on:submit.prevent&gt;&lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;div v-on:click.capture=<span class="string">"doThis"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;div v-on:click.self="doThat"&gt;...&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a v-on:click.once=<span class="string">"doThis"</span>&gt;&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="键值的修饰符"><a href="#键值的修饰符" class="headerlink" title="键值的修饰符"></a>键值的修饰符</h3><p>在监听键盘事件时，我们经常需要监测常见的键值。Vue 允许为 v-on 在监听键盘事件时添加关键修饰符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只有在 keyCode 是 <span class="number">13</span> 时调用 vm.submit() --&gt;</span><br><span class="line">&lt;input v-on:keyup<span class="number">.13</span>=<span class="string">"submit"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input @keyup.enter=<span class="string">"submit"</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete (捕获“删除”和“退格”键)</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right</li>
</ul>
<blockquote>
<p>可以通过全局 config.keyCodes 对象自定义键值修饰符别名：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用 v-on:keyup.f1</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure>

<h3 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h3><p>可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应。</p>
<ul>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta</li>
</ul>
<p>举个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- Alt + C --&gt;</span><br><span class="line">&lt;input @keyup.alt<span class="number">.67</span>=<span class="string">"clear"</span>&gt;</span><br><span class="line">&lt;!-- Ctrl + Click --&gt;</span><br><span class="line">&lt;div @click.ctrl=<span class="string">"doSomething"</span>&gt;Do something&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>修饰键比正常的按键不同；修饰键和 keyup 事件一起用时，事件引发时必须按下正常的按键。换一种说法：如果要引发 keyup.ctrl，必须按下 ctrl 时释放其他的按键；单单释放 ctrl 不会引发事件。</p>
</blockquote>
<h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ol>
<li>.left    </li>
<li>.right    </li>
<li>.middle    </li>
</ol>
<p>这些修饰符会限制处理程序监听特定的滑鼠按键。</p>
<h3 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a>.exact 修饰符</h3><p>.exact 修饰符应与其他系统修饰符组合使用，以指示处理程序只在精确匹配该按键组合时触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl=<span class="string">"onClick"</span>&gt;A&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- 只有在 Ctrl 被按下的时候触发 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;button @click.ctrl.exact="onCtrlClick"&gt;A&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="为什么在-HTML-中监听事件"><a href="#为什么在-HTML-中监听事件" class="headerlink" title="为什么在 HTML 中监听事件?"></a>为什么在 HTML 中监听事件?</h3><ol>
<li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li>
<li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li>
<li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li>
</ol>
<p>以上就是我对Vue修饰符的一些理解，希望大神们可以指出错误，谢谢</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件使用</title>
    <url>/2017/03/15/24-Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。</p>
</blockquote>
<a id="more"></a>

<h3 id="组件的基础"><a href="#组件的基础" class="headerlink" title="组件的基础"></a>组件的基础</h3><h4 id="全局–注册组件"><a href="#全局–注册组件" class="headerlink" title="全局–注册组件"></a>全局–注册组件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'g-com'</span>, &#123;</span><br><span class="line">  	template: <span class="string">'&lt;h1&gt;你好世界&lt;/h1&gt;'</span></span><br><span class="line">  	data()&#123;</span><br><span class="line">  		<span class="comment">//data 为函数</span></span><br><span class="line">		<span class="comment">//这里目的:让每一个组件都有独立的数据,而不是使用同一个对象进行共享</span></span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			counter : <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//g-com这个是html直接使用的标签</span></span><br><span class="line"><span class="comment">//component注册组件的方法</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于自定义标签的命名 ,Vue不强制遵循 W3C 规则 (小写，并且包含一个短杠)，尽管这被认为是最佳实践。</p>
</blockquote>
<h4 id="局部–注册组件"><a href="#局部–注册组件" class="headerlink" title="局部–注册组件"></a>局部–注册组件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el:<span class="string">'#app'</span>,</span><br><span class="line">	data:&#123;</span><br><span class="line">		message:<span class="string">'hello'</span></span><br><span class="line">	&#125;,</span><br><span class="line">	components:&#123;</span><br><span class="line">		<span class="string">'my-com'</span>:&#123;</span><br><span class="line">			template:<span class="string">'&lt;p&gt;这个是app里的局部组件&lt;/p&gt;'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某一个实例中注册的组件,就只能在这个实例中使用</span></span><br><span class="line"><span class="comment">//my-com这个是html直接使用的标签</span></span><br></pre></td></tr></table></figure>

<h3 id="创建组件模板时的注意点"><a href="#创建组件模板时的注意点" class="headerlink" title="创建组件模板时的注意点"></a>创建组件模板时的注意点</h3><p>官方的文档也给了说明，但是看得有点绕，我稍微做了一点小小的总结</p>
<blockquote>
<p>template 模板只会显示最外层的标签，比如使用下面这种方式创建模板：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/html"</span> id=<span class="string">"g-com"</span>&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		只会显示最外层一个标签</span><br><span class="line">	&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在创建模板时要注意元素的限制，在浏览器解析、规范化模板之后才能获取其内容。<br>例如：ul.ol.table.select. 这些标签限制了能被它包裹的元素</p>
</blockquote>
<p>举个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">	&lt;my-com&gt;&lt;<span class="regexp">/my-com&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>table&gt;</span><br></pre></td></tr></table></figure>

<p>自定义组件 <my-com> 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的 is 特性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">	&lt;tr is=<span class="string">"my-com"</span>&gt;&lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>table&gt;</span><br></pre></td></tr></table></figure>



<p>以上就是我对Vue组件的一些理解，希望大神们可以指出错误，谢谢</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件非父子间传值</title>
    <url>/2017/03/28/26-Vue%E7%BB%84%E4%BB%B6%E9%9D%9E%E7%88%B6%E5%AD%90%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Vue组件之间的传值不仅仅发生在父子间组件中，有时候，非父子关系的两个组件之间也需要通信。</p>
</blockquote>
<a id="more"></a>

<h3 id="非父子组件的传值"><a href="#非父子组件的传值" class="headerlink" title="非父子组件的传值"></a>非父子组件的传值</h3><p>非父子组件的传值大体上也是分为三个步骤，我还是称作三部曲</p>
<p>在简单的场景下，可以使用一个空的 Vue 实例作为事件总线：</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><blockquote>
<p>创建一个 vue 作为中央线来处理 非父子关系的组件传递数据</p>
</blockquote>
<p>新建一个bus.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'Vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> bus;</span><br></pre></td></tr></table></figure>

<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><blockquote>
<p>在组件二中创建监听事件—-注意:监听事件一定要在发射之前,监听才有效</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用前先导入</span></span><br><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">'../bus.js'</span>;</span><br><span class="line"></span><br><span class="line">created()&#123;	<span class="comment">//created这个会在注册组件完成是执行,后面再细说</span></span><br><span class="line">	bus.$on(<span class="string">'giveMsg'</span>,(value)=&gt;&#123; <span class="comment">//箭头函数的this是指向外部的,所以没有问题</span></span><br><span class="line">		<span class="keyword">this</span>.counter += value</span><br><span class="line">		<span class="comment">//这里的value是传递过来的值</span></span><br><span class="line">	&#125;)	<span class="comment">//可以加bind改变this的指向,普通的匿名函数的指向值bus的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>在组件一中发射组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">	add()&#123;</span><br><span class="line">		bus.$emit(<span class="string">'giveMsg'</span>,ran) <span class="comment">//通过bus中央线来发射组件</span></span><br><span class="line">		<span class="comment">//giveMsg类似于事件的名称</span></span><br><span class="line">		<span class="comment">//ran是要传递的参数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非父子组件的传值与自定义事件的思路是类似的，写法上也大体相同</p>
<p>以上就是我对Vue组件非父子间传值的一些理解，希望大神们可以指出错误，谢谢</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件父子间传值</title>
    <url>/2017/03/21/25-Vue%E7%BB%84%E4%BB%B6%E7%88%B6%E5%AD%90%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。看看它们是怎么工作的。</p>
</blockquote>
<a id="more"></a>

<h3 id="prop传值"><a href="#prop传值" class="headerlink" title="prop传值"></a>prop传值</h3><blockquote>
<p>为什么要用prop</p>
</blockquote>
<p>因为组件实例的作用域是独立的，子组件的模板不能直接使用父类的，所以Vue中使用prop进行父级向子级传值，下面贴出代码</p>
<h4 id="首先先创建一个Vue的实例"><a href="#首先先创建一个Vue的实例" class="headerlink" title="首先先创建一个Vue的实例"></a>首先先创建一个Vue的实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el:<span class="string">'#app'</span>,</span><br><span class="line">	data:&#123;</span><br><span class="line">		title:<span class="string">'信息记录'</span>,</span><br><span class="line">		person:&#123;</span><br><span class="line">			name:<span class="string">'金毛'</span>,</span><br><span class="line">			job:<span class="string">'看家'</span>,</span><br><span class="line">			company:<span class="string">'皇家护卫队'</span>,</span><br><span class="line">			phone:<span class="string">'18066666666'</span></span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;			</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="创建一个模板"><a href="#创建一个模板" class="headerlink" title="创建一个模板"></a>创建一个模板</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/html"</span> id=<span class="string">"card"</span>&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">		姓名: &#123;&#123; person.name &#125;&#125;&lt;br /</span>&gt;</span><br><span class="line">		职位: &#123;&#123; person.job &#125;&#125;&lt;br /&gt;</span><br><span class="line">		公司: &#123;&#123; person.company &#125;&#125;&lt;br /&gt;</span><br><span class="line">		手机: &#123;&#123; person.phone &#125;&#125;&lt;br /&gt;	</span><br><span class="line">	&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="注册一个组件"><a href="#注册一个组件" class="headerlink" title="注册一个组件"></a>注册一个组件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'card'</span>,&#123;</span><br><span class="line">	template:<span class="string">'#card'</span>,</span><br><span class="line">	data()&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//相当于在data有person数据,接收从组件标签传过来的值</span></span><br><span class="line">	props: [<span class="string">'title'</span>,<span class="string">'person'</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">	&lt;card :person = <span class="string">'person'</span> :title = <span class="string">'title'</span>&gt;&lt;<span class="regexp">/card&gt;</span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/这里的title是 Vue实例data数据里的title,将数据通过 :title 传递到 props:['title']</span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/不加: 相当于直接绑定到组件上了</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，在子组件中不可以修改prop传递过来的值</p>
</blockquote>
<p>每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。</p>
<p>在两种情况下，我们很容易忍不住想去修改 prop 中数据：</p>
<ol>
<li>Prop 作为初始值传入后，子组件想把它当作局部数据来用；</li>
<li>Prop 作为原始数据传入，由子组件处理成其它数据输出。</li>
</ol>
<p>对这两种情况，正确的应对方式是：</p>
<p>1.定义一个局部变量，并用 prop 的值初始化它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="attr">counter</span>: <span class="keyword">this</span>.initialCounter &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.定义一个计算属性，处理 prop 的值并返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">	normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</p>
</blockquote>
<h3 id="prop属性验证–对传入的值指定类型"><a href="#prop属性验证–对传入的值指定类型" class="headerlink" title="prop属性验证–对传入的值指定类型"></a>prop属性验证–对传入的值指定类型</h3><p>我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。这对于开发给他人使用的组件非常有用。</p>
<p>要指定验证规则，需要用对象的形式来定义 prop，而不能用字符串数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">	<span class="comment">//propA 键名,传过来的属性---Number,指定为数值类型</span></span><br><span class="line">	propA:<span class="built_in">Number</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//可以多种类型</span></span><br><span class="line">	propB:[<span class="built_in">Boolean</span>,<span class="built_in">Number</span>],</span><br><span class="line">	</span><br><span class="line">	propC: &#123;</span><br><span class="line">    	type: <span class="built_in">String</span>,</span><br><span class="line">    	required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认值</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">    	type: <span class="built_in">Number</span>,</span><br><span class="line">    	<span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们知道，父组件使用 prop 传递数据给子组件。但子组件怎么跟父组件通信呢？这个时候 Vue 的自定义事件系统就派得上用场了。</p>
</blockquote>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>自定义事件大体上分为三个步骤，我把它叫做三步曲</p>
<p>每个 Vue 实例都实现了事件接口，即：</p>
<p>父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。<br>子组件使用 $emit(eventName)来触发事件。</p>
<h4 id="第一步-监听自定义事件"><a href="#第一步-监听自定义事件" class="headerlink" title="第一步:监听自定义事件"></a>第一步:监听自定义事件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">	<span class="comment">//组件如果想添加原生的事件 需要使用 .native</span></span><br><span class="line">	&lt;counter @to-parent=<span class="string">"received"</span> @click.native=<span class="string">'show'</span>&gt;&lt;<span class="regexp">/counter&gt;</span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/to-parent 是自己定义的一个事件,在第二步触发</span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/received 是Vue实例 里的一个函数名</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第二步-触发自定义事件"><a href="#第二步-触发自定义事件" class="headerlink" title="第二步:触发自定义事件"></a>第二步:触发自定义事件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">	add()&#123;</span><br><span class="line">		<span class="keyword">this</span>.$emit(<span class="string">'to-parent'</span>,ran)	<span class="comment">//这里的ran是传递的参数	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三步-传递过来的值进行计算"><a href="#第三步-传递过来的值进行计算" class="headerlink" title="第三步:传递过来的值进行计算"></a>第三步:传递过来的值进行计算</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">	el:&#39;#app&#39;,</span><br><span class="line">	data:&#123;</span><br><span class="line">		total:0</span><br><span class="line">	&#125;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		received(value)&#123;</span><br><span class="line">			this.total +&#x3D; value</span><br><span class="line">			&#x2F;&#x2F;这里的value就是传递过来的值</span><br><span class="line">		&#125;,</span><br><span class="line">		show()&#123;</span><br><span class="line">			alert(&#39;显示出来吧&#39;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="自定义组件的-v-model"><a href="#自定义组件的-v-model" class="headerlink" title="自定义组件的 v-model"></a>自定义组件的 v-model</h3><p>Vue 2.2.0 新增的自定义组件的 v-model，默认情况下，一个组件的 v-model 会使用 value prop 和 input 事件。但是诸如单选框、复选框之类的输入类型可能把 value 用作了别的目的。model 选项可以避免这样的冲突，官网给出了相应的例子，</p>
<p>有兴趣的小伙伴可以研究一下</p>
<p>以上就是我对Vue组件父子间传值的一些理解，希望大神们可以指出错误，谢谢</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue插槽的使用</title>
    <url>/2017/04/03/27-Vue%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为内容分发 。Vue.js 实现了一个内容分发 API，参照了当前 Web Components 规范草案，使用特殊的 <slot> 元素作为原始内容的插槽。</p>
</blockquote>
<a id="more"></a>


<h3 id="Vue-插槽的使用"><a href="#Vue-插槽的使用" class="headerlink" title="Vue 插槽的使用"></a>Vue 插槽的使用</h3><p>在注册组件中定义好标签名字，先全局注册一个组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'component'</span>,&#123;</span><br><span class="line">	template:<span class="string">'#component'</span>,</span><br><span class="line">	data()&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在text/html中使用 slot,想要几个就写几个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;slot name=<span class="string">'title'</span>&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/每个插槽最好都要有自己的名字，不然所有的标签都会被使用</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p>在html中 可以直接使用Vue实例中的data数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;			</span><br><span class="line">	&lt;component&gt;</span><br><span class="line">		&lt;h1 slot=<span class="string">'title'</span>&gt;标题是:&#123;&#123; title &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>component&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>这就是插槽最基本的使用</p>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽是一种特殊类型的插槽，用作一个 (能被传递数据的) 可重用模板，来代替已经渲染好的元素。</p>
<blockquote>
<p>在父级中，具有特殊特性 slot-scope 的 <code>&lt;template&gt;</code> 元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;component&gt;</span><br><span class="line">	&lt;template slot=<span class="string">'title'</span> scope=<span class="string">"props"</span>&gt;</span><br><span class="line">	<span class="comment">//scope="props" 类似于可以将组件中插槽传递的数据全部获取出来进行打点调用,点的是下面:的东西</span></span><br><span class="line">		&#123;&#123;message&#125;&#125;</span><br><span class="line">	<span class="comment">// message 这个是Vue实例中data的数据</span></span><br><span class="line">		&#123;&#123; props&#125;&#125;</span><br><span class="line">	&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">		</span></span><br><span class="line"><span class="regexp">&lt;/</span>component&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个是插槽将组件中data的数据传递过去</span></span><br><span class="line">&lt;slot name=<span class="string">'title'</span> :message=<span class="string">'message'</span> :title=<span class="string">'tit'</span>&gt;&lt;<span class="regexp">/slot&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 2.5.0+ ，slot-scope 能被用在任意元素或组件中而不再局限于 <code>&lt;template&gt;</code>。这里演示的是2.4.*的版本，放在template中</p>
</blockquote>
<p>以上就是我对Vue插槽的一些理解，还在学习中，哪里有错误请指导小生一下，谢谢</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue动态组件的运用</title>
    <url>/2017/04/08/28-Vue%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>组件在之前已经介绍过了，今天分享一下动态组件，通过使用保留的 <component> 元素，动态地绑定到它的 is 特性，我们让多个组件可以使用同一个挂载点，并动态切换</p>
</blockquote>
<a id="more"></a>


<h3 id="动态组件-is的用法"><a href="#动态组件-is的用法" class="headerlink" title="动态组件 :is的用法"></a>动态组件 :is的用法</h3><blockquote>
<p>首先在主页面中创建一个用来切换组件的标签</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span @mouseover=<span class="string">"com='com2'"</span>&gt;切换到第二个组件&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其次，使用<component> 元素，动态地绑定到它的 is 特性，is中的值是组件的名称</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//keep-alive 保留原来的状态</span></span><br><span class="line"></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">	&lt;component :is=<span class="string">'com'</span>&gt;&lt;<span class="regexp">/component&gt; /</span><span class="regexp">/通过 :is 属性 指明要变成的组件</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接着在js中注册全局组件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'com2'</span>,&#123;</span><br><span class="line">	template:<span class="string">'&lt;div&gt;组件2 &lt;input type="text" /&gt; &lt;/div&gt;'</span></span><br><span class="line">	</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el:<span class="string">'#app'</span>,</span><br><span class="line">	data:&#123;</span><br><span class="line">		com:<span class="string">'com1'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="动态组件的原理步骤"><a href="#动态组件的原理步骤" class="headerlink" title="动态组件的原理步骤"></a>动态组件的原理步骤</h3><ol>
<li><p>它会根据component 标签里 :is 来寻找Vue实例中 data的数据</p>
</li>
<li><p>这时com指向com1的组件,所以component的内容为com1组件的内容</p>
</li>
<li><p>span标签中 @mouseover=”com=’com2’” 可以提取Vue实例中的data数据,实现动态调整组件</p>
</li>
</ol>
<p>以上就是我对Vue动态组件的一些理解，希望大牛提出一些宝贵的意见，谢谢</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue杂项的基本使用（一）</title>
    <url>/2017/04/15/29-Vue%E6%9D%82%E9%A1%B9%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>杂项是Vue里一个比较零散的知识点，和大家分享一下学习的过程</p>
</blockquote>
<a id="more"></a>

<p>官方文档的杂项说的挺详细的，我这里把知识点归纳一下</p>
<h3 id="编写可复用组件"><a href="#编写可复用组件" class="headerlink" title="编写可复用组件"></a>编写可复用组件</h3><p>在编写组件时，最好考虑好以后是否要进行复用。一次性组件间有紧密的耦合没关系，但是可复用组件应当定义一个清晰的公开接口，同时也不要对其使用的外层数据作出任何假设。</p>
<p>Vue 组件的 API 来自三部分——prop、事件和插槽：</p>
<ol>
<li>Prop 允许外部环境传递数据给组件；</li>
<li>事件允许从组件内触发外部环境的副作用；</li>
<li>插槽允许外部环境将额外的内容组合在组件中。</li>
</ol>
<p>也就是在使用Vue的时候，将多次运用到的内容编写成可重复利用的组件，通俗的说也就是封装，利用Prop，事件或插槽进行与其他组件的交互，这样使代码看起来更为整洁</p>
<h3 id="子组件引用"><a href="#子组件引用" class="headerlink" title="子组件引用"></a>子组件引用</h3><p>其实主要的内容是 ref 的使用，我个人认为这个属性是非常好用的。</p>
<p>为什么要使用ref？ 尽管有 prop 和事件，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 ref 为子组件指定一个引用 ID。</p>
<p>举一个简单的例子,假设com是一个我们写好的组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;		</span><br><span class="line">	&lt;!--为了方面找到 组件对应的dom元素,通过ref指定一个名称--&gt;</span><br><span class="line">	&lt;com ref=<span class="string">'com'</span>&gt;&lt;<span class="regexp">/com&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p>这样子就为com这个组件赋予了一个名为com的ref的属性，来看一下他的作用</p>
<blockquote>
<p>找到页面中的Dom元素</p>
</blockquote>
<ol>
<li>app.$refs 得到页面中所有设置的ref ,返回的是一个对象</li>
<li>app.$refs.com 得到对应的组件 ,是一个对象</li>
<li>app.$refs.com.$el 得到组件的 dom元素</li>
</ol>
<blockquote>
<p>修改组件数据</p>
</blockquote>
<p>假设com组件的data中有msg这个属性，并且使用了，那么这样做是可以直接修改他的数据的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.$refs.com.msg = <span class="string">'修改数据'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>普通的元素 也可以通过ref找到</p>
</blockquote>
<p>不仅仅是组件可以使用ref这个属性，普通的标签也是可以的，有兴趣的小伙伴可以自己去尝试一下，这里就不做太多的说明</p>
<blockquote>
<p>refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅是一个直接操作子组件的应急方案——应当避免在模板或计算属性中使用 refs。</p>
</blockquote>
<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>官方的文档可能看的不是很明白，简单的来说，其实异步组件的目的就在于:</p>
<blockquote>
<p>使用时才装入需要的组件，可以有效的提高首次装入页面的速度。比如在路由切换时</p>
</blockquote>
<p>Vue.js允许将组件定义为一个工厂函数，动态地解析组件的定义。工厂函数接收一个resolve回调，成功获取组件定义时调用。也可以调用reject(reason)指示失败。</p>
<p>可能当当文字不是那么的好理解，我们做一个简单的测试，假设我们有两个组件Home、About。Home组件和首页同步加载，而About组件则按需加载。案例的代码有首页index.html，组件代码about.js构成。</p>
<p>首先是about.js代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'about'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;About page&lt;/div&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>接下来是index.html代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Async Component test&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;router-link to=<span class="string">"/home"</span>&gt;<span class="regexp">/home&lt;/</span>router-link&gt;</span><br><span class="line">    &lt;router-link to=<span class="string">"/about"</span>&gt;<span class="regexp">/about&lt;/</span>router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;<span class="regexp">/router-view&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script src=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script src="https:/</span><span class="regexp">/unpkg.com/</span>vue-router/dist/vue-router.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    function load(componentName, path) &#123;</span></span><br><span class="line"><span class="string">      return new Promise(function(resolve, reject) &#123;</span></span><br><span class="line"><span class="string">        var script = document.createElement('script');</span></span><br><span class="line"><span class="string">        script.src = path;</span></span><br><span class="line"><span class="string">        script.async = true;</span></span><br><span class="line"><span class="string">        script.onload = function() &#123;</span></span><br><span class="line"><span class="string">          var component = Vue.component(componentName);</span></span><br><span class="line"><span class="string">          if (component) &#123;</span></span><br><span class="line"><span class="string">            resolve(component);</span></span><br><span class="line"><span class="string">          &#125; else &#123;</span></span><br><span class="line"><span class="string">            reject();</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string">        script.onerror = reject;</span></span><br><span class="line"><span class="string">        document.body.appendChild(script);</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var router = new VueRouter(&#123;</span></span><br><span class="line"><span class="string">      routes: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          path: '/',</span></span><br><span class="line"><span class="string">          redirect:'/home'</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          path: '/home',</span></span><br><span class="line"><span class="string">          component: &#123;</span></span><br><span class="line"><span class="string">            template: '&lt;div&gt;Home page&lt;/div&gt;'</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          path: '/about',</span></span><br><span class="line"><span class="string">          component: function(resolve, reject) &#123;</span></span><br><span class="line"><span class="string">            load('about', 'about.js').then(resolve, reject);</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    var app = new Vue(&#123;</span></span><br><span class="line"><span class="string">      el: '#app',</span></span><br><span class="line"><span class="string">      router: router,</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了加载在服务器的js文件，我们需要一个HTTP服务器。可以使用node.js的http-server实现。安装并启动一个服务器的方法：</p>
<pre><code>npm install http-server -g
http-server</code></pre><p>访问：</p>
<pre><code>http://127.0.0.1:8080</code></pre><p>我们即可在首页看到home和about的链接，点击home可以显示home组件，点击about，如果还没有加载过，就加载about组件。</p>
<p>对index.html内的代码稍作解释:</p>
<ol>
<li>组件定义为function(resolve, reject) {}函数，其内调用load函数，成功后resolve，否则reject</li>
<li>函数load内通过创建标签script加载指定文件，并通过onload事件当加载完成后，通过Vue.component验证组件，存在就resolve,否则reject</li>
</ol>
<p>以上就是我对Vue杂项的一些理解，希望大牛提出一些宝贵的意见，谢谢</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue杂项的基本使用（二）</title>
    <url>/2017/04/20/30-Vue%E6%9D%82%E9%A1%B9%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>杂项是Vue里一个比较零散的知识点，和大家分享一下学习的过程</p>
</blockquote>
<a id="more"></a>

<h3 id="组件的命名约定"><a href="#组件的命名约定" class="headerlink" title="组件的命名约定"></a>组件的命名约定</h3><p>当注册组件 (或者 prop) 时，可以使用 kebab-case (短横线分隔命名)、camelCase (驼峰式命名) 或 PascalCase (单词首字母大写命名)。</p>
<p>官方的文档说的挺详细的：</p>
<h4 id="在组件定义中"><a href="#在组件定义中" class="headerlink" title="在组件定义中"></a>在组件定义中</h4><pre><code>components: {
  // 使用 kebab-case 注册
  &apos;kebab-cased-component&apos;: { /* ... */ },
  // 使用 camelCase 注册
  &apos;camelCasedComponent&apos;: { /* ... */ },
  // 使用 PascalCase 注册
  &apos;PascalCasedComponent&apos;: { /* ... */ }
}</code></pre><h4 id="在-HTML-模板中始终使用-kebab-case"><a href="#在-HTML-模板中始终使用-kebab-case" class="headerlink" title="在 HTML 模板中始终使用 kebab-case"></a>在 HTML 模板中始终使用 kebab-case</h4><pre><code>&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;
&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;
&lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt;</code></pre><blockquote>
<p>当使用字符串模式时，可以不受 HTML 大小写不敏感的限制。</p>
</blockquote>
<h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>组件在它的模板内可以递归地调用自己。不过，只有当它有 name 选项时才可以这么做：<br>当使用 Vue.component 全局注册了一个组件，全局的 ID 会被自动设置为组件的 name。</p>
<p>举一个简单的递归例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在组件内调用自己本身,一定要添加判断(v-if),否则会死循环</span></span><br><span class="line">&lt;script type=<span class="string">"text/html"</span> id=<span class="string">"component"</span>&gt;		</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;component v-<span class="keyword">if</span>=<span class="string">'ran()&gt;0.1'</span>&gt;&lt;<span class="regexp">/component&gt;</span></span><br><span class="line"><span class="regexp">		显示内容 &#123;&#123; num &#125;&#125;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>div&gt;		</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">`</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果进入死循环，会导致一个“max stack size exceeded”错误，所以要确保递归调用有终止条件 (比如递归调用时使用 v-if 并最终解析为 false)。</p>
</blockquote>
<h3 id="组件间的循环使用"><a href="#组件间的循环使用" class="headerlink" title="组件间的循环使用"></a>组件间的循环使用</h3><p>官方文档举的例子其实挺详细的，通俗一点来说，其实就是组件A想调用组件B，而组件B也想调用组件A，所以引起了冲突。<br>要解决这个问题，我们需要在其中一个组件中告诉模块化管理系统：“A 虽然最后会用到 B，但是不需要优先导入 B”。</p>
<p>所以要等到 beforeCreate 生命周期钩子中才去注册：</p>
<p>底下是官方的例子，什么是生命周期我们后面再进行分享</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的理解，也就是在组件A中使用上面这一串代码，可以再之后引入组件B，从而解决冲突的问题</p>
<h3 id="内联模板"><a href="#内联模板" class="headerlink" title="内联模板"></a>内联模板</h3><p>如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板编写起来更灵活。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;my-component inline-template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;这些将作为组件自身的模板。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;而非父组件透传进来的内容。&lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/my</span>-component&gt;</span><br></pre></td></tr></table></figure>

<p>但是 inline-template 让模板的作用域难以理解。使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素才是最佳实践。</p>
<h3 id="对低开销的静态组件使用v-once"><a href="#对低开销的静态组件使用v-once" class="headerlink" title="对低开销的静态组件使用v-once"></a>对低开销的静态组件使用v-once</h3><p>尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'terms-of-service'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;div v-once&gt;\</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Terms of Service&lt;/h1&gt;\</span></span><br><span class="line"><span class="string">      ...很多静态内容...\</span></span><br><span class="line"><span class="string">    &lt;/div&gt;\</span></span><br><span class="line"><span class="string">  '</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上就是我对Vue杂项的一些理解，希望大牛提出一些宝贵的意见，谢谢</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期的使用</title>
    <url>/2017/04/26/31-Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。</p>
</blockquote>
<a id="more"></a>

<p>上面这些是官方文档给出的定义，简单的来说就是我们什么时候需要它，什么时候调用，官网的图已经写的很详细了，我这里只是稍微归纳一下</p>
<h3 id="钩子函数-组件的生命周期函数"><a href="#钩子函数-组件的生命周期函数" class="headerlink" title="钩子函数(组件的生命周期函数)"></a>钩子函数(组件的生命周期函数)</h3><ol>
<li><p>创建之前: beforeCreate</p>
</li>
<li><p>创建之后: created  –&gt;一般在这个时候进行请求数据</p>
</li>
<li><p>组件挂载之前: beforeMount –&gt;在组件挂载完成之前,组件还没有创建完成,模板还没有生成</p>
</li>
<li><p>组件挂载之后(所有组件挂载完成): mounted –&gt;生成模板,获取模板内容</p>
</li>
<li><p>组件更新之前: beforeUpdate</p>
</li>
<li><p>组件更新之后: updated </p>
</li>
<li><p>组件销毁之前: beforeDestroy –&gt;    this.$refs.com1.$destroy();</p>
</li>
<li><p>组件销毁之后: destroyed </p>
</li>
</ol>
<blockquote>
<p>所有的组件都是 依次 创建之前 -&gt;创建完成 -&gt; 挂载之前 -&gt; 然后等所有的组件 挂载完成 -&gt;再依次执行挂载完成函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	Vue.component(<span class="string">'com'</span>,&#123;</span><br><span class="line">		template:<span class="string">'#com'</span>,</span><br><span class="line">		data()&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//组件创建之前,</span></span><br><span class="line">		beforeCreate()&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'组件创建之前'</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//组件创建完成</span></span><br><span class="line">		created()&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'组件创建完成'</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//组件挂载之前</span></span><br><span class="line">		beforeMount()&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'组件挂载之前'</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//组件挂载完成</span></span><br><span class="line">		mounted()&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'组件挂载完成'</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//组件更新之前</span></span><br><span class="line">		beforeUpdate()&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'组件更新之前'</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//组件更新之后</span></span><br><span class="line">		updated()&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'组件更新之后'</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//组件销毁之前</span></span><br><span class="line">		beforeDestroy()&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'组件销毁之前'</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//组件销毁之后</span></span><br><span class="line">		destroyed()&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'组件销毁之后'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">		el:<span class="string">'#app'</span>,</span><br><span class="line">		data:&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;,</span><br><span class="line">		methods:&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>生命周期比较常用到的地方</p>
</blockquote>
<p>created：一般请求数据是在这边</p>
<p>mounted：一些监听的方法放在这边</p>
<p>以上就是我对Vue生命周期的一些理解，希望大牛提出一些宝贵的意见，谢谢</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue过渡动画</title>
    <url>/2017/05/02/32-Vue%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。今天和大家分享一下学习的过程</p>
</blockquote>
<a id="more"></a>

<p>过渡的方法可以由以下几种进行实现：</p>
<ol>
<li>在 CSS 过渡和动画中自动应用 class</li>
<li>可以配合使用第三方 CSS 动画库，如 Animate.css</li>
<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>
<li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li>
</ol>
<h1 id="在CSS中设置过渡效果"><a href="#在CSS中设置过渡效果" class="headerlink" title="在CSS中设置过渡效果"></a>在CSS中设置过渡效果</h1><blockquote>
<p>transition 标签里 放入需要过渡的内容</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;transition name=<span class="string">'fade'</span>&gt;</span><br><span class="line">	&lt;div v-<span class="keyword">if</span>=<span class="string">"seen"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是要过渡的内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>transition&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在style中写入过渡的内容，假设过渡的名字为fade，实现淡入淡出的效果</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">	.fade-enter-active&#123;</span><br><span class="line">		<span class="comment">/* 进入完成 */</span></span><br><span class="line">		transition: all <span class="number">1</span>s ease;</span><br><span class="line">		opacity: <span class="number">1</span>; 	</span><br><span class="line">	&#125;</span><br><span class="line">	.fade-enter&#123;</span><br><span class="line">		<span class="comment">/* 进入之前 */</span></span><br><span class="line">		opacity: <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.fade-leave-active&#123;</span><br><span class="line">		<span class="comment">/* 离开完成 */</span></span><br><span class="line">		transition: all <span class="number">1</span>s linear;</span><br><span class="line">		opacity: <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	.fade-leave&#123;</span><br><span class="line">		<span class="comment">/* 离开之前 */</span></span><br><span class="line">		opacity: <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理稍微介绍一下</p>
</blockquote>
<ol>
<li><p>transition 标签 vue 会自动给其加上对应的样式(v-enter v-enter-active v-leave v-leave-active),v则是我们定义的name的值</p>
</li>
<li><p>带 active 的样式 一定要写在对应的非 active 样式之前</p>
</li>
</ol>
<h1 id="在CSS中设置动画效果"><a href="#在CSS中设置动画效果" class="headerlink" title="在CSS中设置动画效果"></a>在CSS中设置动画效果</h1><p>之前是过渡，现在我们来看一下动画是怎么实现的，方法和过渡差不多：</p>
<p>一、首先将需要执行动画的元素放到 transition 标签内</p>
<p>二、其次给transition标签起一个名字,transition name=’bounce’,Vue会自动为transition标签里的目标元素，在适当的添加或删除 </p>
<blockquote>
<p>我们来看一下Vue自动生成的类有哪些：</p>
</blockquote>
<ol>
<li>v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</li>
<li>v-enter-active: 定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition/animation 完成之后移除。 这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</li>
<li>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入一帧后生效（于此同时 v-enter 被删除），在 transition/animation 完成之后移除。</li>
<li>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</li>
<li>v-leave-active: 定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition/animation 完成之后移除。 这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</li>
<li>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发一帧后生效（于此同时 v-leave 被删除），在 transition/animation 完成之后移除。</li>
</ol>
<p>三、在style中定义动画 animation: bounce-in 1s ease-in; 这里只是举个例子，animation可以根据具体的情况自行定义</p>
<p>四、再将动画补全 @keyframes bounce-in{ }，@keyframes的内容根据自身需求来写</p>
<blockquote>
<p>补充</p>
</blockquote>
<ol>
<li>v- 是这些类名的前缀。使用 <transition name="bounce"> 可以重置前缀</li>
<li>可以在transition标签中添加 :duration=”{ enter: 500, leave: 800 }” 来控制时间</li>
</ol>
<h1 id="依据动画库设置动画"><a href="#依据动画库设置动画" class="headerlink" title="依据动画库设置动画"></a>依据动画库设置动画</h1><ol>
<li>首先引入animate.css</li>
<li>将自定义动画的动画内容 放入transition标签内</li>
<li>将需要的动画 放在 animated后面,注意前面的class,一定要加</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">	name=<span class="string">'custom'</span></span><br><span class="line">	enter-active-<span class="class"><span class="keyword">class</span></span>=<span class="string">'animated bounceInLeft'</span></span><br><span class="line">	leave-active-<span class="class"><span class="keyword">class</span></span>=<span class="string">'animated bounceOutRight'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h1 id="在javascript标签中设置动画"><a href="#在javascript标签中设置动画" class="headerlink" title="在javascript标签中设置动画"></a>在javascript标签中设置动画</h1><p>这里举一个简单的例子，可以去官方文档查看一下具体的例子</p>
<p>一、首先在transition标签中,写入响应的事件,后面’’中填写的是函数名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">	name=<span class="string">'fade'</span></span><br><span class="line">	@before-enter=<span class="string">'beforeEnter'</span></span><br><span class="line">	@enter=<span class="string">'enter'</span></span><br><span class="line">	@before-leave=<span class="string">'beforeLeave'</span></span><br><span class="line">	@leave=<span class="string">"leave"</span>	</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>二、在Vue的实例中,methods里面写入实现相应的函数</p>
<blockquote>
<p>一定要注意,函数需要传入参数,在enter 和 leave 的函数中,要调用 done()，当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。否则，它们会被同步调用，过渡会立即完成</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeEnter(el) &#123;</span><br><span class="line">	$(el).css(&#123;</span><br><span class="line">		opacity : <span class="number">0</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">enter(el,done)&#123;</span><br><span class="line">	$(el).animate(&#123;</span><br><span class="line">		opacity : <span class="number">1</span></span><br><span class="line">	&#125;,<span class="number">1000</span>,<span class="string">'linear'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		done()</span><br><span class="line">	&#125;)	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动画的效果根据实际的情况进行描写，这里只是介绍了一种动画钩子，还有很多的动画钩子有兴趣的可以去试一下，运用的原理是一样的</p>
<h1 id="常见的javascript动画钩子有哪些"><a href="#常见的javascript动画钩子有哪些" class="headerlink" title="常见的javascript动画钩子有哪些"></a>常见的javascript动画钩子有哪些</h1><ol>
<li>@before-enter=”beforeEnter”</li>
<li>@enter=”enter” //调用done()</li>
<li>@after-enter=”afterEnter”</li>
<li>@enter-cancelled=”enterCancelled” //动画取消进入触发</li>
<li>@before-leave=”beforeLeave”</li>
<li>@leave=”leave”//调用done()</li>
<li>@after-leave=”afterLeave”</li>
<li>@leave-cancelled=”leaveCancelled” //动画取消离开触发,leaveCancelled 只用于 v-show 中</li>
</ol>
<h1 id="初始化渲染"><a href="#初始化渲染" class="headerlink" title="初始化渲染"></a>初始化渲染</h1><blockquote>
<p>在transition标签中写入appear属性, vue会加上这个初始渲染动画,和过渡一样，同样也可以自定义 CSS 类名,自定义 JavaScript 钩子.</p>
</blockquote>
<p>定义CSS类名:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  appear</span><br><span class="line">  appear-<span class="class"><span class="keyword">class</span></span>=<span class="string">"custom-appear-class"</span></span><br><span class="line">  appear-to-<span class="class"><span class="keyword">class</span></span>=<span class="string">"custom-appear-to-class"</span> (<span class="number">2.1</span><span class="number">.8</span>+)</span><br><span class="line">  appear-active-<span class="class"><span class="keyword">class</span></span>=<span class="string">"custom-appear-active-class"</span></span><br><span class="line">&gt;</span><br><span class="line">&lt;<span class="regexp">/transition&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义 JavaScript 钩子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">	appear</span><br><span class="line">	@before-appear=<span class="string">'beforeAppear'</span></span><br><span class="line">	@appear=<span class="string">'appear'</span></span><br><span class="line">	@before-enter=<span class="string">'beforeEnter'</span></span><br><span class="line">	@enter=<span class="string">'enter'</span></span><br><span class="line">	@before-leave=<span class="string">'beforeLeave'</span></span><br><span class="line">	@leave=<span class="string">'leave'</span></span><br><span class="line">	:css=<span class="string">'false'</span></span><br><span class="line">	&gt;</span><br><span class="line">&lt;<span class="regexp">/transition&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>分享一下学习的体会</p>
</blockquote>
<ol>
<li>before-appear是初始动画之前 </li>
<li>appear为开始初始动画,这样写的好处是不影响我们进行动画的切换</li>
<li>css属性: 有时候有css过渡 ,如果说为false,Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响</li>
</ol>
<h1 id="多元素过渡"><a href="#多元素过渡" class="headerlink" title="多元素过渡"></a>多元素过渡</h1><p>文档给出了例子，我这里就不再重复了，归纳一下具体的一些知识点</p>
<ul>
<li>transition 标签中要添加 mode=”out-in” <ul>
<li>in-out: 新元素先进行过渡，完成之后当前元素过渡离开。</li>
<li>out-in: 当前元素先进行过渡，完成之后新元素过渡进入。</li>
</ul>
</li>
<li>一般来说transition 标签只能有一个标签在最外层,但是可以用v-if来控制</li>
<li>相同标签名进行 if else 切换,一定要加上 key且值要不一样</li>
</ul>
<h1 id="多组件过渡"><a href="#多组件过渡" class="headerlink" title="多组件过渡"></a>多组件过渡</h1><p>多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;transition name=<span class="string">"component-fade"</span> mode=<span class="string">"out-in"</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">"view"</span>&gt;&lt;<span class="regexp">/component&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>transition&gt;</span><br></pre></td></tr></table></figure>

<p>在CSS中写入过渡:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.component-fade-enter-active, .component-fade-leave-active &#123;</span><br><span class="line">  transition: opacity <span class="number">.3</span>s ease;</span><br><span class="line">&#125;</span><br><span class="line">.component-fade-enter, .component-fade-leave-to</span><br><span class="line"><span class="comment">/* .component-fade-leave-active for below version 2.1.8 */</span> &#123;</span><br><span class="line">  opacity: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h1><p>与transition不同,列表过渡使用的是:transition-group 过渡组</p>
<blockquote>
<p>不同于 transition标签,它会以一个真实元素呈现：默认为一个 <span>。你也可以通过 tag 特性更换为其他元素。内部元素 总是需要 提供唯一的 key 属性值,添加的class 会传递到 生成的标签上</p>
</blockquote>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;transition-group name=<span class="string">"list"</span> tag=<span class="string">"div"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">'aa'</span>&gt;</span><br><span class="line">    &lt;span v-<span class="keyword">for</span>=<span class="string">"item in items"</span> v-bind:key=<span class="string">"item"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"list-item"</span>&gt;</span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>transition-group&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><transition-group> 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。<br>要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用</p>
</blockquote>
<p>例如: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.list-move&#123;</span><br><span class="line">	transition: all <span class="number">0.4</span>s linear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>需要在 list-leave-active 中添加  position: absolute  目的是让他不占位置</li>
<li>过渡的元素最好display: inline-block,因为transform适用所有块元素以及某些行内元素(但是不包括span)</li>
</ol>
<p>官方文档给出了更为详细的例子，有兴趣的小伙伴可以去看一下</p>
<p>这篇的过渡动画写的有点略长，以上就是我对Vue过渡动画的一些理解，有哪里不对的欢迎提出</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue过渡动画的demo</title>
    <url>/2017/05/10/33-Vue%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E7%9A%84%E5%B0%8F%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>上一篇的博客写了Vue的过渡动画，今天写几个小demo来实践一下</p>
</blockquote>
<a id="more"></a>

<p>demo实现三原色的配比，废话不多说，直接上代码,复制可以直接使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">		&lt;title&gt;取色&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">		&lt;script src="https:/</span><span class="regexp">/unpkg.com/</span>vue<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">		&lt;style type="</span>text/css<span class="string">"&gt;</span></span><br><span class="line"><span class="string">			body&#123;</span></span><br><span class="line"><span class="string">				text-align: center;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			#colordiv&#123;</span></span><br><span class="line"><span class="string">				width: 500px;</span></span><br><span class="line"><span class="string">				height: 500px;</span></span><br><span class="line"><span class="string">				margin: 0 auto;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			input[type=range] &#123;</span></span><br><span class="line"><span class="string">			    -webkit-appearance: none;</span></span><br><span class="line"><span class="string">			    width: 400px;</span></span><br><span class="line"><span class="string">			    border-radius: 10px; /*这个属性设置使填充进度条时的图形为圆角*/</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			input[type=range]::-webkit-slider-runnable-track &#123;</span></span><br><span class="line"><span class="string">			    height: 15px;</span></span><br><span class="line"><span class="string">			    border-radius: 10px; /*将轨道设为圆角的*/</span></span><br><span class="line"><span class="string">			    box-shadow: 0 1px 1px #def3f8, inset 0 .125em .125em #0d1112; /*轨道内置阴影效果*/</span></span><br><span class="line"><span class="string">			&#125;  </span></span><br><span class="line"><span class="string">			input[type=range]:focus &#123;</span></span><br><span class="line"><span class="string">			    outline: none; </span></span><br><span class="line"><span class="string">			    /*滑动时去掉外边框*/</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			input[type=range]::-webkit-slider-thumb &#123;</span></span><br><span class="line"><span class="string">			    -webkit-appearance: none;</span></span><br><span class="line"><span class="string">			    height: 25px;</span></span><br><span class="line"><span class="string">			    width: 25px;</span></span><br><span class="line"><span class="string">			    margin-top: -5px;/*使滑块超出轨道部分的偏移量相等*/</span></span><br><span class="line"><span class="string">			    background: #ffffff;</span></span><br><span class="line"><span class="string">			    border-radius: 50%; /*外观设置为圆形*/</span></span><br><span class="line"><span class="string">			    border: solid 0.125em rgba(205, 224, 230, 0.5); /*设置边框*/</span></span><br><span class="line"><span class="string">			    box-shadow: 0 .125em .125em #3b4547; /*添加底部阴影*/</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&lt;/style&gt;</span></span><br><span class="line"><span class="string">	&lt;/head&gt;</span></span><br><span class="line"><span class="string">	&lt;body&gt;</span></span><br><span class="line"><span class="string">		&lt;div id="</span>app<span class="string">"&gt;</span></span><br><span class="line"><span class="string">			&lt;div id="</span>colordiv<span class="string">" :style="</span>color<span class="string">"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">			&lt;br /&gt;&lt;br /&gt;</span></span><br><span class="line"><span class="string">			红色配比:&#123;&#123; Math.floor( hong / 255 * 100) &#125;&#125;%&lt;input v-model="</span>hong<span class="string">" type="</span>range<span class="string">" name="</span>range<span class="string">" id="</span>range<span class="string">" value="</span>hong<span class="string">" max="</span><span class="number">255</span><span class="string">" step="</span><span class="number">1</span><span class="string">" :style="</span>redcolor<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">			&lt;br /&gt;&lt;br /&gt;</span></span><br><span class="line"><span class="string">			绿色配比:&#123;&#123; Math.floor( lv / 255 * 100) &#125;&#125;%&lt;input v-model="</span>lv<span class="string">" type="</span>range<span class="string">" name="</span>range<span class="string">" id="</span>range<span class="string">" value="</span>lv<span class="string">" max="</span><span class="number">255</span><span class="string">" step="</span><span class="number">1</span><span class="string">" :style="</span>lvcolor<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">			&lt;br /&gt;&lt;br /&gt;</span></span><br><span class="line"><span class="string">			蓝色配比:&#123;&#123; Math.floor( lan / 255 * 100) &#125;&#125;%&lt;input v-model="</span>lan<span class="string">" type="</span>range<span class="string">" name="</span>range<span class="string">" id="</span>range<span class="string">" value="</span>lan<span class="string">" max="</span><span class="number">255</span><span class="string">" step="</span><span class="number">1</span><span class="string">" :style="</span>lancolor<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">		&lt;/div&gt;</span></span><br><span class="line"><span class="string">	&lt;/body&gt;</span></span><br><span class="line"><span class="string">	&lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		var div = document.getElementById('colordiv');		</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		var app = new Vue(&#123;</span></span><br><span class="line"><span class="string">			el:'#app',</span></span><br><span class="line"><span class="string">			data:&#123;</span></span><br><span class="line"><span class="string">				hong:0,</span></span><br><span class="line"><span class="string">				lv:0,</span></span><br><span class="line"><span class="string">				lan:0,</span></span><br><span class="line"><span class="string">				color:&#123;</span></span><br><span class="line"><span class="string">					background:'black'</span></span><br><span class="line"><span class="string">				&#125;,</span></span><br><span class="line"><span class="string">				redcolor:&#123;</span></span><br><span class="line"><span class="string">					background: '-webkit-linear-gradient(red,red) no-repeat',</span></span><br><span class="line"><span class="string">					backgroundSize:' 0% 100%'</span></span><br><span class="line"><span class="string">				&#125;,</span></span><br><span class="line"><span class="string">				lvcolor:&#123;</span></span><br><span class="line"><span class="string">					background: '-webkit-linear-gradient(green,green) no-repeat',</span></span><br><span class="line"><span class="string">					backgroundSize:' 0% 100%'</span></span><br><span class="line"><span class="string">				&#125;,</span></span><br><span class="line"><span class="string">				lancolor:&#123;</span></span><br><span class="line"><span class="string">					background: '-webkit-linear-gradient(blue,blue) no-repeat',</span></span><br><span class="line"><span class="string">					backgroundSize:'0% 100%'</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">			&#125;,</span></span><br><span class="line"><span class="string">			methods:&#123;</span></span><br><span class="line"><span class="string">				</span></span><br><span class="line"><span class="string">			&#125;,</span></span><br><span class="line"><span class="string">			computed:&#123;</span></span><br><span class="line"><span class="string">				change()&#123;</span></span><br><span class="line"><span class="string">					this.color.background = "</span>rgb(<span class="string">" + Number(this.hong) + "</span>,<span class="string">"+ Number(this.lv) +"</span>,<span class="string">"+ Number(this.lan) +"</span>)<span class="string">";</span></span><br><span class="line"><span class="string">					this.redcolor.backgroundSize = Math.floor( this.hong / 255 * 100) + '% 100%';</span></span><br><span class="line"><span class="string">					this.lvcolor.backgroundSize = Math.floor( this.lv / 255 * 100) + '% 100%';</span></span><br><span class="line"><span class="string">					this.lancolor.backgroundSize = Math.floor( this.lan / 255 * 100) + '% 100%';</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">			&#125;,</span></span><br><span class="line"><span class="string">			updated()&#123;</span></span><br><span class="line"><span class="string">				this.change</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			</span></span><br><span class="line"><span class="string">		&#125;)</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">	&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>


<p>这个demo实现81个单元格随机变化位置，样式,使用到lodash库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">		&lt;title&gt;Vue&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">		&lt;meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no"&gt;</span></span><br><span class="line"><span class="regexp">		&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"&gt;</span></span><br><span class="line"><span class="regexp">		&lt;script src="https:/</span><span class="regexp">/unpkg.com/</span>vue<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">		&lt;!-- 导入 lodash库--&gt;</span></span><br><span class="line"><span class="string">		&lt;script src="</span>https:<span class="comment">//cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line">		&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">			.list-box &#123;</span><br><span class="line">				width: <span class="number">540</span>px;</span><br><span class="line">				height: <span class="number">540</span>px;</span><br><span class="line">				margin: <span class="number">0</span> auto;</span><br><span class="line">				margin-top: <span class="number">30</span>px;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			.list-box span &#123;</span><br><span class="line">				display: inline-block;</span><br><span class="line">				float: left;</span><br><span class="line">				border: 1px solid #ccc;</span><br><span class="line">				width: <span class="number">59</span>px;</span><br><span class="line">				height: <span class="number">59</span>px;</span><br><span class="line">				margin-left: <span class="number">-1</span>px;</span><br><span class="line">				margin-top: <span class="number">-1</span>px;</span><br><span class="line">				text-align: center;</span><br><span class="line">				line-height: <span class="number">59</span>px;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 平移动画 */</span></span><br><span class="line">			</span><br><span class="line">			.list-move &#123;</span><br><span class="line">				transition: all <span class="number">1</span>s linear;</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">			&lt;button @click=<span class="string">"shuffle"</span>&gt;打乱&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">			&lt;transition-group name="list" tag="div" class="list-box"&gt;</span></span><br><span class="line"><span class="regexp">				&lt;span v-for="num in nums" :key="num" :style="&#123;background: colors[num]&#125;"&gt;&#123;&#123;num + 1&#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">			&lt;<span class="regexp">/transition-group&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>div&gt;</span><br><span class="line">	&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">	&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">		var app = new Vue(&#123;</span></span><br><span class="line"><span class="string">			el: '#app',</span></span><br><span class="line"><span class="string">			data: &#123;</span></span><br><span class="line"><span class="string">				message: 'Hello Vue!',</span></span><br><span class="line"><span class="string">				nums: new Array(81).fill(1).map((v, i) =&gt; i),</span></span><br><span class="line"><span class="string">				colors: []</span></span><br><span class="line"><span class="string">			&#125;,</span></span><br><span class="line"><span class="string">			methods: &#123;</span></span><br><span class="line"><span class="string">				shuffle() &#123;</span></span><br><span class="line"><span class="string">					this.nums = _.shuffle(this.nums)</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">			&#125;,</span></span><br><span class="line"><span class="string">			created() &#123;</span></span><br><span class="line"><span class="string">				// 修改颜色</span></span><br><span class="line"><span class="string">				this.colors = new Array(81).fill(1).map(() =&gt; &#123;</span></span><br><span class="line"><span class="string">					var r = Math.floor(Math.random() * 128 + 128)</span></span><br><span class="line"><span class="string">					var g = Math.floor(Math.random() * 128 + 128)</span></span><br><span class="line"><span class="string">					var b = Math.floor(Math.random() * 128 + 128)</span></span><br><span class="line"><span class="string">					return `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`</span></span><br><span class="line"><span class="string">				&#125;)</span></span><br><span class="line"><span class="string">			&#125;,</span></span><br><span class="line"><span class="string">			mounted() &#123;</span></span><br><span class="line"><span class="string">				console.log(this.colors);</span></span><br><span class="line"><span class="string">				setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="string">					this.shuffle()</span></span><br><span class="line"><span class="string">				&#125;, 2000)</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;)</span></span><br><span class="line"><span class="string">	&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue状态过渡</title>
    <url>/2017/06/20/34-Vue%E7%8A%B6%E6%80%81%E8%BF%87%E6%B8%A1/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢，Vue使用第三方库来实现切换元素的过渡状态。</p>
</blockquote>
<a id="more"></a>

<p>数据元素本身的动效有哪些？</p>
<ol>
<li>数字和运算</li>
<li>颜色的显示</li>
<li>SVG 节点的位置</li>
<li>元素的大小和其他的属性</li>
</ol>
<p>之前在讲计算属性的时候有提到过，Vue提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性(watch)。那个时候说一般都是使用computed，但是存在即是有道理的，watch有他自己的优势。</p>
<p>先来看一个例子，输入数字后，数字做动画效果，使用Tweenjs：</p>
<p>首先导入 <a href="https://fastly.jsdelivr.net/npm/tween.js@16.3.4" target="_blank" rel="noopener">https://fastly.jsdelivr.net/npm/tween.js@16.3.4</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">	&lt;input type=<span class="string">"number"</span> v-model=<span class="string">"number"</span>&gt;</span><br><span class="line">	&#123;&#123; animateNumber &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el:<span class="string">'#app'</span>,</span><br><span class="line">	data:&#123;</span><br><span class="line">		number:<span class="number">0</span>,</span><br><span class="line">		animateNumber:<span class="number">0</span></span><br><span class="line">	&#125;,</span><br><span class="line">	watch:&#123; <span class="comment">//watch 观察,可以指定观察的属性(数据),属性一旦发生改变,就会调用观察所对应属性的 函数</span></span><br><span class="line">	  number(newValue,oldValue)&#123;<span class="comment">//传入两个值，一个新的，一个旧的</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">var</span> vm = <span class="keyword">this</span>;<span class="comment">//接收this，下面赋值用到</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">var</span> tween = <span class="keyword">new</span> TWEEN.Tween(&#123;</span><br><span class="line">			x : oldValue</span><br><span class="line">		&#125;)</span><br><span class="line">		.to(&#123;</span><br><span class="line">			x : newValue</span><br><span class="line">		&#125;,<span class="number">2000</span>)</span><br><span class="line">		.easing(TWEEN.Easing.Elastic.InOut)<span class="comment">//过渡形式,有很多种</span></span><br><span class="line">		.onUpdate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//监听更新</span></span><br><span class="line">			vm.animateNumber = <span class="keyword">this</span>.x.toFixed(<span class="number">0</span>)<span class="comment">//将平滑值赋值</span></span><br><span class="line">		&#125;)</span><br><span class="line">		.start();<span class="comment">// 开启启动动画</span></span><br><span class="line">		</span><br><span class="line">		animate();<span class="comment">//运行动画效果</span></span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">animate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="comment">//TWEEN.update() 触发更新方法</span></span><br><span class="line">	        <span class="keyword">if</span> (TWEEN.update()) &#123;</span><br><span class="line">				<span class="comment">//请求帧动画的方法				        </span></span><br><span class="line">	        	requestAnimationFrame(animate)</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>直接在代码里解释比较详细，在官网的例子上做了些注释，更多的例子可以去官网学习一下。</p>
<p>以上就是我对Vue状态过渡的一些理解，有哪里不对的欢迎提出</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue混合对象</title>
    <url>/2017/07/15/36-Vue%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>混合 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。</p>
</blockquote>
<a id="more"></a>

<p>在看vue的混合对象之前，我们先了解一下其他混合对象的方法</p>
<ol>
<li><p>for 循环</p>
<pre><code>for(var value in obj){
    zhangsan[value] = obj[value]
}</code></pre></li>
<li><p>$.extend</p>
<pre><code>var newzhangsan = $.extend(true,{},zhangsan,obj);</code></pre></li>
<li><p>es6方法</p>
<pre><code>console.log(Object.assign(zhangsan,obj));</code></pre></li>
<li><p>es7方法</p>
<pre><code>console.log({...zhangsan,...obj});//如果是数组就用[]</code></pre></li>
<li><p>lodash 方法, 一旦设置了相同属性的值，后续的将被忽略掉。</p>
<pre><code>console.log(_.defaultsDeep(zhangsan,zhangsi));</code></pre></li>
</ol>
<p>接下来我们看一下Vue的方法，官方的文档对这一个模块也讲的挺详细的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myMixin &#x3D; Vue.extend(&#123;	&#x2F;&#x2F;定义混合 混合的作用:代码的复用性</span><br><span class="line">	data()&#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			author: &#39;Mr.chen&#39;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	created()&#123; 		&#x2F;&#x2F;每一次调用或者引入都会执行</span><br><span class="line">		console.log(&#39;作者&#39; + this.author)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;com1&#39;,&#123;</span><br><span class="line">	mixins:[myMixin], 	&#x2F;&#x2F;混合过来多个对象, mixins固定用法</span><br><span class="line">	</span><br><span class="line">	template:&#96;&lt;div&gt;&#123;&#123;message&#125;&#125;的作者是 &#123;&#123; author &#125;&#125;&lt;&#x2F;div&gt;&#96;,</span><br><span class="line">	data()&#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			message:&#39;javascript&#39;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	created()&#123;</span><br><span class="line">		console.log(&#39;你好世界&#39;)</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>关于混合对象我也只是稍微了解了一下，在实际中并没有用到，有兴趣的小伙伴可以自行去官网上研究。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue自定义指令</title>
    <url>/2017/07/03/35-Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。关于自定义指令，官网讲的很详细，我只是讲一下学习的过程</p>
</blockquote>
<a id="more"></a>

<h3 id="Vue的自定义指令"><a href="#Vue的自定义指令" class="headerlink" title="Vue的自定义指令"></a>Vue的自定义指令</h3><ul>
<li><p>Vue.directive()定义指令的方式,</p>
</li>
<li><p>参数1 为 指令名 写的时候不加v-  用的时候要加    </p>
</li>
<li><p>参数2 为 对象—-对象的内容:(对象提供定义指令的几个钩子函数(可选))</p>
</li>
<li><p>bind：指令第一次绑定到元素时调用，只会调用一次。</p>
</li>
<li><p>inserted：被绑定的元素插入到父节点时调用。</p>
</li>
<li><p>update：被绑定的元素在模板更新后调用。</p>
</li>
<li><p>componentUpdated：被绑定元素模板完成一次周期更新时调用</p>
</li>
<li><p>unbind：在指令从元素上解除绑定时调用，只会调用一次。</p>
</li>
</ul>
<p>举个简单的例子:假设我有三个输入框，利用自定义指令，将输入框每隔一秒，依次获取焦点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">	&lt;input type=<span class="string">"text"</span> v-focus&gt;</span><br><span class="line">	&lt;input type=<span class="string">"text"</span> v-focus&gt;</span><br><span class="line">	&lt;input type=<span class="string">"text"</span> v-focus&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;	<span class="comment">// 当绑定的元素插入到 DOM 时调用此函数……</span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">  	i++;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	el.focus(); <span class="comment">// 元素调用 focus 获取焦点   	</span></span><br><span class="line">    &#125;,<span class="number">1000</span> * i)<span class="comment">//定义一个i 第一次执行1秒 第二次 执行 2秒 第三次 执行 3秒  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>自定义指令讲的不是很详细，更多的需要自己去实践一下才知道，有哪里不对的地方欢迎提出。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue路由入门</title>
    <url>/2017/07/29/37-Vue%E8%B7%AF%E7%94%B1%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Vue大多数是单页面应用，跳转的功能使用的不是a标签，而是vue-router</p>
</blockquote>
<a id="more"></a>

<p>vue-router是Vue中非常重要的知识点，官方也特地出了一个文档来专门介绍路由,官网写的非常详细，我只是分享一下我的学习心得</p>
<h3 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/unpkg.com/</span>vue-router/dist/vue-router.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;div id="</span>app<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;</span></span><br><span class="line"><span class="string">    &lt;!-- 使用 router-link 组件来导航. --&gt;</span></span><br><span class="line"><span class="string">    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></span><br><span class="line"><span class="string">    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span><br><span class="line"><span class="string">    &lt;router-link to='/home'&gt;首页&lt;/router-link&gt; </span></span><br><span class="line"><span class="string">	&lt;!-- query 与  params 为固定写法  会根据这两个进行寻找参数--&gt;</span></span><br><span class="line"><span class="string">	&lt;router-link :to='&#123;path:"</span>/user/<span class="number">123</span><span class="string">",query:&#123;page:2&#125;&#125;'&gt;测试一&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">	&lt;router-link :to='&#123;name:"</span>user<span class="string">",params:&#123;id:2&#125;&#125;'&gt;测试二&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">  &lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;!-- 路由出口 --&gt;</span></span><br><span class="line"><span class="string">  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line"><span class="string">  &lt;!-- router-view 存放组件的容器 --&gt;</span></span><br><span class="line"><span class="string">  &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="javaScript"><a href="#javaScript" class="headerlink" title="javaScript"></a>javaScript</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义（路由）组件。可以从其他文件 import 进来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> home = &#123;<span class="attr">template</span>:<span class="string">`&lt;main class='a'&gt;&lt;h1&gt;次页面是首页&lt;/h1&gt;&lt;/main&gt;`</span>&#125;</span><br><span class="line"><span class="keyword">var</span> info = &#123;<span class="attr">template</span>:<span class="string">`&lt;main class='b'&gt;&lt;h1&gt;次页面是测试&lt;/h1&gt;&lt;/main&gt;`</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置路由对应页面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> routes = [</span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/home'</span>,<span class="attr">component</span>:home&#125;,</span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">'user'</span>,<span class="attr">path</span>:<span class="string">'/user/:id'</span>,<span class="attr">component</span>:user&#125;, <span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 router 实例，然后传 routes配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">	routes <span class="comment">// 路由规则,路由的信息 （缩写）相当于 routes: routes</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建和挂载根实例。记得要通过 router 配置参数注入路由，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el: <span class="string">'#app'</span>,</span><br><span class="line">	data: &#123;		</span><br><span class="line">	&#125;,</span><br><span class="line">	router ,<span class="comment">//指定使用哪一个路由</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上就是Vue路由的基础功能，可以实现简单的跳转，有什么不对的地方欢迎提出</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue嵌套路由</title>
    <url>/2017/08/14/38-Vue%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件</p>
</blockquote>
<a id="more"></a>

<p>嵌套路由字面上就是路由中嵌套的一个或多个子路由，我直接把完整的代码贴出来，在代码中做解释，看的比较清楚一点,复制后可直接运行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;meta charset="utf-8"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script src="http:/</span><span class="regexp">/unpkg.com/</span>vue/dist/vue.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;script src="</span>https:<span class="comment">//unpkg.com/vue-router/dist/vue-router.js"&gt;&lt;/script&gt;</span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt; </span></span><br><span class="line"><span class="regexp">  &lt;div id="box"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;router-link to="/</span>home<span class="string">"&gt;home&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">      &lt;router-link to="</span>/news<span class="string">"&gt;news&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">    &lt;/p&gt;</span></span><br><span class="line"><span class="string">     &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  &lt;!-- 模板抽离出来 --&gt;</span></span><br><span class="line"><span class="string">  &lt;template id="</span>home<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;!-- 注意：组件只能有一个根元素，所以我们包装到这个div中 --&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;首页&lt;/h2&gt;</span></span><br><span class="line"><span class="string">       &lt;router-link to="</span>/home/login<span class="string">"&gt;登录&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">      &lt;router-link to="</span>/home/reg<span class="string">"&gt;注册&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">      &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line"><span class="string">      &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  &lt;template id="</span>news<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;新闻&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  &lt;template id="</span>login<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;登录界面&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string">  &lt;template id="</span>reg<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;注册界面&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    // 1. 定义（路由）组件。</span></span><br><span class="line"><span class="string">    const Home = &#123; template: '#home' &#125;;</span></span><br><span class="line"><span class="string">    const News = &#123; template: '#news' &#125;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    const Login = &#123; template: '#login' &#125;;</span></span><br><span class="line"><span class="string">    const Reg = &#123; template: '#reg' &#125;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    // 2. 定义路由</span></span><br><span class="line"><span class="string">    const routes = [</span></span><br><span class="line"><span class="string">       &#123; path: '/', redirect: '/home' &#125;,</span></span><br><span class="line"><span class="string">      &#123; </span></span><br><span class="line"><span class="string">        path: '/home', </span></span><br><span class="line"><span class="string">        component: Home, </span></span><br><span class="line"><span class="string">        children:[</span></span><br><span class="line"><span class="string">          &#123; path: '/home/login', component: Login&#125;,</span></span><br><span class="line"><span class="string">          &#123; path: '/home/reg', component: Reg&#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123; path: '/news', component: News&#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    // 3. 创建 router 实例，然后传 `routes` 配置</span></span><br><span class="line"><span class="string">    const router = new VueRouter(&#123;</span></span><br><span class="line"><span class="string">      routes // （缩写）相当于 routes: routes</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    // 4. 创建和挂载根实例。</span></span><br><span class="line"><span class="string">    // 记得要通过 router 配置参数注入路由，</span></span><br><span class="line"><span class="string">    // 从而让整个应用都有路由功能</span></span><br><span class="line"><span class="string">    const app = new Vue(&#123;</span></span><br><span class="line"><span class="string">     router</span></span><br><span class="line"><span class="string">    &#125;).$mount('#box')</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    // 现在，应用已经启动了！</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>要注意，以 / 开头的嵌套路径会被当作根路径，这让你充分的使用嵌套组件而无须设置嵌套的路径，children 配置就是像 routes 配置一样的路由配置数组，所以呢，你可以嵌套多层路由。</p>
<p>以上就是我对Vue嵌套路由的一些理解，有不对的地方欢迎提出</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的编程式导航</title>
    <url>/2017/08/30/39-Vue%E7%9A%84%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>除了使用 <router-link> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p>
</blockquote>
<a id="more"></a>

<h2 id="router-push"><a href="#router-push" class="headerlink" title="router.push"></a>router.push</h2><p>在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。</p>
<p>想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>
<p>当你点击 <router-link> 时，这个方法会在内部调用，所以说，点击 <router-link :to="..."> 等同于调用 router.push(…)。</p>
<p>官方的文档是这样描述的，挺详细的，简单点的意思就是，系统会自动调用 router.push，我们也可以手动的使用它。</p>
<p>举个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">'home'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里有个值得注意的地方，如果提供了 path，params 会被忽略，需要提供路由的 name 或手写完整的带有参数的 path：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> userId = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br></pre></td></tr></table></figure>

<h2 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace"></a>router.replace</h2><p>router.replace 跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p>
<p>组件中在router-link后面添加replace就好了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"..."</span> replace&gt;</span><br></pre></td></tr></table></figure>

<h2 id="router-go-n"><a href="#router-go-n" class="headerlink" title="router.go(n)"></a>router.go(n)</h2><p>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。</p>
<p>举个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class="line">router.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一步记录，等同于 history.back()</span></span><br><span class="line">router.go(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进 3 步记录</span></span><br><span class="line">router.go(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class="line">router.go(<span class="number">-100</span>)</span><br><span class="line">router.go(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>以上就是我对vue编程式导航的一些理解，有哪里不对的欢迎提出</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的重定向与别名</title>
    <url>/2017/09/13/40-Vue%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>有些时候我们需要对不同场景改变不同的路由跳转，这个时候就需要用到路由的重定向功能</p>
</blockquote>
<a id="more"></a>

<p>这些内容是我从官方文档中摘抄的，感觉写的很详细，就不再做总结了</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向也是通过 routes 配置来完成，下面例子是从 /a 重定向到 /b：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">redirect</span>: <span class="string">'/b'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>重定向的目标也可以是一个命名的路由：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">'foo'</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>甚至是一个方法，动态返回重定向目标：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 方法接收 目标路由 作为参数</span></span><br><span class="line">      <span class="comment">// return 重定向的 字符串路径/路径对象</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>『重定向』的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b，那么『别名』又是什么呢？</p>
<blockquote>
<p>/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">component</span>: A, <span class="attr">alias</span>: <span class="string">'/b'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>『别名』的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的导航守卫</title>
    <url>/2017/09/25/41-Vue%E7%9A%84%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>什么是导航守卫，简单的来说，就是路由进行跳转或改变的时候，会触发，这就是导航守卫</p>
</blockquote>
<a id="more"></a>

<p>以下内容转载至官方文档，官网给的文档还是很详细的，有兴趣的可以去看一下</p>
<p>参数或查询的改变并不会触发进入/离开的导航守卫。你可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。</p>
<h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>你可以使用 router.beforeEach 注册一个全局前置守卫：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中。</p>
<p>每个守卫方法接收三个参数：</p>
<ul>
<li><p>to: Route: 即将要进入的目标 路由对象</p>
</li>
<li><p>from: Route: 当前导航正要离开的路由</p>
</li>
<li><p>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</p>
<ul>
<li><p>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。</p>
</li>
<li><p>next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。</p>
</li>
<li><p>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</p>
</li>
<li><p>next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>确保要调用 next 方法，否则钩子就不会被 resolved。</p>
</blockquote>
<h3 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h3><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h3><p>你可以在路由配置上直接定义 beforeEnter 守卫：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h3><p>可以在路由组件内直接定义以下路由导航守卫：</p>
<ol>
<li>beforeRouteEnter</li>
<li>beforeRouteUpdate (2.2 新增)</li>
<li>beforeRouteLeave</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。不过，可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以 在 beforeRouteLeave 中直接访问 this。这个离开守卫通常用来禁止用户在还未保存修改前突然离开。可以通过 next(false) 来取消导航。</p>
<h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli的入门</title>
    <url>/2017/10/02/42-vue-cli%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>在实际的项目开发中，大多都是使用vue的脚手架来搭好主体的框架，一起讨论一下吧</p>
</blockquote>
<a id="more"></a>

<p>有些小伙伴可能不了解什么是脚手架，vue的脚手架相当于帮你将项目的结构定义好，webpack的打包工具也帮你配置好，方便你写项目</p>
<p>在安装脚手架之前，要先安装好npm，可以在命令行输入npm -v 来检测时候安装了npm和npm的版本，这里我就不细讲了。</p>
<h2 id="安装cli"><a href="#安装cli" class="headerlink" title="安装cli"></a>安装cli</h2><p>首先，在命令行输入 npm install vue-cli -g </p>
<blockquote>
<p>g :代表全局安装。如果你安装时报错，一般是网络问题，你可以尝试用cnpm来进行安装。安装完成后，可以用vue -V来进行查看 vue-cli的版本号。</p>
</blockquote>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>输入 vue init webpack demo</p>
<blockquote>
<p>webpack 表示模板名称，vue-cli官方提供了5种模板：</p>
</blockquote>
<ol>
<li><p>webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。</p>
</li>
<li><p>webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。</p>
</li>
<li><p>browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。</p>
</li>
<li><p>browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。</p>
</li>
<li><p>simple-一个最简单的单页应用模板。</p>
</li>
</ol>
<blockquote>
<p>demo是你给自己的项目取的名字</p>
</blockquote>
<p>输入命令后，会询问我们几个简单的选项，我们根据自己的需要进行填写就可以了。</p>
<ul>
<li>Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写</li>
<li>Project description:项目描述，默认为A Vue.js project。</li>
<li>Author：作者，如果你有配置git的作者，他会读取。</li>
<li>Install  vue-router? 是否安装vue的路由插件。</li>
<li>Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。最好是进行配置。</li>
<li>setup unit tests with  Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha。</li>
<li>Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试。</li>
</ul>
<p>都输入完成之后，cd到我们的项目中，npm install进行安装，安装完成后会提示你的域名和端口，在浏览器输入就好啦，vue-cli 2.9.1 之前的版本会自动打开浏览器</p>
<p>好了，以上就是我对vue-cli入门的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue路由权限控制</title>
    <url>/2019/01/21/43-vue%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>在实际的开发过程中，我们通常会涉及到权限的问题，不同的用户进来只能看到他对应的菜单权限，页面上的菜单渲染是比较好实现的，这里就不多提，唯一比较难的就是路由的权限控制。</p>
</blockquote>
<a id="more"></a>

<p>本文由超级无敌帅气<code>小凯龙</code>友情赞助</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><blockquote>
<p>目前大概有两种思路可以实现路由的权限控制：</p>
</blockquote>
<p>1.通过router.beforeEach() 路由拦截的方式实现。</p>
<p>2.通过vue-router 官方提供的addRoutes()来进行动态路由注入，<code>注意</code> 该方法只有vue-router的版本 <code>&gt;= 2.2</code>才有效。</p>
<blockquote>
<p>我们可以来看这两种方式是如何实现的：</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="路由拦截的方式"><a href="#路由拦截的方式" class="headerlink" title="路由拦截的方式"></a>路由拦截的方式</h3><p>这种方式依赖于我们项目的路由表都是事先配置好的，假设我们的路由表有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [&#123;</span><br><span class="line">		path: <span class="string">'/'</span>,</span><br><span class="line">		redirect: <span class="string">'/index1'</span></span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		path: <span class="string">'/index1'</span>,</span><br><span class="line">		name: <span class="string">'Index1'</span>,</span><br><span class="line">		component: Index1</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		path: <span class="string">'/index2'</span>,</span><br><span class="line">		name: <span class="string">'Index2'</span>,</span><br><span class="line">		component: Index2</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		path: <span class="string">'/index3'</span>,</span><br><span class="line">		name: <span class="string">'Index3'</span>,</span><br><span class="line">		component: Index3</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>
<p>在 <code>router/index</code> 中，通过router.beforeEach() 路由拦截去进行权限判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//to: 从哪个路由来</span></span><br><span class="line">	<span class="comment">//from: 去哪个路由</span></span><br><span class="line">	<span class="comment">//next：是一个方法，使用路由拦截，必须在后面添加next()，否则路由无法跳转</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//假设我们从后台获取的权限为：</span></span><br><span class="line">	<span class="keyword">const</span> list = [<span class="string">'index1'</span>, <span class="string">'index2'</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果没有匹配到，证明没有权限</span></span><br><span class="line">	<span class="keyword">if</span>(list.indexOf(to.name) === <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="comment">//next('/login');</span></span><br><span class="line"></span><br><span class="line">		... <span class="comment">//或者执行其他操作</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//路由拦截可根据项目返回的权限自行调整，这里只是做了一个简单的例子</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="动态注入路由"><a href="#动态注入路由" class="headerlink" title="动态注入路由"></a>动态注入路由</h3><p>这种方式我们只需要配置静态的路由表，比如登录、注册页，其他路由通过动态注入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [&#123;</span><br><span class="line">		path: <span class="string">'/'</span>,</span><br><span class="line">		redirect: <span class="string">'/login'</span></span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		path: <span class="string">'/login'</span>,</span><br><span class="line">		name: <span class="string">'login'</span>,</span><br><span class="line">		component: Login</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>
<p>假设我们在 登录 的时候，后端返回的权限列表如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leaf: 是我们用来判断是否唯一的</span></span><br><span class="line"><span class="comment">//component：一般来说后端返回给我们的就是一个路径而已，所以我们需要自行的去加载组件</span></span><br><span class="line">export const routers = [&#123;</span><br><span class="line">	path: '/main',</span><br><span class="line">	name: 'main',</span><br><span class="line">	leaf: false,</span><br><span class="line">	component: 'pages/main/main',</span><br><span class="line">	children: [&#123;</span><br><span class="line">		path: '/main/home',</span><br><span class="line">		name: 'home',</span><br><span class="line">		component: 'pages/home/home',</span><br><span class="line">		leaf: true</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		path: '/main/index1',</span><br><span class="line">		name: 'index1',</span><br><span class="line">		component: 'pages/index1',</span><br><span class="line">		leaf: true</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		path: '/main/index2',</span><br><span class="line">		name: 'index2',</span><br><span class="line">		component: 'pages/index2',</span><br><span class="line">		leaf: true</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		path: '/main/index3',</span><br><span class="line">		name: 'index3',</span><br><span class="line">		component: 'pages/index3',</span><br><span class="line">		leaf: true</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		path: '/main/index4',</span><br><span class="line">		name: 'index4',</span><br><span class="line">		component: 'pages/index4',</span><br><span class="line">		leaf: true</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">	path: '*',</span><br><span class="line">	component: 'pages/noFind',</span><br><span class="line">	leaf: true</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>可以写个方法去再次过滤返回回来的路由列表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>routers 初始数据，为数组格式，一般来说是个空数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>data 后端返回的路由列表数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generaMenu</span>(<span class="params">routers, data</span>) </span>&#123;</span><br><span class="line">  data.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> menu = <span class="built_in">Object</span>.assign(&#123;&#125;,item);</span><br><span class="line">    menu.component = <span class="keyword">import</span>(<span class="string">`@/<span class="subst">$&#123;menu.component&#125;</span>.vue`</span>);</span><br><span class="line">    <span class="keyword">if</span>(!item.leaf) &#123;</span><br><span class="line">      menu.children = [];</span><br><span class="line">      generaMenu(menu.children,item.children);</span><br><span class="line">	    menu.redirect = menu.children[<span class="number">0</span>].path; <span class="comment">//如果需要重定向的话，可以根据自己的需求进行选择</span></span><br><span class="line">    &#125;</span><br><span class="line">    routers.push(menu);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们最终就得到了符合路由规则的路由表了。然后通过 <code>addRoutes()</code> 这个方法把路由给注入到路由表里面，之后就可以访问已注入的路由了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$route.addRoutes(data);</span><br></pre></td></tr></table></figure>
<p><code>注意</code> 如果有用到404的路由话，需要把404这个路由放到整个路由表的最后一个，否则，因为一开始我们是没有对应的动态路由，默认就跳转到了404页面了，所以静态路由表不配置404路由，与动态路由一起注入到路由表中。</p>
<p><code>注意</code> 因为使用了addRoutes()这个方法之后，路由表已经可以认为是不可控的了，也就是说，已经注入的路由，没办法在通过官方给的api删除掉(当然，目前官方也没有提供相应的api)。那当我们A帐号退出之后，B帐号登录进来，也会执行 <code>addRoutes()</code> 这个方法，会一直累加上去，然后控制台上也会有警告，出现了重复的路由，然后我们访问A帐号有，B帐号没有的路由时，发现是可以进行访问的。这显然不符合我们的需求。</p>
<p>那么，我们该如何解决这个问题呢？</p>
<p>一种是在用户退出的时候，进行项目的重载：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location.href = <span class="string">'/'</span>; <span class="comment">//这种相对来说体验就非常差了，相当于重新刷新了页面，显然也是不符合我们的需求</span></span><br></pre></td></tr></table></figure>

<p>还有一种就是重新初始化静态路由表：<br>首先，我们要对 <code>router/index</code> 进行改造一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const createRouter &#x3D; () &#x3D;&gt; new Router(&#123;</span><br><span class="line">  routes: [&#123;</span><br><span class="line">  	path: &#39;&#x2F;&#39;,</span><br><span class="line">  	redirect: &#39;&#x2F;login&#39;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  	path: &#39;&#x2F;login&#39;,</span><br><span class="line">  	name: &#39;login&#39;,</span><br><span class="line">  	component: Login</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const router &#x3D; createRouter()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重新实例化一个新的路由表，替换之前的路由表，然后将这个方法导出</span><br><span class="line">export function resetRouter() &#123;</span><br><span class="line">  const newRouter &#x3D; createRouter();</span><br><span class="line">  router.matcher &#x3D; newRouter.matcher; &#x2F;&#x2F; the relevant part</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们在用户退出的时候，重新执行下 <code>resetRouter()</code> 这个方法就可以解决路由表重复累加的问题，同时也发现B账号进来之后，只能访问对应的路由权限而已。A账号的权限路由已经不存在了。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex的使用</title>
    <url>/2017/11/09/44-Vuex%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p>
</blockquote>
<a id="more"></a>

<h2 id="Vuex-是什么"><a href="#Vuex-是什么" class="headerlink" title="Vuex 是什么?"></a>Vuex 是什么?</h2><p>vuex是vue的一个插件,是一个专为 Vue.js 应用程序开发的状态管理模式。(状态:数据,改变数据和获取数据)</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>也是依赖于  npm install vue-cli -g 要先进行全局安装

npm install vuex --save</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建一个文件当做一个store仓库"><a href="#创建一个文件当做一个store仓库" class="headerlink" title="创建一个文件当做一个store仓库"></a>创建一个文件当做一个store仓库</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span> </span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span> <span class="comment">//导入使用 vuex </span></span><br><span class="line">Vue.use(Vuex) </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> state = &#123;</span><br><span class="line">	<span class="comment">// state 所有的状态(数据)</span></span><br><span class="line">&#125; 	</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutations = &#123;	</span><br><span class="line">	<span class="comment">// 改变 state 状态,提交 mutations</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getters = &#123;</span><br><span class="line">	<span class="comment">// getters 计算属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> actions = &#123;</span><br><span class="line">	<span class="comment">// 异步改变数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将这些对象引入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">	state,</span><br><span class="line">	mutations,</span><br><span class="line">	getters,</span><br><span class="line">	actions</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="在main-js中导入store这个仓库"><a href="#在main-js中导入store这个仓库" class="headerlink" title="在main.js中导入store这个仓库"></a>在main.js中导入store这个仓库</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index.js'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	store,<span class="comment">//指定储存对象</span></span><br><span class="line">	router,</span><br><span class="line">	render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="vuex的五大特性"><a href="#vuex的五大特性" class="headerlink" title="vuex的五大特性"></a>vuex的五大特性</h2><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态,数据等都写在 state中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> state = &#123;</span><br><span class="line">	count:<span class="number">0</span>,</span><br><span class="line">	userName:<span class="string">'cs'</span>,</span><br><span class="line">	ownner:<span class="string">'this is chensheng'</span></span><br><span class="line">&#125; 	<span class="comment">// state 所有的状态(数据)</span></span><br></pre></td></tr></table></figure>

<h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p>改变state的状态(数据),通过提交mutations,也就是调用里面的方法( 在 页面中methods使用 this.$store.commit() )</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutations = &#123;</span><br><span class="line">	<span class="comment">//参数一:state对象</span></span><br><span class="line">	<span class="comment">//参数二:自定义的参数 </span></span><br><span class="line">	</span><br><span class="line">    add(state,payload) &#123;</span><br><span class="line">    	state.count += payload || <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    jian(state,payload) &#123;</span><br><span class="line">    	state.count -= payload || <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Payload,你可以向 store.commit 传入额外的参数，在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读.</p>
</blockquote>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>Vuex 允许我们在 store 中定义”getter”（可以认为是 store 的计算属性）,类似于 计算属性,对 state里面的数据进行处理,当依赖值发生改变的时候会自动计算,需要将 state对象 传进去.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getters = &#123;</span><br><span class="line">	upperOwnner(state)&#123;</span><br><span class="line">		<span class="keyword">return</span> state.ownner.slice(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + state.ownner.slice(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>Action 提交的是 mutation，而不是直接变更状态,可以包含任意异步操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> actions = &#123;</span><br><span class="line">	<span class="comment">// context :上下文,指 store对象</span></span><br><span class="line">	<span class="comment">// param : 自定义参数</span></span><br><span class="line">	addAsync(context,param)&#123;</span><br><span class="line">		<span class="comment">// 修改 state</span></span><br><span class="line">		<span class="comment">// actions 不能直接修改 stayed 状态,必须提交到 mutations 修改</span></span><br><span class="line">		context.commit(<span class="string">'add'</span>,param);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>store.state.a // -&gt; moduleA 的状态<br>store.state.b // -&gt; moduleB 的状态</p>
<h2 id="如何在vue界面使用-写好的store-的-javascript页面"><a href="#如何在vue界面使用-写好的store-的-javascript页面" class="headerlink" title="如何在vue界面使用 写好的store 的 javascript页面"></a>如何在vue界面使用 写好的store 的 javascript页面</h2><h3 id="State-1"><a href="#State-1" class="headerlink" title="State"></a>State</h3><p>导入 mapState 辅助 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br></pre></td></tr></table></figure>

<p>使用mapState(当名称与 state 的子节点名称相同时,我们也可以给 mapState 传一个字符串数组。)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	computed:&#123;</span><br><span class="line">		...mapState([<span class="string">'count'</span>,<span class="string">'userName'</span>,<span class="string">'ownner'</span>])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mutations-1"><a href="#Mutations-1" class="headerlink" title="Mutations"></a>Mutations</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">	add()&#123;</span><br><span class="line">		<span class="comment">//建议这样写 使用状态,可以预测 提交mutations 方法去修改状态</span></span><br><span class="line">		<span class="keyword">this</span>.$store.commit(<span class="string">'add'</span>,<span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getters-1"><a href="#getters-1" class="headerlink" title="getters"></a>getters</h3><p>之前说了mapState 可以传递数组,当需要计算属性时,也可以使用对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line"></span><br><span class="line">	anthor:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//这里的this指向的是组件</span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.$store);<span class="comment">//this.$store 存储对象</span></span><br><span class="line">			</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.$store.getters);<span class="comment">//this.$store.getters --getters 对象里的所有数据		</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.upperOwnner</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以导入 mapGetters 辅助 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">computed:&#123;</span><br><span class="line">	...mapGetters([</span><br><span class="line">		<span class="string">'upperOwnner'</span></span><br><span class="line">	]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p>dispatch 其实使用的方法与 Mutations其实是一样的,在var actions 的时候,实际上操作的是commit<br>只是它是异步修改的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">	add()&#123;</span><br><span class="line">		<span class="comment">//调用 action方法 addAsync</span></span><br><span class="line">		<span class="keyword">this</span>.$store.dispatch(<span class="string">'addAsync'</span>,<span class="number">3</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以导入mapActions 辅助方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'addAsync'</span></span><br><span class="line">    ]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>组合 Action, Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以向上面这样组合</p>
<p>更多详细的Vuex的知识可以上官网阅读，以上就是我对Vuex的一些基础理解，有不对的地方欢迎提出</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 2.0 总结</title>
    <url>/2019/09/13/45-vue-cli%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>写了很久了,一直没有发出来,本来想像Vue那样分知识点一个一个讲的,但是Vue-cli其实也就是一个脚手架,所以索性合在一起讲</p>
</blockquote>
<a id="more"></a>

<h1 id="写一下一直以来对Vue的理解"><a href="#写一下一直以来对Vue的理解" class="headerlink" title="写一下一直以来对Vue的理解"></a>写一下一直以来对Vue的理解</h1><h1 id="什么是Vue-为什么选择Vue"><a href="#什么是Vue-为什么选择Vue" class="headerlink" title="什么是Vue?为什么选择Vue?"></a>什么是Vue?为什么选择Vue?</h1><p>简单的来说,Vue就是一个<code>渐进式框架</code> + <code>MVVM模式</code></p>
<p>那么问题来了,什么是 渐进式框架?</p>
<h2 id="渐进式框架"><a href="#渐进式框架" class="headerlink" title="渐进式框架"></a>渐进式框架</h2><p>总结一句话来说,可以只使用一部分功能,不必使用全部功能,可以跟其他的框架结合使用,这就叫渐进式框架.</p>
<p>每个框架都有一定的主张,(会有自己的一些特点),从而会对使用者有一定的要求,相比较于Angular的模块机制和依赖注入,react的函数式编程等,Vue的主张是最少</p>
<p>它可以在原项目的基础上,拆分出一两个组件用vue来封装,其他的继续用jquer或者javascript,也可以使用Vue-cli来搭建全家桶</p>
<p>再来看看什么是 MVVM设计模式</p>
<h2 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h2><p>其实Vue设计上没有完全遵循MVVM模式,但是Vue的设计无疑是受到了它的启发</p>
<p>MVVM分来三个模型</p>
<ul>
<li>M: model 数据模型</li>
<li>V: view 视图模型</li>
<li>VM: 视图数据模型</li>
</ul>
<p>相比较于传统H5的MVC模式,MVVM模式将应用程序分为了三大部分,实现了职责分离,通过<code>数据双向绑定</code>让数据驱动视图.<br>在学习Vue的过程中要转化思想,不要想着怎么操作DOM元素,而是操作数据</p>
<p>以后再介绍Vue-cli 3.0的版本,我们先在Vue-cli 2.0的基础上,看看Vue给我们带来了哪些功能, 想要了解在html中使用Vue.js的用法,可以搜索我的博客 <code>陈先生的小前端</code></p>
<p>在学习Vue的过程中,我们没必要一上来就搞懂Vue的每一个部件和功能,先从核心功能开始学习,逐渐扩展。 </p>
<p>同时,在使用中,我们也没有必要把全部件能都拿出来,需要什么就用什么就是了。</p>
<h1 id="搭建Vue-cli"><a href="#搭建Vue-cli" class="headerlink" title="搭建Vue-cli"></a>搭建Vue-cli</h1><p>项目是运行在node环境上的,所以我们需要去Node官网下载安装</p>
<p>由于Vue-cli是基于webpack的,所以我们要再安装一下webpack <code>npm install webpack -g</code> 。</p>
<p>全局安装 <code>npm install vue-cli -g</code></p>
<p>初始化项目 <code>vue init webpack project</code></p>
<p>过程我就不细说了,直接看看项目结构</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/45-projectImg.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="项目结构图"></p>
<h1 id="Vue基础语法"><a href="#Vue基础语法" class="headerlink" title="Vue基础语法"></a>Vue基础语法</h1><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><ul>
<li>数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值</li>
<li>v-once 能执行一次性地插值,当数据改变时,插值处的内容不会更新。</li>
<li>v-text 和双大括号一样,绑定一个值</li>
<li>v-html 简单的来说能编译标签,站点上动态渲染的任意 HTML 可能会非常危险,因为它很容易导致XSS攻击。</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul>
<li>解释：指令(Directives)是带有 v- 前缀的特殊属性。指令属性的值预期是单个 JavaScript 表达式 (v-for 是例外情况)</li>
<li>作用：当表达式的值改变时,将其产生的连带影响,响应式地作用于 DOM</li>
</ul>
<p>刚刚说到的 v-html 那些也是指令,就不再重复解释了,看看我们还经常用到那些指令</p>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul>
<li>作用：绑定属性,当表达式的值改变时,将其产生的连带影响,响应式地作用于 DOM</li>
<li>语法：v-bind:title=”msg”</li>
<li>简写：:title=”msg”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul>
<li>作用：绑定事件</li>
<li>语法：v-on:click=”say” or v-on:click=”say(‘参数’, $event)”</li>
<li>简写：@click=”say”</li>
<li>说明：绑定的事件定义在methods</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>绑定事件后面还可以跟一些修饰符,修饰符在一些应用场景可以起关键作用,类似阻止冒泡之类的,看看都有哪些事件修饰符(还有其他类型的修饰符)</p>
<ul>
<li>.native 原生点击事件</li>
<li>.stop 阻止冒泡,调用 event.stopPropagation()</li>
<li>.prevent 阻止默认行为,调用 event.preventDefault()</li>
<li>.capture 添加事件侦听器时使用事件捕获模式</li>
<li>.self 只当事件在该元素本身（比如不是子元素）触发时,才会触发事件</li>
<li>.once 事件只触发一次</li>
</ul>
<blockquote>
<p>主要要注意的是,修饰符可以串联使用,不过要注意前后关系(用 @click.prevent.self 会阻止所有的点击,而 @click.self.prevent 只会阻止元素上的点击。)</p>
</blockquote>
<p>为什么在 HTML 中监听事件?</p>
<ul>
<li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li>
<li>因为你无须在 JavaScript 里手动绑定事件,你的 ViewModel 代码可以是非常纯粹的逻辑,和 DOM 完全解耦,更易于测试。</li>
<li>当一个 ViewModel 被销毁时,所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li>
</ul>
<p>修饰符一共有哪些种类呢?</p>
<ul>
<li>事件修饰符: 就是上面讲的那些</li>
<li>按键修饰符: 针对键盘keyup的修饰符</li>
<li>系统修饰符: 按下相应按键时才触发鼠标或键盘事件的监听器。</li>
<li>表单修饰符: 多用于表单<ul>
<li>.lazy : v-model 在每次 input 事件触发后将输入框的值与数据进行同步。你可以添加 lazy 修饰符,从而转变为使用 change</li>
<li>.number : 如果想自动将用户的输入值转为数值类型,可以给 v-model 添加 number 修饰符</li>
<li>.trim : 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符</li>
</ul>
</li>
<li>自定义事件修饰符: .sync, 后面会讲到怎么用</li>
</ul>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul>
<li>作用：在表单元素上创建双向数据绑定</li>
<li>说明：监听用户的输入事件以更新数据,多用于表单中</li>
</ul>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ul>
<li>作用：基于源数据多次渲染元素或模板块</li>
</ul>
<h3 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if , v-show"></a>v-if , v-show</h3><p>这两个都是用于条件渲染</p>
<ul>
<li>v-if：根据表达式的值的真假条件,销毁或重建元素</li>
<li>v-show：根据表达式之真假值,切换元素的 display CSS 属性</li>
</ul>
<blockquote>
<p>所以如果需要频繁的切换显示状态,使用v-show对性能更友好</p>
</blockquote>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul>
<li>说明：vue会跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</li>
</ul>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>如果觉得vue自带的指令不够用,我们可以进行自定义指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 输入框自动获取焦点</span><br><span class="line">&lt;input v-focus&gt;</span><br><span class="line">---------------</span><br><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    &#x2F;&#x2F; 指令的定义</span><br><span class="line">    inserted(el) &#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="script内的方法"><a href="#script内的方法" class="headerlink" title="script内的方法"></a>script内的方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">	data() &#123;</span><br><span class="line">		return &#123;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;&#125;,</span><br><span class="line">	created() &#123;&#125;,</span><br><span class="line">	mounted() &#123;&#125;,</span><br><span class="line">	computed: &#123;&#125;,</span><br><span class="line">	watch: &#123;&#125;,</span><br><span class="line">	filters:&#123;&#125;,</span><br><span class="line">	components: &#123;&#125;,</span><br><span class="line">	directives: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data大家都知道里面存放的是数据,可是为什么需要一个return返回?</p>
<p>因为不使用return包裹的数据会在项目的全局可见,会造成变量污染<br>使用return包裹后数据中变量只在当前组件中生效,不会影响其他组件。</p>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>用来存放方法,我们所有的方法都尽量写在里面,便于管理</p>
<h3 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed(计算属性)"></a>computed(计算属性)</h3><ul>
<li>说明：计算属性是基于它们的依赖进行缓存的,只有在它的依赖发生改变时才会重新求值</li>
<li>注意：computed中的属性不能与data中的属性同名,否则会报错</li>
</ul>
<p>为什么会用到计算属性呢? 因为在模板中放入太多的逻辑会让模板过重且难以维护,举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	&#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>想要反转字符串,但是这样写显然让人觉得看的很累,所以采用计算属性来写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	&lt;p&gt;&#123;&#123; reversedMessage &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">	reversedMessage() &#123;</span><br><span class="line">		return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实写在methods也可以实现这个功能,采用计算属性就是为了响应式依赖进行计算,对性能更友好</p>
</blockquote>
<h3 id="watch-监听"><a href="#watch-监听" class="headerlink" title="watch(监听)"></a>watch(监听)</h3><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch:&#123; &#x2F;&#x2F;watch 观察,可以指定观察的属性(数据),属性一旦发生改变,就会调用观察所对应属性的 函数</span><br><span class="line">	number(newValue,oldValue)&#123;&#x2F;&#x2F;传入两个值,一个新的,一个旧的</span><br><span class="line">		&#x2F;&#x2F; 在这里可以处理当number的值改变时的回调函数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>讲一下vue中的过滤器,说到过滤器,先说一下vue中<code>双大括号</code>, 它也是单个 JavaScript 表达式,所以可以使用过滤器</p>
<ul>
<li>作用：文本数据格式化</li>
<li>过滤器可以用在两个地方：<code>双大括号</code>和 v-bind 表达式</li>
<li>两种过滤器：1 全局过滤器 2 局部过滤器</li>
</ul>
<blockquote>
<p>过滤器可以串联,可以接收多个参数 </p>
</blockquote>
<p>给个简单的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">	&lt;!--第一个是参数 | 第二个是方法的名字--&gt;		</span><br><span class="line">	</span><br><span class="line">	&lt;p&gt;2的三次方等于&#123;&#123; 2 | pow(3) &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;p&gt;2加3 加5等于&#123;&#123; 2 | add(3,5) &#125;&#125;&lt;&#x2F;p&gt;&#x2F;&#x2F;多个参数的时候可以直接在第二个后面跟</span><br><span class="line">	</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意!过滤器函数,必须要有一个参数</span><br><span class="line">filters:&#123;</span><br><span class="line">	pow(num1,num2)&#123;</span><br><span class="line">		return Math.pow(num1,num2)</span><br><span class="line">	&#125;,</span><br><span class="line">	add(n1,n2,n3)&#123;</span><br><span class="line">		return n1 + n2 + n3</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="components-组件"><a href="#components-组件" class="headerlink" title="components(组件)"></a>components(组件)</h3><p>当引入组件的时候需要在这边声明,具体后面再说</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程。<br>例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。<br>同时在这个过程中也会运行一些叫做生命周期钩子的函数,给予用户机会在一些特定的场景下添加他们自己的代码。</p>
<ol>
<li>创建之前: beforeCreate</li>
</ol>
<ul>
<li>说明：在实例初始化之后,数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li>
<li>注意：此时,无法获取 data中的数据、methods中的方法</li>
</ul>
<ol start="2">
<li>创建之后: created –&gt;一般在这个时候进行请求数据</li>
</ol>
<ul>
<li>注意：这是一个常用的生命周期,可以调用methods中的方法、改变data中的数据</li>
<li>使用场景：发送请求获取数据</li>
</ul>
<ol start="3">
<li>组件挂载之前: beforeMount –&gt;在组件挂载完成之前,组件还没有创建完成,模板还没有生成</li>
</ol>
<ul>
<li>说明：在挂载开始之前被调用</li>
</ul>
<ol start="4">
<li>组件挂载之后(所有组件挂载完成): mounted –&gt;生成模板,获取模板内容</li>
</ol>
<ul>
<li>说明：此时,vue实例已经挂载到页面中,可以获取到el中的DOM元素,进行DOM操作</li>
</ul>
<ol start="5">
<li>组件更新之前: beforeUpdate</li>
</ol>
<ul>
<li>说明：数据更新时调用,发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态,这不会触发附加的重渲染过程。</li>
<li>注意：此处获取的数据是更新后的数据,但是获取页面中的DOM元素是更新之前的</li>
</ul>
<ol start="6">
<li>组件更新之后: updated</li>
</ol>
<ul>
<li>说明：组件 DOM 已经更新,所以你现在可以执行依赖于 DOM 的操作。</li>
</ul>
<ol start="7">
<li>组件销毁之前: beforeDestroy –&gt; this.$refs.com1.$destroy();</li>
</ol>
<ul>
<li>说明：实例销毁之前调用。在这一步,实例仍然完全可用。</li>
<li>使用场景：实例销毁之前,执行清理任务,比如：清除定时器等</li>
</ul>
<ol start="8">
<li>组件销毁之后: destroyed</li>
</ol>
<ul>
<li>说明：Vue 实例销毁后调用。调用后,Vue 实例指示的所有东西都会解绑定,所有的事件监听器会被移除,所有的子实例也会被销毁。</li>
</ul>
<h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2><p>组件一般分为两种,父子间组件和非父子间组件..只要弄清楚传值,监听和发送,就差不多掌握了</p>
<h3 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h3><p>首先创建一个.vue的页面,作为一个组件</p>
<p>在需要它的页面导入 <code>import 组件名 from &#39;@/components/页面名称.vue&#39;</code></p>
<p>之后在    <code>components: { 组件名 }</code> 中声明一下就可以调用了</p>
<h3 id="prop传值"><a href="#prop传值" class="headerlink" title="prop传值"></a>prop传值</h3><p>我们先看看父组件怎么传值给子组件</p>
<blockquote>
<p>在 Vue 中,父子组件的关系可以总结为 prop 向下传递,事件向上传递。父组件通过 prop 给子组件下发数据,子组件通过事件给父组件发送消息。</p>
</blockquote>
<p>为什么要用prop?因为组件实例的作用域是独立的,子组件的模板不能直接使用父类的,所以Vue中使用prop进行父级向子级传值</p>
<ul>
<li>方式：通过子组件props属性来传递数据 props是一个数组</li>
<li>注意：属性的值必须在组件中通过props属性显示指定,否则,不会生效</li>
<li>说明：传递过来的props属性的用法与data属性的用法相同</li>
</ul>
<p>假设这个是我们要创建的组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&#123;&#123; myName &#125;&#125;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		&#x2F;&#x2F; 接收父级传来的数据</span><br><span class="line">		props: &#123;</span><br><span class="line">			myName: &#123;</span><br><span class="line">				type: String,</span><br><span class="line">				default: &#39;csing&#39;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#x2F;&#x2F; 对象或数组默认值必须从一个函数获取</span><br><span class="line">			numList: &#123;</span><br><span class="line">				type: Array,</span><br><span class="line">				default: function () &#123;</span><br><span class="line">					return [&#39;csing&#39;]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				&#x2F;&#x2F; 用一个字段接收</span><br><span class="line">				msg: this.myName,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是,在子组件中不可以修改prop传递过来的值</p>
</blockquote>
<p>每次父组件更新时,子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了,Vue 会在控制台给出警告。</p>
<p>在两种情况下,我们很容易忍不住想去修改 prop 中数据：</p>
<ol>
<li>Prop 作为初始值传入后,子组件想把它当作局部数据来用；</li>
<li>Prop 作为原始数据传入,由子组件处理成其它数据输出。</li>
</ol>
<p>所以我们需要一个字段去接收</p>
<blockquote>
<p>还有一个重点我们要讲一下, JavaScript 中对象和数组是引用类型,指向同一个内存空间,如果 prop 是一个对象或数组,在子组件内部改变它会影响父组件的状态。</p>
</blockquote>
<p>那么问题来了,非prop属性会被替换吗</p>
<p>举个很简单的例子,一个组件里面定义了class,在外面引用该组件时,也写了一个class,class会被替换吗</p>
<blockquote>
<p>庆幸的是,class 和 style 特性会稍微智能一些,即两边的值会被合并起来</p>
</blockquote>
<p>所以我们需要使用 <code>inheritAttrs: false</code> 来禁用特性继承,配合<code>$attrs</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p v-bind&#x3D;&quot;$attrs&quot;&gt;继承属性&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>


<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>子组件传值给父组件就需要用到自定义事件,自定义事件大体上分为三个步骤,我把它叫做三步曲</p>
<h4 id="第一步-监听自定义事件"><a href="#第一步-监听自定义事件" class="headerlink" title="第一步:监听自定义事件"></a>第一步:监听自定义事件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 父组件接受子组件的to-parent方法 --&gt;</span><br><span class="line">&lt;viewpage :myName&#x3D;&quot;name&quot; @to-parent&#x3D;&quot;fromChild&quot;&gt;&lt;&#x2F;viewpage&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第二步-触发自定义事件"><a href="#第二步-触发自定义事件" class="headerlink" title="第二步:触发自定义事件"></a>第二步:触发自定义事件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">	add()&#123;</span><br><span class="line">		this.$emit(&#39;to-parent&#39;,this.addName)	&#x2F;&#x2F;这里的ran是传递的参数	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三步-传递过来的值进行计算"><a href="#第三步-传递过来的值进行计算" class="headerlink" title="第三步:传递过来的值进行计算"></a>第三步:传递过来的值进行计算</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">	fromChild(name)&#123;</span><br><span class="line">		this.name &#x3D; this.name + name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在有一个问题,如果子组件只是想当初的修改一下父组件传进来的值,并且赋值给父组件,怎么办</p>
</blockquote>
<p>使用修饰符 <code>sync</code></p>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;details&quot;&gt;</span><br><span class="line">		&lt;myComponent :show.sync&#x3D;&#39;valueChild&#39; style&#x3D;&quot;padding: 30px 20px 30px 5px;border:1px solid #ddd;margin-bottom: 10px;&quot;&gt;&lt;&#x2F;myComponent&gt;</span><br><span class="line">		&lt;button @click&#x3D;&quot;changeValue&quot;&gt;toggle&lt;&#x2F;button&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">Vue.component(&#39;myComponent&#39;, &#123;</span><br><span class="line">		template: &#96;&lt;div v-if&#x3D;&quot;show&quot;&gt;</span><br><span class="line">									&lt;p&gt;默认初始值是&#123;&#123;show&#125;&#125;，所以是显示的&lt;&#x2F;p&gt;</span><br><span class="line">									&lt;button @click.stop&#x3D;&quot;closeDiv&quot;&gt;关闭&lt;&#x2F;button&gt;</span><br><span class="line">							 &lt;&#x2F;div&gt;&#96;,</span><br><span class="line">		props:[&#39;show&#39;],</span><br><span class="line">		methods: &#123;</span><br><span class="line">			closeDiv() &#123;</span><br><span class="line">				this.$emit(&#39;update:show&#39;, false); &#x2F;&#x2F;触发 input 事件，并传入新值</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default&#123;</span><br><span class="line">	data()&#123;</span><br><span class="line">		return&#123;</span><br><span class="line">			valueChild:true,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		changeValue()&#123;</span><br><span class="line">			this.valueChild &#x3D; !this.valueChild</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>动态效果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7579449-1567b35b54771fc6.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/497/format/webp" alt="动态效果"></p>
<p>vue 修饰符sync的功能是：当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。如果我们不用.sync，我们想做上面的那个弹窗功能，我们也可以props传初始值，然后事件监听，实现起来也不算复杂。这里用sync实现，只是给大家提供一个思路，让其明白他的实现原理，可能有其它复杂的功能适用sync。</p>
<p>到这里最常用的父子组件相互传值就已经完成了,接下来说一下非父子间的传值</p>
<h3 id="bus中央线"><a href="#bus中央线" class="headerlink" title="bus中央线"></a>bus中央线</h3><p>其实原理和自定义事件是一样的,也是三部曲</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><blockquote>
<p>创建一个 vue 作为中央线来处理 非父子关系的组件传递数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;Vue&#39;</span><br><span class="line">var bus &#x3D; new Vue();</span><br><span class="line">export default bus;</span><br></pre></td></tr></table></figure>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><blockquote>
<p>在组件二中创建监听事件—-注意:监听事件一定要在发射之前,监听才有效</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用前先导入</span><br><span class="line">import bus from &#39;@&#x2F;util&#x2F;bus.js&#39;;</span><br><span class="line"></span><br><span class="line">created() &#123;</span><br><span class="line">	bus.$on(&#39;giveMsg&#39;,(value)&#x3D;&gt;&#123;</span><br><span class="line">		&#x2F;&#x2F;这里的value是传递过来的值</span><br><span class="line">		this.counter +&#x3D; value</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><blockquote>
<p>在组件一中发射组件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add()&#123;</span><br><span class="line">	&#x2F;&#x2F;通过bus中央线来发射组件</span><br><span class="line">	&#x2F;&#x2F;giveMsg类似于事件的名称</span><br><span class="line">	&#x2F;&#x2F;num是要传递的参数</span><br><span class="line">	bus.$emit(&#39;giveMsg&#39;,this.num) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><blockquote>
<p>为了让组件可以组合,我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为内容分发 。Vue.js 实现了一个内容分发 API,参照了当前 Web Components 规范草案,使用特殊的 元素作为原始内容的插槽。</p>
</blockquote>
<p>在组件中写 slot,想要几个就写几个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&#x2F;&#x2F;每个插槽最好都要有自己的名字,不然所有的标签都会被使用</span><br><span class="line">	&lt;slot name&#x3D;&#39;title&#39;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>使用插槽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;			</span><br><span class="line">	&lt;component&gt;</span><br><span class="line">		&lt;h1 slot&#x3D;&#39;title&#39;&gt;标题是:&#123;&#123; title &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">	&lt;&#x2F;component&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>现在这种用法虽然也可以,但是<code>2.6.0</code> v-slot 指令取代了 slot,并且只能在template上使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template v-slot:title&gt;我是一个标题&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="混入-mixin"><a href="#混入-mixin" class="headerlink" title="混入 (mixin)"></a>混入 (mixin)</h3><blockquote>
<p>有时候不需要插槽的功能,我们需要实现Vue 组件中的可复用功能,比如三个组件中都需要共同的方法,我们就可以用到mixin</p>
</blockquote>
<p>新建一个mixin.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mixin &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      tableHight: 300,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断屏幕告诉,并自适应表格高度</span><br><span class="line">    viewHeight() &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        this.tableHight &#x3D; window.innerHeight - this.$refs.table.offsetTop - (100 * (window.innerHeight &#x2F; 1080));</span><br><span class="line">      &#125;, 100)</span><br><span class="line">      this.$nextTick(function() &#123;</span><br><span class="line">        this.tableHight &#x3D; window.innerHeight - this.$refs.table.offsetTop - (100 * (window.innerHeight &#x2F; 1080));</span><br><span class="line">        &#x2F;&#x2F; 监听窗口大小变化(暂时不监听)</span><br><span class="line">        let self &#x3D; this;</span><br><span class="line">        window.onresize &#x3D; function() &#123;</span><br><span class="line">          self.tableHight &#x3D; window.innerHeight - self.$refs.table.offsetTop - (100 * (window.innerHeight &#x2F; 1080));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.viewHeight()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default mixin</span><br></pre></td></tr></table></figure>

<p>之后在组件中导入使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import mixin from &#39;@&#x2F;util&#x2F;mixin.js&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是 </p>
<blockquote>
<p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先</p>
</blockquote>
<h2 id="router路由"><a href="#router路由" class="headerlink" title="router路由"></a>router路由</h2><p>说到路由,先说一下为什么vue中的路由,在安卓或者ios监听不到页面url的变化,因为它是一个单页应用程序</p>
<h3 id="SPA-单页应用程序"><a href="#SPA-单页应用程序" class="headerlink" title="SPA -单页应用程序"></a>SPA -单页应用程序</h3><blockquote>
<p>单页Web应用（single page application,SPA）,就是只有一个Web页面的应用,是加载单个HTML页面,并在用户与应用程序交互时动态更新该页面的Web应用程序。</p>
</blockquote>
<ol>
<li><p>单页面应用程序: 只有第一次会加载页面, 以后的每次请求, 仅仅是获取必要的数据.然后, 由页面中js解析获取的数据, 展示在页面中<br>传统多页面应用程序：</p>
</li>
<li><p>对于传统的多页面应用程序来说, 每次请求服务器返回的都是一个完整的页面</p>
</li>
</ol>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>减少了请求体积,加快页面响应速度,降低了对服务器的压力</li>
<li>更好的用户体验,让用户在web app感受native app的流畅</li>
</ol>
<h4 id="实现思路和技术点"><a href="#实现思路和技术点" class="headerlink" title="实现思路和技术点"></a>实现思路和技术点</h4><ol>
<li>锚点的使用（window.location.hash #）</li>
<li>hashchange 事件 window.addEventListener(“hashchange”,function () {})</li>
<li>监听锚点值变化的事件,根据不同的锚点值,请求相应的数据</li>
<li>原本用作页面内部进行跳转,定位并展示相应的内容</li>
</ol>
<h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><p>SPA往往是功能复杂的应用,为了有效管理所有视图内容,前端路由 应运而生,当URL中的哈希值（# hash）发生改变后,路由会根据制定好的规则,展示对应的视图内容</p>
<p>在router/index.js 中配置路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">	routes: [</span><br><span class="line">		&#x2F;&#x2F;  将 path 重定向到 redirect</span><br><span class="line">		&#123;</span><br><span class="line">			path: &#39;&#x2F;&#39;,</span><br><span class="line">			redirect: &#39;&#x2F;home&#39;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			path: &#39;&#x2F;home&#39;,</span><br><span class="line">			name: &#39;home-page&#39;,</span><br><span class="line">			component: require(&#39;@&#x2F;view&#x2F;home&#39;).default,</span><br><span class="line">			children:[</span><br><span class="line">				&#123;</span><br><span class="line">					path: &#39;&#x2F;Welcome&#39;,</span><br><span class="line">					name: &#39;Welcome&#39;,</span><br><span class="line">					component: require(&#39;@&#x2F;view&#x2F;Welcome&#39;).default,</span><br><span class="line">				&#125;,</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在页面中使用编程式导航</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">router.push(&#39;home&#39;)</span><br><span class="line">&#x2F;&#x2F; 对象</span><br><span class="line">router.push(&#123; path: &#39;home&#39; &#125;)</span><br><span class="line">&#x2F;&#x2F; 命名的路由</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace"></a>router.replace</h4><p>router.replace 跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p>
<h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><p>具体的不说了,简单介绍一下完整的导航解析流程</p>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
<p><a href="https://www.chensheng.group/2017/09/25/41-Vue的导航守卫/">路由守卫具体链接–&gt;戳我</a></p>
<h2 id="Vuex数据仓库"><a href="#Vuex数据仓库" class="headerlink" title="Vuex数据仓库"></a>Vuex数据仓库</h2><blockquote>
<p>vuex是vue的一个插件,是一个专为 Vue.js 应用程序开发的状态管理模式。(状态:数据,改变数据和获取数据)</p>
</blockquote>
<p><a href="https://www.chensheng.group/2017/11/09/50-Vuex的使用/">数据仓库具体链接–&gt;戳我</a></p>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><blockquote>
<p>由于vue不再继续维护vue-resource，并推荐使用 axios,所有axios进入了大家的视野</p>
</blockquote>
<ul>
<li>以Promise为基础的HTTP客户端，适用于：浏览器和node.js</li>
<li>封装ajax，用来发送请求，异步获取数据</li>
<li>从浏览器中创建 XMLHttpRequest</li>
<li>从 node.js 发出 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
<li>客户端支持防止 CSRF/XSRF</li>
</ul>
<h3 id="安装：npm-i-S-axios"><a href="#安装：npm-i-S-axios" class="headerlink" title="安装：npm i -S axios"></a>安装：npm i -S axios</h3><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在浏览器中使用，直接引入js文件使用下面的GET&#x2F;POST请求方式即可</span><br><span class="line">&#x2F;&#x2F; 1 引入 axios.js</span><br><span class="line">&#x2F;&#x2F; 2 直接调用axios提供的API发送请求</span><br><span class="line">created() &#123;</span><br><span class="line">  axios.get(url).then(function(resp) &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">&#x2F;&#x2F; 配合 webpack 使用方式如下：</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">&#x2F;&#x2F; 将 axios 添加到 Vue.prototype 中</span><br><span class="line">Vue.prototype.$axios &#x3D; axios</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">&#x2F;&#x2F; 在组件中使用：</span><br><span class="line">methods: &#123;</span><br><span class="line">  getData() &#123;</span><br><span class="line">    this.$axios.get(&#39;url&#39;)</span><br><span class="line">      .then(res &#x3D;&gt; &#123;&#125;)</span><br><span class="line">      .catch(err &#x3D;&gt; &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">&#x2F;&#x2F; API使用方式：</span><br><span class="line"></span><br><span class="line">axios.get(url[, config])</span><br><span class="line">axios.post(url[, data[, config]])</span><br><span class="line">axios(url[, config])</span><br><span class="line">axios(config)</span><br></pre></td></tr></table></figure>

<p>看看具体的代码实现</p>
<h3 id="Get-请求"><a href="#Get-请求" class="headerlink" title="Get 请求"></a>Get 请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const url &#x3D; &#39;http:&#x2F;&#x2F;vue.studyit.io&#x2F;api&#x2F;getnewslist&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; url中带有query参数</span><br><span class="line">axios.get(&#39;&#x2F;user?id&#x3D;89&#39;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">	console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">	console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; url和参数分离，使用对象</span><br><span class="line">axios.get(&#39;&#x2F;user&#39;, &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    id: 12345</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Post-请求"><a href="#Post-请求" class="headerlink" title="Post 请求"></a>Post 请求</h3><p>默认情况下，axios 会将JS对象序列化为JSON对象。为了使用 application/x-www-form-urlencoded 格式发送请求，我们可以这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用 qs 包，处理将对象序列化为字符串</span><br><span class="line">&#x2F;&#x2F; npm i -S qs</span><br><span class="line">&#x2F;&#x2F; var qs &#x3D; require(&#39;qs&#39;)</span><br><span class="line">import qs from &#39;qs&#39;</span><br><span class="line">qs.stringify(&#123; &#39;bar&#39;: 123 &#125;) &#x3D;&#x3D;&#x3D;&gt; &quot;bar&#x3D;123&quot;</span><br><span class="line">axios.post(&#39;&#x2F;foo&#39;, qs.stringify(&#123; &#39;bar&#39;: 123 &#125;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者：</span><br><span class="line">axios.post(&#39;&#x2F;foo&#39;, &#39;bar&#x3D;123&amp;age&#x3D;19&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 具体使用</span><br><span class="line">axios.post(&#39;&#x2F;user&#39;, qs.stringify(&#123;</span><br><span class="line">	firstName: &#39;Fred&#39;,</span><br><span class="line">	lastName: &#39;Flintstone&#39;</span><br><span class="line">&#125;))</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">	console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">	console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果就是正常的传递json对象,那就这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axios.post(&#39;&#x2F;user&#39;, &#123;</span><br><span class="line">	firstName: &#39;Fred&#39;,</span><br><span class="line">	lastName: &#39;Flintstone&#39;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">	console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">	console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>项目做好后,最后一步就是打包了</p>
<p>打包其实vue-cli都帮我们配置好了,<code>npm run build</code> 就可以了,需要其他的配置,以后会说到</p>
<p><a href="https://www.chensheng.group/2018/01/29/55-vue-cli打包问题总结/">打包踩过的坑</a></p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>SessionStorage的共享</title>
    <url>/2017/11/23/46-SessionStorage%E7%9A%84%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>在之前，保存用户信息大多数都是放在Cookie中，但是安全性太低了，随着Html5的诞生，Web Storage也进入我们的视野，于是存储信息都转入到SessionStorage，今天就分享一下SessionStorage的共享问题</p>
</blockquote>
<a id="more"></a>

<p>在之前的博客中有提到Cookie和Web Storage的区别与使用，但是使用起来并没有我们想象的那么顺心，Cookie使用起来，不同标签页可以共享，但是安全性不高，SessionStorage安全性是稍微好一些，但是在不同的标签页中又不能共享数据。百度一会，发现国外有一个大神对于这个问题提出了一个解决的方案，我总结了一下</p>
<h3 id="现有的浏览器存储机制"><a href="#现有的浏览器存储机制" class="headerlink" title="现有的浏览器存储机制"></a>现有的浏览器存储机制</h3><ol>
<li>localStorage：~5MB，数据永久保存直到用户手动删除</li>
<li>sessionStorage：~5MB，数据只在当前标签页有效，当用户关闭浏览器时删除</li>
<li>cookie：~4KB，可以设置成永久有效，当用户关闭浏览器时删除</li>
</ol>
<h3 id="安全的认证token保存"><a href="#安全的认证token保存" class="headerlink" title="安全的认证token保存"></a>安全的认证token保存</h3><p>一些重要的系统会要求当用户关闭标签页时会话立刻到期。</p>
<p>为了达到这个目的，绝对不应该使用cookies来保存任何敏感信息（例如认证token）。</p>
<p>这些问题就使得我们在保存认证token时应使用内存或sessionStorage。sessionStorage的好处是它允许跨多个页面保存数据，并且也支持浏览器刷新操作。这样用户就可以在多个页面之间跳转或刷新页面而保持登录状态。</p>
<p>Good。我们将token保存在sessionStorage，并在每次请求服务器时将token放在请求头中来完成用户的身份认证。当用户关闭标签页，token会立即过期。</p>
<h3 id="但多标签页怎么办？"><a href="#但多标签页怎么办？" class="headerlink" title="但多标签页怎么办？"></a>但多标签页怎么办？</h3><p>即便是在单页面应用中也有一个很常见的情况，用户经常希望打开多个标签页。而此场景下将token保存在sessionStorage中将会带来很差的用户体验，每次开启一个标签页都会要求用户重新登录。没错，sessionStorage不支持跨标签页共享数据。</p>
<h3 id="利用localStorage事件来跨标签页共享sessionStorage"><a href="#利用localStorage事件来跨标签页共享sessionStorage" class="headerlink" title="利用localStorage事件来跨标签页共享sessionStorage"></a>利用localStorage事件来跨标签页共享sessionStorage</h3><p>当用户新开一个标签页时，我们先来询问其它已经打开的标签页是不是有需要给我们共享的sessionStorage数据。如果有，现有的标签页会通过localStorage事件来传递数据到新打开的标签页中，我们只需要复制一份到本地sessionStorage即可。</p>
<blockquote>
<p>传递过来的sessionStorage绝对不会保存在localStorage，从localStorage事件将数据中复制并保存到sessionStorage，这个流程是在同一个调用中完成，没有中间状态。而且数据是对应事件携带的，并不在localStorage中。这样就确保了数据的安全性。</p>
</blockquote>
<p>直接上代码：在代码中解释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了简单明了删除了对IE的支持</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!sessionStorage.length) &#123;</span><br><span class="line">		<span class="comment">// 这个调用能触发目标事件，从而达到共享数据的目的</span></span><br><span class="line">		localStorage.setItem(<span class="string">'getSessionStorage'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 该事件是核心,调用监听事件</span></span><br><span class="line">	<span class="built_in">window</span>.addEventListener(<span class="string">'storage'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.key == <span class="string">'getSessionStorage'</span>) &#123;</span><br><span class="line">			<span class="comment">// 已存在的标签页会收到这个事件</span></span><br><span class="line">			localStorage.setItem(<span class="string">'sessionStorage'</span>, <span class="built_in">JSON</span>.stringify(sessionStorage));</span><br><span class="line">			localStorage.removeItem(<span class="string">'sessionStorage'</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.key == <span class="string">'sessionStorage'</span> &amp;&amp; !sessionStorage.length) &#123;</span><br><span class="line">			<span class="comment">// 新开启的标签页会收到这个事件</span></span><br><span class="line">			<span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(event.newValue),</span><br><span class="line">					value;</span><br><span class="line">			<span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">				sessionStorage.setItem(key, data[key]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码其实不难理解，当打开新的页面，新页面的sessionStorage.length会空，于是就会调用localStorage.setItem()，其他标签页会判断event.key是否与刚刚保存的key值一致，若一致，说明改页面不是新的页面，则将页面中的session保存至localStorage，新打开的页面监听到有新的值，就将值通过event.newValue取出后赋给自己的SessionStorage，就实现了SessionStorage的共享。</p>
</blockquote>
<p>有些小伙伴对storage事件实时监听可能不太了解，这里稍微解释一下,后面会专门给出一个demo</p>
<p>在事件处理函数中，触发事件的事件对象（event参数值）具有如下几个属性</p>
<ol>
<li>event.key 属性：属性值为在 session 或 localStorage 中被修改的数据键值。 </li>
<li>event.oldValue 属性：属性值为在 sessionStorage 或 localStorage 中被修改的值。 </li>
<li>event.newValue 属性：属性值为在 sessionStorage 或 localStorage 中被修改后的值 </li>
<li>event.url 属性：属性值为修改 sessionStorage 或 localStorage 中值的页面的URL地址 </li>
<li>event.storageArea 属性 : 属性值为被变动的 sessionStorage 对象或 localStorage 对象</li>
</ol>
<p>给出一个监听的小demo，好好研究一下吧，复制就可以使用</p>
<h3 id="实时监听的页面"><a href="#实时监听的页面" class="headerlink" title="实时监听的页面"></a>实时监听的页面</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;利用storage事件实时监视Web Storage中的数据&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//利用storage事件实时监视wev Storage中的数据</span></span><br><span class="line">            <span class="built_in">window</span>.addEventListener(<span class="string">'storage'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;<span class="comment">//e只是一个传参</span></span><br><span class="line">                <span class="comment">//获取被修改的键值</span></span><br><span class="line">                <span class="keyword">if</span> (e.key == <span class="string">'test'</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取将要被添加内容的元素</span></span><br><span class="line">                    <span class="keyword">var</span> output = <span class="built_in">document</span>.getElementById(<span class="string">'output'</span>);</span><br><span class="line">                    <span class="comment">//将获取到的修改值在元素中输出</span></span><br><span class="line">                    output.innerHTML = <span class="string">'原有值：'</span> + e.oldValue;</span><br><span class="line">                    output.innerHTML += <span class="string">'&lt;br /&gt;新值:'</span> + e.newValue;</span><br><span class="line">                    output.innerHTML += <span class="string">'&lt;br /&gt;变动页面地址：'</span> + utf8_decode(<span class="built_in">unescape</span>(e.url));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//分别打印会发现内容一致</span></span><br><span class="line">                    <span class="built_in">console</span>.log(e.storageArea);</span><br><span class="line">                    <span class="built_in">console</span>.log(localStorage);</span><br><span class="line">                    <span class="comment">//此行代码只在Chrome浏览器中有效</span></span><br><span class="line">                    <span class="built_in">console</span>.log(e.storageArea === localStorage);<span class="comment">//输出true</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="literal">false</span>);</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">utf8_decode</span> (<span class="params">utftext</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> string = <span class="string">''</span>;</span><br><span class="line">                <span class="keyword">var</span> i = c = c1 = c2 = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//获取URL所有字符</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; utftext.length) &#123;</span><br><span class="line">                    <span class="comment">//获取URL并将URL中所有 Unicode 编码获取</span></span><br><span class="line">                    c = utftext.charCodeAt(i);</span><br><span class="line">                    <span class="comment">//对 Unicode 编码进行处理转化成字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">128</span>) &#123;</span><br><span class="line">                        string += <span class="built_in">String</span>.fromCharCode(c);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((c &lt; <span class="number">191</span>) &amp;&amp; (c &lt; <span class="number">224</span>)) &#123;</span><br><span class="line">                        c2 = utftext.charCodeAt(i + <span class="number">1</span>);</span><br><span class="line">                        string += <span class="built_in">String</span>.fromCharCode(((c &amp; <span class="number">31</span>) &lt;&lt; <span class="number">6</span>) | (c2 &amp; <span class="number">63</span>));</span><br><span class="line">                        i += <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        c2 = utftext.charCodeAt(i + <span class="number">1</span>);</span><br><span class="line">                        c3 = utftext.charCodeAt(i + <span class="number">2</span>);</span><br><span class="line">                        string += <span class="built_in">String</span>.fromCharCode(((c &amp; <span class="number">15</span>) &lt;&lt; <span class="number">12</span>) | ((c2 &amp; <span class="number">63</span>) &lt;&lt; <span class="number">6</span>) | (c3 &amp; <span class="number">63</span>));</span><br><span class="line">                        i += <span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> string;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">        &lt;output id="output"&gt;&lt;/</span>output&gt;</span><br><span class="line">    &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="被监听的页面"><a href="#被监听的页面" class="headerlink" title="被监听的页面"></a>被监听的页面</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;用于修改localStorage 中数据的页面的代码&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">                    请输入一些值：&lt;input type=<span class="string">"text"</span> id=<span class="string">"text1"</span> /&gt;</span><br><span class="line">        &lt;button onclick=<span class="string">"setLOcalStorage()"</span>&gt;设置&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setLOcalStorage</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//设置test键值下的内容等于input框中的内容</span></span><br><span class="line">            localStorage.test = <span class="built_in">document</span>.getElementById(<span class="string">'text1'</span>).value;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>以上就是我对SessionStorage共享的一些理解看法，十分感觉各位大神对代码无私的分享</p>
]]></content>
      <categories>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>SessionStorage</tag>
        <tag>LocalStorage</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket的使用</title>
    <url>/2017/12/01/47-WebSocket%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>WebSocket提供了一个受欢迎的技术，以替代我们过去几年一直在用的Ajax技术。这个新的API提供了一个方法，从客户端使用简单的语法有效地推动消息到服务器。WebSocket API：它可用于客户端、服务器端。而且有一个优秀的第三方API，名为Socket.IO。</p>
</blockquote>
<a id="more"></a>

<p>其实WebSocket并不难理解，核心思想就是允许服务器主动发送信息给客户端。通过socket.on来监听，socket.emit发送，达到数据双向传递的效果</p>
<p>我们来看一下在服务端和客户端中，WebSocket都是怎么实现的,在代码中解释可能看的会清楚一点</p>
<blockquote>
<p>服务端中</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器及页面响应部分</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>),</span><br><span class="line"></span><br><span class="line">    app = express(),</span><br><span class="line">    </span><br><span class="line">    server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(app);</span><br><span class="line">    </span><br><span class="line">    io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>).listen(server); <span class="comment">//引入socket.io模块并绑定到服务器</span></span><br><span class="line">    </span><br><span class="line">    users=[];<span class="comment">//保存所有在线用户的昵称</span></span><br><span class="line">    </span><br><span class="line">app.use(<span class="string">'/'</span>, express.static(__dirname + <span class="string">'/www'</span>));<span class="comment">//指定静态HTML文件的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//socket部分</span></span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//昵称设置,接受login的一个处理</span></span><br><span class="line">    socket.on(<span class="string">'login'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">nickname</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (users.indexOf(nickname) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            socket.emit(<span class="string">'nickExisted'</span>); <span class="comment">//判断用户名是否存在,如果存在,则向自己发送一个nickExisted事件</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            socket.userIndex = users.length;</span><br><span class="line">            socket.nickname = nickname;</span><br><span class="line">            users.push(nickname);</span><br><span class="line">            socket.emit(<span class="string">'loginSuccess'</span>);</span><br><span class="line">            io.sockets.emit(<span class="string">'system'</span>, nickname, users.length, <span class="string">'login'</span>); <span class="comment">//向所有连接到服务器的客户端发送当前登陆用户的昵称 </span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//断开连接的事件</span></span><br><span class="line">	socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	    <span class="comment">//将断开连接的用户从users中删除</span></span><br><span class="line">	    users.splice(socket.userIndex, <span class="number">1</span>);</span><br><span class="line">	    <span class="comment">//通知除自己以外的所有人</span></span><br><span class="line">	    socket.broadcast.emit(<span class="string">'system'</span>, socket.nickname, users.length, <span class="string">'logout'</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收新消息</span></span><br><span class="line">    socket.on(<span class="string">'postMsg'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//将消息发送到除自己外的所有用户</span></span><br><span class="line">        socket.broadcast.emit(<span class="string">'newMsg'</span>, socket.nickname, msg);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接收用户发来的图片</span></span><br><span class="line">	socket.on(<span class="string">'img'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">imgData</span>) </span>&#123;</span><br><span class="line">	    <span class="comment">//通过一个newImg事件分发到除自己外的每个用户</span></span><br><span class="line">	    socket.broadcast.emit(<span class="string">'newImg'</span>, socket.nickname, imgData);</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*需要解释一下的是，在connection事件的回调函数中，socket表示的是当前连接到服务器的那个客户端。</span></span><br><span class="line"><span class="comment">所以代码socket.emit('foo')则只有自己收得到这个事件，而socket.broadcast.emit('foo')则</span></span><br><span class="line"><span class="comment">表示向除自己外的所有人发送该事件，另外，上面代码中，io表示服务器整个socket连接，所以代码</span></span><br><span class="line"><span class="comment">io.sockets.emit('foo')表示所有人都可以收到该事件。*/</span></span><br><span class="line"></span><br><span class="line">server.listen(process.env.PORT || <span class="number">8080</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务器开启成功'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>客户端中</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//实例并初始化我们的hichat程序</span></span><br><span class="line">    <span class="keyword">var</span> hichat = <span class="keyword">new</span> HiChat();</span><br><span class="line">    hichat.init();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义我们的hichat类</span></span><br><span class="line"><span class="keyword">var</span> HiChat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.socket = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向原型添加业务方法</span></span><br><span class="line">HiChat.prototype = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//此方法初始化程序</span></span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//建立到服务器的socket连接</span></span><br><span class="line">        <span class="keyword">this</span>.socket = io.connect();</span><br><span class="line">        <span class="comment">//监听socket的connect事件，此事件表示连接已经建立</span></span><br><span class="line">        <span class="keyword">this</span>.socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//连接到服务器后，显示昵称输入框</span></span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">'info'</span>).textContent = <span class="string">'请输入你的名称 '</span>;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">'nickWrapper'</span>).style.display = <span class="string">'block'</span>;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">'nicknameInput'</span>).focus();</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//昵称设置的确定按钮</span></span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'loginBtn'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		    <span class="keyword">var</span> nickName = <span class="built_in">document</span>.getElementById(<span class="string">'nicknameInput'</span>).value;</span><br><span class="line">		    <span class="comment">//检查昵称输入框是否为空</span></span><br><span class="line">		    <span class="keyword">if</span> (nickName.trim().length != <span class="number">0</span>) &#123;</span><br><span class="line">		        <span class="comment">//不为空，则发起一个login事件并将输入的昵称发送到服务器</span></span><br><span class="line">		        that.socket.emit(<span class="string">'login'</span>, nickName);</span><br><span class="line">		    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		        <span class="comment">//否则输入框获得焦点</span></span><br><span class="line">		        <span class="built_in">document</span>.getElementById(<span class="string">'nicknameInput'</span>).focus();</span><br><span class="line">		    &#125;;</span><br><span class="line">		&#125;, <span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//监听nickExisted事件,判断用户名是否重复</span></span><br><span class="line">        <span class="keyword">this</span>.socket.on(<span class="string">'nickExisted'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		    <span class="built_in">document</span>.getElementById(<span class="string">'info'</span>).textContent = <span class="string">'!nickname is taken, choose another pls'</span>; <span class="comment">//显示昵称被占用的提示</span></span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//监听loginSuccess事件,登录成功</span></span><br><span class="line">		<span class="keyword">this</span>.socket.on(<span class="string">'loginSuccess'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		    <span class="built_in">document</span>.title = <span class="string">'hichat | '</span> + <span class="built_in">document</span>.getElementById(<span class="string">'nicknameInput'</span>).value;</span><br><span class="line">		    <span class="built_in">document</span>.getElementById(<span class="string">'loginWrapper'</span>).style.display = <span class="string">'none'</span>;<span class="comment">//隐藏遮罩层显聊天界面</span></span><br><span class="line">		    <span class="built_in">document</span>.getElementById(<span class="string">'messageInput'</span>).focus();<span class="comment">//让消息输入框获得焦点</span></span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.socket.on(<span class="string">'system'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">nickName, userCount, type</span>) </span>&#123;</span><br><span class="line">		    <span class="comment">//判断用户是连接还是离开以显示不同的信息</span></span><br><span class="line">		    <span class="keyword">var</span> msg = nickName + (type == <span class="string">'login'</span> ? <span class="string">' 登录'</span> : <span class="string">' 离开'</span>);</span><br><span class="line">		 	<span class="comment">//指定系统消息显示为红色</span></span><br><span class="line">		    that._displayNewMsg(<span class="string">'system '</span>, msg, <span class="string">'red'</span>);</span><br><span class="line">		    <span class="comment">//将在线人数显示到页面顶部</span></span><br><span class="line">		    <span class="built_in">document</span>.getElementById(<span class="string">'status'</span>).textContent = userCount + <span class="string">' 用户在线'</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//监听用户发送消息</span></span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'sendBtn'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		    <span class="keyword">var</span> messageInput = <span class="built_in">document</span>.getElementById(<span class="string">'messageInput'</span>),</span><br><span class="line">		        msg = messageInput.value;</span><br><span class="line">		        <span class="comment">//获取颜色值</span></span><br><span class="line">        		color = <span class="built_in">document</span>.getElementById(<span class="string">'colorStyle'</span>).value;</span><br><span class="line">		    messageInput.value = <span class="string">''</span>;</span><br><span class="line">		    messageInput.focus();</span><br><span class="line">		    <span class="keyword">if</span> (msg.trim().length != <span class="number">0</span>) &#123;</span><br><span class="line">		    	<span class="comment">//显示和发送时带上颜色值参数</span></span><br><span class="line">		        that.socket.emit(<span class="string">'postMsg'</span>, msg, color); <span class="comment">//把消息发送到服务器</span></span><br><span class="line">		        that._displayNewMsg(<span class="string">'me'</span>, msg, color); <span class="comment">//把自己的消息显示到自己的窗口中</span></span><br><span class="line">		    &#125;;</span><br><span class="line">		&#125;, <span class="literal">false</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将监听到的消息显示出来</span></span><br><span class="line">		<span class="keyword">this</span>.socket.on(<span class="string">'newMsg'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">user, msg, color</span>) </span>&#123;</span><br><span class="line">		    that._displayNewMsg(user, msg, color);</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将图片读取为base64格式的字符串形式进行发送。而base64格式的图片直接可以指定为图片的src，这样就可以将图片用img标签显示在页面了。</span></span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'sendImage'</span>).addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	    <span class="comment">//检查是否有文件被选中</span></span><br><span class="line">		    <span class="keyword">if</span> (<span class="keyword">this</span>.files.length != <span class="number">0</span>) &#123;</span><br><span class="line">		        <span class="comment">//获取文件并用FileReader进行读取</span></span><br><span class="line">		        <span class="keyword">var</span> file = <span class="keyword">this</span>.files[<span class="number">0</span>],</span><br><span class="line">		             reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">		        <span class="keyword">if</span> (!reader) &#123;</span><br><span class="line">		            that._displayNewMsg(<span class="string">'system'</span>, <span class="string">'!your browser doesn\'t support fileReader'</span>, <span class="string">'red'</span>);</span><br><span class="line">		            <span class="keyword">this</span>.value = <span class="string">''</span>;</span><br><span class="line">		            <span class="keyword">return</span>;</span><br><span class="line">		        &#125;;</span><br><span class="line">		        reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">		            <span class="comment">//读取成功，显示到页面并发送到服务器</span></span><br><span class="line">		            <span class="keyword">this</span>.value = <span class="string">''</span>;</span><br><span class="line">		            that.socket.emit(<span class="string">'img'</span>, e.target.result);</span><br><span class="line">		            that._displayImage(<span class="string">'me'</span>, e.target.result);</span><br><span class="line">		        &#125;;</span><br><span class="line">		        reader.readAsDataURL(file);</span><br><span class="line">		    &#125;;</span><br><span class="line">		&#125;, <span class="literal">false</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//监听返回回来的图片</span></span><br><span class="line">		<span class="keyword">this</span>.socket.on(<span class="string">'newImg'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">user, img</span>) </span>&#123;</span><br><span class="line">		    that._displayImage(user, img);</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//载入表情包</span></span><br><span class="line">		<span class="keyword">this</span>._initialEmoji();</span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'emoji'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">		    <span class="keyword">var</span> emojiwrapper = <span class="built_in">document</span>.getElementById(<span class="string">'emojiWrapper'</span>);</span><br><span class="line">		    emojiwrapper.style.display = <span class="string">'block'</span>;</span><br><span class="line">		    e.stopPropagation();</span><br><span class="line">		&#125;, <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">		    <span class="keyword">var</span> emojiwrapper = <span class="built_in">document</span>.getElementById(<span class="string">'emojiWrapper'</span>);</span><br><span class="line">		    <span class="keyword">if</span> (e.target != emojiwrapper) &#123;</span><br><span class="line">		        emojiwrapper.style.display = <span class="string">'none'</span>;</span><br><span class="line">		    &#125;;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//监听哪个表情被点击了</span></span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'emojiWrapper'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">		    <span class="comment">//获取被点击的表情</span></span><br><span class="line">		    <span class="keyword">var</span> target = e.target;</span><br><span class="line">		    <span class="keyword">if</span> (target.nodeName.toLowerCase() == <span class="string">'img'</span>) &#123;</span><br><span class="line">		        <span class="keyword">var</span> messageInput = <span class="built_in">document</span>.getElementById(<span class="string">'messageInput'</span>);</span><br><span class="line">		        messageInput.focus();</span><br><span class="line">		        messageInput.value = messageInput.value + <span class="string">'[emoji:'</span> + target.title + <span class="string">']'</span>;</span><br><span class="line">		    &#125;;</span><br><span class="line">		&#125;, <span class="literal">false</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//监听输入名称按钮,按回车</span></span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'nicknameInput'</span>).addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">		    <span class="keyword">if</span> (e.keyCode == <span class="number">13</span>) &#123;</span><br><span class="line">		        <span class="keyword">var</span> nickName = <span class="built_in">document</span>.getElementById(<span class="string">'nicknameInput'</span>).value;</span><br><span class="line">		        <span class="keyword">if</span> (nickName.trim().length != <span class="number">0</span>) &#123;</span><br><span class="line">		            that.socket.emit(<span class="string">'login'</span>, nickName);</span><br><span class="line">		        &#125;;</span><br><span class="line">		    &#125;;</span><br><span class="line">		&#125;, <span class="literal">false</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//监听发送信息按钮,按回车</span></span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'messageInput'</span>).addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">		    <span class="keyword">var</span> messageInput = <span class="built_in">document</span>.getElementById(<span class="string">'messageInput'</span>),</span><br><span class="line">		        msg = messageInput.value,</span><br><span class="line">		        color = <span class="built_in">document</span>.getElementById(<span class="string">'colorStyle'</span>).value;</span><br><span class="line">		    <span class="keyword">if</span> (e.keyCode == <span class="number">13</span> &amp;&amp; msg.trim().length != <span class="number">0</span>) &#123;</span><br><span class="line">		        messageInput.value = <span class="string">''</span>;</span><br><span class="line">		        that.socket.emit(<span class="string">'postMsg'</span>, msg, color);</span><br><span class="line">		        that._displayNewMsg(<span class="string">'me'</span>, msg, color);</span><br><span class="line">		    &#125;;</span><br><span class="line">		&#125;, <span class="literal">false</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//清除聊天记录</span></span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'clearBtn'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">'historyMsg'</span>).innerHTML = <span class="string">''</span>;</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//创建聊天信息</span></span><br><span class="line">    _displayNewMsg: <span class="function"><span class="keyword">function</span>(<span class="params">user, msg, color</span>) </span>&#123;</span><br><span class="line">    	<span class="comment">//获取聊天框</span></span><br><span class="line">        <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'historyMsg'</span>),</span><br><span class="line">        <span class="comment">//创建聊天发送消息的标签</span></span><br><span class="line">        msgToDisplay = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>),</span><br><span class="line">        <span class="comment">//创建时间</span></span><br><span class="line">        date = <span class="keyword">new</span> <span class="built_in">Date</span>().toTimeString().substr(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="comment">//将消息中的表情转换为图片</span></span><br><span class="line">        msg = <span class="keyword">this</span>._showEmoji(msg);</span><br><span class="line">        <span class="comment">//字体颜色  </span></span><br><span class="line">        msgToDisplay.style.color = color || <span class="string">'#000'</span>;</span><br><span class="line">        <span class="comment">//加入信息</span></span><br><span class="line">        msgToDisplay.innerHTML = user + <span class="string">'&lt;span class="timespan"&gt;('</span> + date + <span class="string">'): &lt;/span&gt;'</span> + msg;</span><br><span class="line">        <span class="comment">//加入到聊天框中</span></span><br><span class="line">        container.appendChild(msgToDisplay);</span><br><span class="line">        container.scrollTop = container.scrollHeight;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//创建图片信息</span></span><br><span class="line">    _displayImage: <span class="function"><span class="keyword">function</span>(<span class="params">user, imgData, color</span>) </span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'historyMsg'</span>),</span><br><span class="line">	        msgToDisplay = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>),</span><br><span class="line">	        date = <span class="keyword">new</span> <span class="built_in">Date</span>().toTimeString().substr(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">	    msgToDisplay.style.color = color || <span class="string">'#000'</span>;</span><br><span class="line">	    msgToDisplay.innerHTML = user + <span class="string">'&lt;span class="timespan"&gt;('</span> + date + <span class="string">'): &lt;/span&gt; &lt;br/&gt;'</span> + <span class="string">'&lt;img src="'</span> + imgData + <span class="string">'"/&gt;'</span>;</span><br><span class="line">	    container.appendChild(msgToDisplay);</span><br><span class="line">	    container.scrollTop = container.scrollHeight;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//创建表情</span></span><br><span class="line">	_initialEmoji: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> emojiContainer = <span class="built_in">document</span>.getElementById(<span class="string">'emojiWrapper'</span>),</span><br><span class="line">	        docFragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">69</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">	        <span class="keyword">var</span> emojiItem = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">	        emojiItem.src = <span class="string">'../content/emoji/'</span> + i + <span class="string">'.gif'</span>;</span><br><span class="line">	        emojiItem.title = i;</span><br><span class="line">	        docFragment.appendChild(emojiItem);</span><br><span class="line">	    &#125;;</span><br><span class="line">	    emojiContainer.appendChild(docFragment);</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断消息文本中是否含有表情符号，如果有，则转换为图片，最后再显示到页面</span></span><br><span class="line">	_showEmoji: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;<span class="comment">//正则搜索其中的表情符号，将其替换为img标签，最后返回处理好的文本消息。</span></span><br><span class="line">	    <span class="keyword">var</span> match, result = msg,</span><br><span class="line">	        reg = <span class="regexp">/\[emoji:\d+\]/g</span>,</span><br><span class="line">	        emojiIndex,</span><br><span class="line">	        totalEmojiNum = <span class="built_in">document</span>.getElementById(<span class="string">'emojiWrapper'</span>).children.length;</span><br><span class="line">	    <span class="keyword">while</span> (match = reg.exec(msg)) &#123;</span><br><span class="line">	        emojiIndex = match[<span class="number">0</span>].slice(<span class="number">7</span>, <span class="number">-1</span>);</span><br><span class="line">	        <span class="keyword">if</span> (emojiIndex &gt; totalEmojiNum) &#123;</span><br><span class="line">	            result = result.replace(match[<span class="number">0</span>], <span class="string">'[X]'</span>);</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	            result = result.replace(match[<span class="number">0</span>], <span class="string">'&lt;img class="emoji" src="../content/emoji/'</span> + emojiIndex + <span class="string">'.gif" /&gt;'</span>);</span><br><span class="line">	        &#125;;</span><br><span class="line">	    &#125;;</span><br><span class="line">	    <span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>核心的代码就是这些，源码在我的github中有，以上就是我对WebSocket的一些理解看法，十分感觉各位大神对代码无私的分享，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环的异步操作</title>
    <url>/2018/01/08/48-for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>for循环的操作想必大家都不陌生,今天来探讨一下for循环的小陷阱</p>
</blockquote>
<a id="more"></a>

<p>什么都先不说,先上个代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码小伙伴肯定都很熟悉,for循环的基本操作,输出0,1,2,3,4.</p>
<blockquote>
<p>如果我在里面加一个setTimeout呢</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span> * i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一些小伙伴也想到了, setTimeout 会延迟执行，那么执行到 console.log 的时候，其实 i 已经变成 5 了，所以会每隔一秒输出一个5</p>
<blockquote>
<p>那应该怎么改才能输出 0 到 4 呢？</p>
</blockquote>
<p>其实加一个闭包就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于闭包的原理和实现,可以查看我另一篇博客,这里就不重复说啦</p>
<blockquote>
<p>看到这里是不是已经跃跃欲试了,如果,我把i删掉呢?会输出什么</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子的话，内部其实没有对 i 保持引用，闭包也就没有效果了,所以会每隔一秒输出一个5</p>
<blockquote>
<p>现在,我把代码改成这样,输出什么呢?</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;)(i), i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一看就懵了,什么,在setTimeout里面放入一个立即执行函数,其实,setTimeout 可以接受函数或者字符串作为参数，那么这里立即执行函数是个啥呢，应该是个 undefined ，也就是说等价于:setTimeout(undefined, …);所以会立马输出0~4</p>
<blockquote>
<p>好了,最后一题,放大招</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; resolve();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>莫慌,少年,我们来一步一步的分析</p>
<p>首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。</p>
<p>然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。</p>
<p>然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。</p>
<p>因此，应当先输出 5，然后再输出 4 。</p>
<p>最后在到下一个 tick，就是 1 。</p>
<p>所以最后的答案是 2 3 5 4 1</p>
<p>好了,今天for循环的知识点就先讨论到这里,如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>反向代理解决跨域问题</title>
    <url>/2018/01/19/49-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>现在大多数都是前后端分离,这时候,跨域问题就是前端小伙伴们关心的问题了,跨域的方法有很多种,今天重点说一下利用node或者nginx做反向代理</p>
</blockquote>
<a id="more"></a>

<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域?"></a>什么是跨域?</h2><p>跨域是由浏览器同源策略引起的，是指页面请求的接口地址，必须与页面url地址处于同域上（即域名，端口，协议相同）。这是为了防止某域名下的接口被其他域名下的网页非法调用，是浏览器对JavaScript施加的安全限制。</p>
<p>简单的来说,必须是相同的域名和相同的端口号才可以,否则就会存在跨域的问题</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote>
<p>简单的介绍一下前面几种方法</p>
</blockquote>
<ol>
<li>document.domain + iframe (只有在主域相同的时候才能使用该方法,这是变更源的一种操作 )</li>
<li>动态创建script (这个没什么好说的，因为script标签不受同源策略的限制。简单的说,有src属性的标签都不受同源策略的限制)</li>
<li>location.hash + iframe(同样需要目标服务器作处理,原理是利用location.hash来进行传值)</li>
<li>window.name + iframe (需要目标服务器响应window.name)</li>
<li>postMessage（这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。HTML5中的XMLHttpRequest Level 2中的API）</li>
<li>web sockets (web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。所以同源策略对web sockets不适用)</li>
<li>JSONP(jsonp应该是比较常用的了,但是需要目标服务器配合一个callback函数,并且它只支持GET请求而不支持POST等其它类型的HTTP请求)</li>
<li>CORS (这是目前最基本的解决方法,服务端会在HTTP请求头中增加一系列HTTP请求参数,例如Access-Control-Allow-Origin,但是需要后端的配合)</li>
</ol>
<p>以上八种跨域方式,只是稍微的说明一下,因为大多数都要后端进行配合,就没有我们前端独立就能完成的吗,今天重点说一下如何使用服务器进行反向代理</p>
<h2 id="Node服务器反向代理"><a href="#Node服务器反向代理" class="headerlink" title="Node服务器反向代理"></a>Node服务器反向代理</h2><p>首先, npm install express –save , npm install http-proxy-middleware –save,现在node包弄好,</p>
<p>随后在这个文件中创建一个public文件夹,用来放我们的静态资源</p>
<p>之后在跟目录中新建一个server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">"http-proxy-middleware"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">"./public"</span>));</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/api'</span>, proxy(&#123;</span><br><span class="line">  	target: <span class="string">'https://api.douban.com'</span>, <span class="comment">//这句话的意思就是说，凡是你的ajax请求里面带api的 就还会自动帮你向http://www.example.com这里进行数据请求</span></span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite:&#123;</span><br><span class="line">      <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>现在就可以进行跨域啦，比如我要请求的地址是  <a href="https://api.douban.com/v2/music/search?q=周杰伦" target="_blank" rel="noopener">https://api.douban.com/v2/music/search?q=周杰伦</a><br>这时，我只需要将地址改成 /api/v2/music/search?q=周杰伦 就可以啦。</p>
<h2 id="nginx代理"><a href="#nginx代理" class="headerlink" title="nginx代理"></a>nginx代理</h2><p>首先打开nginx的官网进行下载稳定版本，下载好后直接解压到你想要的文件夹下，启动nginx.exe文件，会出现一个一闪而过的页面，然后打开任意一个浏览器，输入 localhost，如果出现Welcome to nginx!几个大字，说明安装成功。</p>
<blockquote>
<p>但是，有些人就是打不开，原因很简单,80端口被占用了。 解决方法是：以管理员身份运行regedit打开键值:HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\HTTP在右边找到Start这一项，将其改为0重启系统，System进程不会占用80端口。</p>
</blockquote>
<p>一切解决完毕后，打开conf文件夹，找到nginx.conf这个文件 ,找到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">	listen       <span class="number">80</span>;</span><br><span class="line">   server_name  localhost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在404之前添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location /api&#123;</span><br><span class="line">	rewrite ^.+api/?(.*)$ /$<span class="number">1</span> <span class="keyword">break</span>;</span><br><span class="line">	proxy_pass https:<span class="comment">//api.douban.com;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后将静态 文件放入html文件中就可以进行跨域访问啦</p>
<p> 比如我要请求的地址是  <a href="https://api.douban.com/v2/music/search?q=周杰伦" target="_blank" rel="noopener">https://api.douban.com/v2/music/search?q=周杰伦</a><br> 我只需要将地址改成 /api/v2/music/search?q=周杰伦 就可以啦</p>
<blockquote>
<p>最后附上一些nginx常用的操作</p>
</blockquote>
<ol>
<li>tasklist /fi “imagename eq nginx.exe 查看nginx进程</li>
<li>nginx -s stop 强制关闭</li>
<li>nginx -s quit 安全关闭</li>
<li>nginx -s reload 改变配置文件的时候，重启nginx工作进程，来时配置文件生效</li>
<li>nginx -s reopen 打开日志文件</li>
</ol>
<p>好了,今天node/nginx的反向代理就先讨论到这里,如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli打包踩过的坑</title>
    <url>/2018/01/29/50-vue-cli%E6%89%93%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>写了一堆vue的代码，终于到了要打包部署上线了，许多小伙伴肯定都激动不已，但是发现打包之后一片空白，各种资源路径报错，今天就来讨论一下大家遇到的问题</p>
</blockquote>
<a id="more"></a>

<p>首先，bulid文件里面的东西我们就不看了，vue配置的差不多了，直接npm run build 会生成dist文件</p>
<p>将dist文件放在服务器上，遇到的第一个问题：</p>
<h2 id="资源引入错误，各种报错"><a href="#资源引入错误，各种报错" class="headerlink" title="资源引入错误，各种报错"></a>资源引入错误，各种报错</h2><p>莫慌，这是因为在开发环境和生产环境的相对路径和绝对路径导致的，在config文件夹-index.js中的assetsPublicPath: ‘/‘要改为’./‘</p>
<p>假如项目没有放在根目录,并且引入了静态文件,需要改成: assetsPublicPath: ‘/文件名/‘</p>
<h2 id="在css中设置的背景图片显示不出来"><a href="#在css中设置的背景图片显示不出来" class="headerlink" title="在css中设置的背景图片显示不出来"></a>在css中设置的背景图片显示不出来</h2><p>原因其实认真思考一下也能发现，因为在css中你添加的路径，你打包出来路径就不一样了啊，你可以再打包之后修改一下路径，也可以在build/utils.js中配置<br>加上一句 publicPath: ‘../../‘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (options.extract) &#123;</span><br><span class="line">  return ExtractTextPlugin.extract(&#123;</span><br><span class="line">    use: loaders,</span><br><span class="line">    fallback: &#39;vue-style-loader&#39;,</span><br><span class="line">    publicPath: &#39;..&#x2F;..&#x2F;&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return [&#39;vue-style-loader&#39;].concat(loaders)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用UI框架的小伙伴可能会发现，字体图标也不见了"><a href="#用UI框架的小伙伴可能会发现，字体图标也不见了" class="headerlink" title="用UI框架的小伙伴可能会发现，字体图标也不见了"></a>用UI框架的小伙伴可能会发现，字体图标也不见了</h2><p>别急，在webpack.base.conf.js里面修改limit要改大，把10000改为90000</p>
<h2 id="刷新时发现404"><a href="#刷新时发现404" class="headerlink" title="刷新时发现404"></a>刷新时发现404</h2><p>这你肯定在路由中设置了Historty模式 ，注释掉就好了</p>
<p>好了，以上就是我对vue-cli打包的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 2.0 配置说明</title>
    <url>/2018/02/04/51-vue-cli%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>之前总结过了Vue-cli,现在看看里面的配置文件都是干嘛用的,这个不是最新的Vue-cli,是老的版本,马上也出Vue-cli 3了,到时候再说,配置文件的解释我也是从百度找来的</p>
</blockquote>
<a id="more"></a>

<h3 id="build-dev-server-js"><a href="#build-dev-server-js" class="headerlink" title="build/dev-server.js"></a>build/dev-server.js</h3><p>首先来看执行”npm run dev”时候最先执行的build/dev-server.js文件。该文件主要完成下面几件事情：</p>
<ol>
<li>检查node和npm的版本、引入相关插件和配置</li>
<li>webpack对源码进行编译打包并返回compiler对象</li>
<li>创建express服务器</li>
<li>配置开发中间件（webpack-dev-middleware）和热重载中间件（webpack-hot-middleware）</li>
<li>挂载代理服务和中间件</li>
<li>配置静态资源</li>
<li>启动服务器监听特定端口（8080）</li>
<li>自动打开浏览器并打开特定网址（localhost:8080）</li>
</ol>
<p>说明： express服务器提供静态文件服务，不过它还使用了http-proxy-middleware，一个http请求代理的中间件。前端开发过程中需要使用到后台的API的话，可以通过配置proxyTable来将相应的后台请求代理到专用的API服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查NodeJS和npm的版本</span><br><span class="line">require(&#39;.&#x2F;check-versions&#39;)()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取基本配置</span><br><span class="line">var config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">&#x2F;&#x2F; 如果Node的环境变量中没有设置当前的环境（NODE_ENV），则使用config中的dev环境配置作为当前的环境</span><br><span class="line">if (!process.env.NODE_ENV) &#123;</span><br><span class="line">  process.env.NODE_ENV &#x3D; JSON.parse(config.dev.env.NODE_ENV)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; opn是一个可以调用默认软件打开网址、图片、文件等内容的插件</span><br><span class="line">&#x2F;&#x2F; 这里用它来调用默认浏览器打开dev-server监听的端口，例如：localhost:8080</span><br><span class="line">var opn &#x3D; require(&#39;opn&#39;)</span><br><span class="line">var path &#x3D; require(&#39;path&#39;)</span><br><span class="line">var express &#x3D; require(&#39;express&#39;)</span><br><span class="line">var webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">&#x2F;&#x2F; http-proxy-middleware是一个express中间件，用于将http请求代理到其他服务器</span><br><span class="line">&#x2F;&#x2F; 例：localhost:8080&#x2F;api&#x2F;xxx  --&gt;  localhost:3000&#x2F;api&#x2F;xxx</span><br><span class="line">&#x2F;&#x2F; 这里使用该插件可以将前端开发中涉及到的请求代理到提供服务的后台服务器上，方便与服务器对接</span><br><span class="line">var proxyMiddleware &#x3D; require(&#39;http-proxy-middleware&#39;)</span><br><span class="line">&#x2F;&#x2F; 开发环境下的webpack配置</span><br><span class="line">var webpackConfig &#x3D; require(&#39;.&#x2F;webpack.dev.conf&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; dev-server 监听的端口，如果没有在命令行传入端口号，则使用config.dev.port设置的端口，例如8080</span><br><span class="line">var port &#x3D; process.env.PORT || config.dev.port</span><br><span class="line">&#x2F;&#x2F; 用于判断是否要自动打开浏览器的布尔变量，当配置文件中没有设置自动打开浏览器的时候其值为 false</span><br><span class="line">var autoOpenBrowser &#x3D; !!config.dev.autoOpenBrowser</span><br><span class="line">&#x2F;&#x2F; HTTP代理表，指定规则，将某些API请求代理到相应的服务器</span><br><span class="line">var proxyTable &#x3D; config.dev.proxyTable</span><br><span class="line">&#x2F;&#x2F; 创建express服务器</span><br><span class="line">var app &#x3D; express()</span><br><span class="line">&#x2F;&#x2F; webpack根据配置开始编译打包源码并返回compiler对象</span><br><span class="line">var compiler &#x3D; webpack(webpackConfig)</span><br><span class="line">&#x2F;&#x2F; webpack-dev-middleware将webpack编译打包后得到的产品文件存放在内存中而没有写进磁盘</span><br><span class="line">&#x2F;&#x2F; 将这个中间件挂到express上使用之后即可提供这些编译后的产品文件服务</span><br><span class="line">var devMiddleware &#x3D; require(&#39;webpack-dev-middleware&#39;)(compiler, &#123;</span><br><span class="line">  publicPath: webpackConfig.output.publicPath, &#x2F;&#x2F; 设置访问路径为webpack配置中的output里面所对应的路径</span><br><span class="line">  quiet: true &#x2F;&#x2F; 设置为true，使其不要在控制台输出日志</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; webpack-hot-middleware，用于实现热重载功能的中间件</span><br><span class="line">var hotMiddleware &#x3D; require(&#39;webpack-hot-middleware&#39;)(compiler, &#123;</span><br><span class="line">  log: false, &#x2F;&#x2F; 关闭控制台的日志输出</span><br><span class="line">  heartbeat: 2000 &#x2F;&#x2F; 发送心跳包的频率</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; webpack(重新)编译打包完成后并将js、css等文件inject到html文件之后，通过热重载中间件强制页面刷新</span><br><span class="line">compiler.plugin(&#39;compilation&#39;, function (compilation) &#123;</span><br><span class="line">  compilation.plugin(&#39;html-webpack-plugin-after-emit&#39;, function (data, cb) &#123;</span><br><span class="line">    hotMiddleware.publish(&#123; action: &#39;reload&#39; &#125;)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据 proxyTable 中的代理请求配置来设置express服务器的http代理规则</span><br><span class="line">Object.keys(proxyTable).forEach(function (context) &#123;</span><br><span class="line">  var options &#x3D; proxyTable[context]</span><br><span class="line">  &#x2F;&#x2F; 格式化options，例如将&#39;www.example.com&#39;变成&#123; target: &#39;www.example.com&#39; &#125;</span><br><span class="line">  if (typeof options &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">    options &#x3D; &#123; target: options &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  app.use(proxyMiddleware(options.filter || context, options))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; handle fallback for HTML5 history API</span><br><span class="line">&#x2F;&#x2F; 重定向不存在的URL，用于支持SPA（单页应用）</span><br><span class="line">&#x2F;&#x2F; 例如使用vue-router并开启了history模式</span><br><span class="line">app.use(require(&#39;connect-history-api-fallback&#39;)())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; serve webpack bundle output</span><br><span class="line">&#x2F;&#x2F; 挂载webpack-dev-middleware中间件，提供webpack编译打包后的产品文件服务</span><br><span class="line">app.use(devMiddleware)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; enable hot-reload and state-preserving</span><br><span class="line">&#x2F;&#x2F; compilation error display</span><br><span class="line">&#x2F;&#x2F; 挂载热重载中间件</span><br><span class="line">app.use(hotMiddleware)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; serve pure static assets</span><br><span class="line">&#x2F;&#x2F; 提供static文件夹上的静态文件服务</span><br><span class="line">var staticPath &#x3D; path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)</span><br><span class="line">app.use(staticPath, express.static(&#39;.&#x2F;static&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 访问链接</span><br><span class="line">var uri &#x3D; &#39;http:&#x2F;&#x2F;localhost:&#39; + port</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建promise，在应用服务启动之后resolve</span><br><span class="line">&#x2F;&#x2F; 便于外部文件require了这个dev-server之后的代码编写</span><br><span class="line">var _resolve</span><br><span class="line">var readyPromise &#x3D; new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">  _resolve &#x3D; resolve</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&#39;&gt; Starting dev server...&#39;)</span><br><span class="line">&#x2F;&#x2F; webpack-dev-middleware等待webpack完成所有编译打包之后输出提示语到控制台，表明服务正式启动</span><br><span class="line">&#x2F;&#x2F; 服务正式启动才自动打开浏览器进入页面</span><br><span class="line">devMiddleware.waitUntilValid(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;&gt; Listening at &#39; + uri + &#39;\n&#39;)</span><br><span class="line">  &#x2F;&#x2F; when env is testing, don&#39;t need open it</span><br><span class="line">  if (autoOpenBrowser &amp;&amp; process.env.NODE_ENV !&#x3D;&#x3D; &#39;testing&#39;) &#123;</span><br><span class="line">    opn(uri)</span><br><span class="line">  &#125;</span><br><span class="line">  _resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动express服务器并监听相应的端口</span><br><span class="line">var server &#x3D; app.listen(port)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 暴露本模块的功能给外部使用，例如下面这种用法</span><br><span class="line">&#x2F;&#x2F; var devServer &#x3D; require(&#39;.&#x2F;build&#x2F;dev-server&#39;)</span><br><span class="line">&#x2F;&#x2F; devServer.ready.then(() &#x3D;&gt; &#123;...&#125;)</span><br><span class="line">&#x2F;&#x2F; if (...) &#123; devServer.close() &#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  ready: readyPromise,</span><br><span class="line">  close: () &#x3D;&gt; &#123;</span><br><span class="line">    server.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="build-webpack-base-conf-js"><a href="#build-webpack-base-conf-js" class="headerlink" title="build/webpack.base.conf.js"></a>build/webpack.base.conf.js</h3><p>从代码中看到，dev-server使用的webpack配置来自build/webpack.dev.conf.js文件（测试环境下使用的是build/webpack.prod.conf.js，这里暂时不考虑测试环境）。而build/webpack.dev.conf.js中又引用了webpack.base.conf.js，所以这里我先分析webpack.base.conf.js。</p>
<p>webpack.base.conf.js主要完成了下面这些事情：</p>
<p>配置webpack编译入口<br>配置webpack输出路径和命名规则<br>配置模块resolve规则<br>配置不同类型模块的处理规则</p>
<p>说明： 这个配置里面只配置了.js、.vue、图片、字体等几类文件的处理规则，如果需要处理其他文件可以在module.rules里面另行配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;webpack.base.conf.js是开发和生产共同使用提出来的基础配置文件，主要实现配制入口，配置输出环境，配置模块resolve和插件等</span><br><span class="line"></span><br><span class="line">var path &#x3D; require(&#39;path&#39;)</span><br><span class="line">var fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line">var utils &#x3D; require(&#39;.&#x2F;utils&#39;)</span><br><span class="line">var config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">var vueLoaderConfig &#x3D; require(&#39;.&#x2F;vue-loader.conf&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取绝对路径</span><br><span class="line">function resolve (dir) &#123;</span><br><span class="line">  &#x2F;&#x2F; 拼接出绝对路径</span><br><span class="line">  return path.join(__dirname, &#39;..&#39;, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; webpack入口文件</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#39;.&#x2F;src&#x2F;main.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; webpack输出路径和命名规则</span><br><span class="line">  output: &#123;</span><br><span class="line">    &#x2F;&#x2F; webpack输出的目标文件夹路径（例如：&#x2F;dist）</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    &#x2F;&#x2F; webpack输出bundle文件命名格式</span><br><span class="line">    filename: &#39;[name].js&#39;,</span><br><span class="line">    &#x2F;&#x2F; webpack编译输出的发布路径（例如&#39;&#x2F;&#x2F;cdn.xxx.com&#x2F;app&#x2F;&#39;）</span><br><span class="line">    publicPath: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      : config.dev.assetsPublicPath</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 模块resolve的规则</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    &#x2F;&#x2F;自动的扩展后缀，比如一个js文件，则引用时书写可不要写.js</span><br><span class="line">    extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;],</span><br><span class="line">    &#x2F;&#x2F; 别名，方便引用模块，例如有了别名之后，</span><br><span class="line">    &#x2F;&#x2F; import Vue from &#39;vue&#x2F;dist&#x2F;vue.common.js&#39;可以写成 import Vue from &#39;vue&#39;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      &#39;vue$&#39;: &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;,</span><br><span class="line">      &#39;@&#39;: resolve(&#39;src&#39;),</span><br><span class="line">    &#125;,</span><br><span class="line">    symlinks: false</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 不同类型模块的处理规则</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;&#x2F;&#x2F; 对src和test文件夹下的.js和.vue文件使用eslint-loader进行代码规范检查</span><br><span class="line">        test: &#x2F;\.(js|vue)$&#x2F;,</span><br><span class="line">        loader: &#39;eslint-loader&#39;,</span><br><span class="line">        enforce: &#39;pre&#39;,</span><br><span class="line">        include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;)],</span><br><span class="line">        options: &#123;</span><br><span class="line">          formatter: require(&#39;eslint-friendly-formatter&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;&#x2F;&#x2F; 对所有.vue文件使用vue-loader进行编译</span><br><span class="line">        test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">        loader: &#39;vue-loader&#39;,</span><br><span class="line">        options: vueLoaderConfig</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;&#x2F;&#x2F; 对src和test文件夹下的.js文件使用babel-loader将es6+的代码转成es5</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        loader: &#39;babel-loader&#39;,</span><br><span class="line">        include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;)]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;&#x2F;&#x2F; 对图片资源文件使用url-loader</span><br><span class="line">        test: &#x2F;\.(png|jpe?g|gif|svg)(\?.*)?$&#x2F;,</span><br><span class="line">        loader: &#39;url-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          &#x2F;&#x2F; 小于10K的图片转成base64编码的dataURL字符串写到代码中</span><br><span class="line">          limit: 10000,</span><br><span class="line">          &#x2F;&#x2F; 其他的图片转移到静态资源文件夹</span><br><span class="line">          name: utils.assetsPath(&#39;img&#x2F;[name].[hash:7].[ext]&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;&#x2F;&#x2F; 对多媒体资源文件使用url-loader</span><br><span class="line">        test: &#x2F;\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$&#x2F;,</span><br><span class="line">        loader: &#39;url-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          &#x2F;&#x2F; 小于10K的资源转成base64编码的dataURL字符串写到代码中</span><br><span class="line">          limit: 10000,</span><br><span class="line">          &#x2F;&#x2F; 其他的资源转移到静态资源文件夹</span><br><span class="line">          name: utils.assetsPath(&#39;media&#x2F;[name].[hash:7].[ext]&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;&#x2F;&#x2F; 对字体资源文件使用url-loader</span><br><span class="line">        test: &#x2F;\.(woff2?|eot|ttf|otf)(\?.*)?$&#x2F;,</span><br><span class="line">        loader: &#39;url-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          &#x2F;&#x2F; 小于10K的资源转成base64编码的dataURL字符串写到代码中</span><br><span class="line">          limit: 10000,</span><br><span class="line">          &#x2F;&#x2F; 其他的资源转移到静态资源文件夹</span><br><span class="line">          name: utils.assetsPath(&#39;fonts&#x2F;[name].[hash:7].[ext]&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="build-webpack-dev-conf-js"><a href="#build-webpack-dev-conf-js" class="headerlink" title="build/webpack.dev.conf.js"></a>build/webpack.dev.conf.js</h3><p>接下来看webpack.dev.conf.js，这里面在webpack.base.conf的基础上增加完善了开发环境下面的配置，主要包括下面几件事情：</p>
<ol>
<li>将webpack的热重载客户端代码添加到每个entry对应的应用</li>
<li>合并基础的webpack配置</li>
<li>配置样式文件的处理规则，styleLoaders</li>
<li>配置Source Maps</li>
<li>配置webpack插件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var utils &#x3D; require(&#39;.&#x2F;utils&#39;)</span><br><span class="line">var webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">var config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">&#x2F;&#x2F; webpack-merge是一个可以合并数组和对象的插件</span><br><span class="line">var merge &#x3D; require(&#39;webpack-merge&#39;)</span><br><span class="line">var baseWebpackConfig &#x3D; require(&#39;.&#x2F;webpack.base.conf&#39;)</span><br><span class="line">&#x2F;&#x2F; html-webpack-plugin用于将webpack编译打包后的产品文件注入到html模板中</span><br><span class="line">&#x2F;&#x2F; 即自动在index.html里面加上&lt;link&gt;和&lt;script&gt;标签引用webpack打包后的文件</span><br><span class="line">var HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)</span><br><span class="line">&#x2F;&#x2F; friendly-errors-webpack-plugin用于更友好地输出webpack的警告、错误等信息</span><br><span class="line">var FriendlyErrorsPlugin &#x3D; require(&#39;friendly-errors-webpack-plugin&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; add hot-reload related code to entry chunks</span><br><span class="line">&#x2F;&#x2F; 给每个入口页面(应用)加上dev-client，用于跟dev-server的热重载插件通信，实现热更新</span><br><span class="line">Object.keys(baseWebpackConfig.entry).forEach(function (name) &#123;</span><br><span class="line">  baseWebpackConfig.entry[name] &#x3D; [&#39;.&#x2F;build&#x2F;dev-client&#39;].concat(baseWebpackConfig.entry[name])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; merge(baseWebpackConfig, &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    &#x2F;&#x2F; 样式文件的处理规则，对css&#x2F;sass&#x2F;scss等不同内容使用相应的styleLoaders</span><br><span class="line">    &#x2F;&#x2F; 由utils配置出各种类型的预处理语言所需要使用的loader，例如sass需要使用sass-loader</span><br><span class="line">    rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; cheap-module-eval-source-map is faster for development</span><br><span class="line">  &#x2F;&#x2F; 使用这种source-map更快</span><br><span class="line">  devtool: &#39;#cheap-module-eval-source-map&#39;,</span><br><span class="line">  &#x2F;&#x2F; webpack插件</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &#39;process.env&#39;: config.dev.env</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; 开启webpack热更新功能</span><br><span class="line">    new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    &#x2F;&#x2F; webpack编译过程中出错的时候跳过报错阶段，不会阻塞编译，在编译结束后报错</span><br><span class="line">    new webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">    &#x2F;&#x2F; 自动将依赖注入html模板，并输出最终的html文件到目标文件夹</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: &#39;index.html&#39;,</span><br><span class="line">      template: &#39;index.html&#39;,</span><br><span class="line">      inject: true</span><br><span class="line">    &#125;),</span><br><span class="line">    new FriendlyErrorsPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="build-utils-js"><a href="#build-utils-js" class="headerlink" title="build/utils.js"></a>build/utils.js</h3><p>utils提供工具函数，包括生成处理各种样式语言的loader，获取资源文件存放路径的工具函数。 </p>
<ol>
<li>计算资源文件存放路径 </li>
<li>生成cssLoaders用于加载.vue文件中的样式 </li>
<li>生成styleLoaders用于加载不在.vue文件中的单独存在的样式文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var path &#x3D; require(&#39;path&#39;)</span><br><span class="line">var config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">&#x2F;&#x2F; extract-text-webpack-plugin可以提取bundle中的特定文本，将提取后的文本单独存放到另外的文件</span><br><span class="line">&#x2F;&#x2F; 这里用来提取css样式</span><br><span class="line">var ExtractTextPlugin &#x3D; require(&#39;extract-text-webpack-plugin&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 资源文件的存放路径</span><br><span class="line">&#x2F;&#x2F; 导出文件的位置，根据环境判断开发环境和生产环境，为config文件中index.js文件中定义的build.assetsSubDirectory或dev.assetsSubDirectory</span><br><span class="line">exports.assetsPath &#x3D; function (_path) &#123;</span><br><span class="line">  var assetsSubDirectory &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">    ? config.build.assetsSubDirectory</span><br><span class="line">    : config.dev.assetsSubDirectory</span><br><span class="line">    </span><br><span class="line">  &#x2F;&#x2F;Node.js path 模块提供了一些用于处理文件路径的小工具</span><br><span class="line">  return path.posix.join(assetsSubDirectory, _path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生成css、sass、scss等各种用来编写样式的语言所对应的loader配置</span><br><span class="line">exports.cssLoaders &#x3D; function (options) &#123;</span><br><span class="line">  options &#x3D; options || &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;使用了css-loader和postcssLoader，通过options.usePostCSS属性来判断是否使用postcssLoader中压缩等方法</span><br><span class="line">  &#x2F;&#x2F; css-loader配置</span><br><span class="line">  var cssLoader &#x3D; &#123;</span><br><span class="line">    loader: &#39;css-loader&#39;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      &#x2F;&#x2F; 是否最小化</span><br><span class="line">      minimize: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;,</span><br><span class="line">      &#x2F;&#x2F; 是否使用source-map</span><br><span class="line">      sourceMap: options.sourceMap</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; generate loader string to be used with extract text plugin</span><br><span class="line">  &#x2F;&#x2F; 生成各种loader配置，并且配置了extract-text-pulgin</span><br><span class="line">  function generateLoaders (loader, loaderOptions) &#123;</span><br><span class="line">    &#x2F;&#x2F; 默认是css-loader</span><br><span class="line">    var loaders &#x3D; [cssLoader]</span><br><span class="line">    &#x2F;&#x2F; 如果非css，则增加一个处理预编译语言的loader并设好相关配置属性</span><br><span class="line">    &#x2F;&#x2F; 例如generateLoaders(&#39;less&#39;)，这里就会push一个less-loader</span><br><span class="line">    &#x2F;&#x2F; less-loader先将less编译成css，然后再由css-loader去处理css</span><br><span class="line">    &#x2F;&#x2F; 其他sass、scss等语言也是一样的过程</span><br><span class="line">    if (loader) &#123;</span><br><span class="line">      loaders.push(&#123;</span><br><span class="line">        loader: loader + &#39;-loader&#39;,</span><br><span class="line">        &#x2F;&#x2F;Object.assign是es6语法的浅复制，后两者合并后复制完成赋值</span><br><span class="line">        options: Object.assign(&#123;&#125;, loaderOptions, &#123;</span><br><span class="line">          sourceMap: options.sourceMap</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Extract CSS when that option is specified</span><br><span class="line">    &#x2F;&#x2F; (which is the case during production build)</span><br><span class="line">    if (options.extract) &#123;</span><br><span class="line">      &#x2F;&#x2F; 配置extract-text-plugin提取样式</span><br><span class="line">      &#x2F;&#x2F; ExtractTextPlugin可提取出文本，代表首先使用上面处理的loaders，当未能正确引入时使用vue-style-loader</span><br><span class="line">      return ExtractTextPlugin.extract(&#123;</span><br><span class="line">        use: loaders,</span><br><span class="line">        fallback: &#39;vue-style-loader&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 无需提取样式则简单使用vue-style-loader配合各种样式loader去处理&lt;style&gt;里面的样式</span><br><span class="line">      &#x2F;&#x2F; 返回vue-style-loader连接loaders的最终值</span><br><span class="line">      return [&#39;vue-style-loader&#39;].concat(loaders)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; https:&#x2F;&#x2F;vue-loader.vuejs.org&#x2F;en&#x2F;configurations&#x2F;extract-css.html</span><br><span class="line">  &#x2F;&#x2F; 得到各种不同处理样式的语言所对应的loader</span><br><span class="line">  return &#123;</span><br><span class="line">    css: generateLoaders(), &#x2F;&#x2F;需要css-loader 和 vue-style-loader</span><br><span class="line">    postcss: generateLoaders(), &#x2F;&#x2F;需要css-loader和postcssLoader  和 vue-style-loader</span><br><span class="line">    less: generateLoaders(&#39;less&#39;),&#x2F;&#x2F;需要less-loader 和 vue-style-loader</span><br><span class="line">    sass: generateLoaders(&#39;sass&#39;, &#123; indentedSyntax: true &#125;),&#x2F;&#x2F;需要sass-loader 和 vue-style-loader</span><br><span class="line">    scss: generateLoaders(&#39;sass&#39;), &#x2F;&#x2F;需要sass-loader 和 vue-style-loader</span><br><span class="line">    stylus: generateLoaders(&#39;stylus&#39;),&#x2F;&#x2F;需要stylus-loader 和 vue-style-loader</span><br><span class="line">    styl: generateLoaders(&#39;stylus&#39;)&#x2F;&#x2F;需要stylus-loader 和 vue-style-loader</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Generate loaders for standalone style files (outside of .vue)</span><br><span class="line">&#x2F;&#x2F; 生成处理单独的.css、.sass、.scss等样式文件的规则</span><br><span class="line">exports.styleLoaders &#x3D; function (options) &#123;</span><br><span class="line">  var output &#x3D; []</span><br><span class="line">  var loaders &#x3D; exports.cssLoaders(options)</span><br><span class="line">  for (var extension in loaders) &#123;</span><br><span class="line">    var loader &#x3D; loaders[extension]</span><br><span class="line">    &#x2F;&#x2F;将各种css,less,sass等综合在一起得出结果输出output</span><br><span class="line">    output.push(&#123;</span><br><span class="line">      test: new RegExp(&#39;\\.&#39; + extension + &#39;$&#39;),</span><br><span class="line">      use: loader</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  return output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="build-vue-loader-conf-js"><a href="#build-vue-loader-conf-js" class="headerlink" title="build/vue-loader.conf.js"></a>build/vue-loader.conf.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var utils &#x3D; require(&#39;.&#x2F;utils&#39;)</span><br><span class="line">var config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">var isProduction &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理.vue文件中的样式</span><br><span class="line">  loaders: utils.cssLoaders(&#123;</span><br><span class="line">    &#x2F;&#x2F; 是否打开source-map</span><br><span class="line">    sourceMap: isProduction</span><br><span class="line">      ? config.build.productionSourceMap</span><br><span class="line">      : config.dev.cssSourceMap,</span><br><span class="line">    &#x2F;&#x2F; 是否提取样式到单独的文件</span><br><span class="line">    extract: isProduction</span><br><span class="line">  &#125;),</span><br><span class="line">  transformToRequire: &#123;</span><br><span class="line">    video: &#39;src&#39;,</span><br><span class="line">    source: &#39;src&#39;,</span><br><span class="line">    img: &#39;src&#39;,</span><br><span class="line">    image: &#39;xlink:href&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="build-dev-client-js"><a href="#build-dev-client-js" class="headerlink" title="build/dev-client.js"></a>build/dev-client.js</h3><p>dev-client.js里面主要写了浏览器端代码，用于实现webpack的热更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-disable *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 实现浏览器端的EventSource，用于跟服务器双向通信</span><br><span class="line">&#x2F;&#x2F; webpack热重载客户端跟dev-server上的热重载插件之间需要进行双向通信</span><br><span class="line">&#x2F;&#x2F; 服务端webpack重新编译后，会向客户端推送信息，告诉客户端进行更新</span><br><span class="line">require(&#39;eventsource-polyfill&#39;)</span><br><span class="line">&#x2F;&#x2F; webpack热重载客户端</span><br><span class="line">var hotClient &#x3D; require(&#39;webpack-hot-middleware&#x2F;client?noInfo&#x3D;true&amp;reload&#x3D;true&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 客户端收到更新动作，执行页面刷新</span><br><span class="line">hotClient.subscribe(function (event) &#123;</span><br><span class="line">  if (event.action &#x3D;&#x3D;&#x3D; &#39;reload&#39;) &#123;</span><br><span class="line">    window.location.reload()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="build-build-js"><a href="#build-build-js" class="headerlink" title="build/build.js"></a>build/build.js</h3><p>讲完了开发环境下的配置，下面开始来看构建环境下的配置。执行”npm run build”的时候首先执行的是build/build.js文件，build.js主要完成下面几件事：</p>
<ol>
<li>loading动画</li>
<li>删除目标文件夹</li>
<li>执行webpack构建</li>
<li>输出信息</li>
<li>说明： webpack编译之后会输出到配置里面指定的目标文件夹；删除目标文件夹之后再创建是为了去除旧的内容，以免产生不可预测的影响。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查NodeJS和npm的版本,加（）代表直接调用该函数，首先检查node和npm的版本</span><br><span class="line">require(&#39;.&#x2F;check-versions&#39;)()</span><br><span class="line"></span><br><span class="line">process.env.NODE_ENV &#x3D; &#39;production&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ora，一个可以在终端显示spinner的插件</span><br><span class="line">var ora &#x3D; require(&#39;ora&#39;)</span><br><span class="line">&#x2F;&#x2F; rm，用于删除文件或文件夹的插件</span><br><span class="line">var rm &#x3D; require(&#39;rimraf&#39;)</span><br><span class="line">var path &#x3D; require(&#39;path&#39;)</span><br><span class="line">&#x2F;&#x2F; chalk，用于在控制台输出带颜色字体的插件</span><br><span class="line">var chalk &#x3D; require(&#39;chalk&#39;)</span><br><span class="line">var webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">&#x2F;&#x2F; 默认读取下面的index.js文件</span><br><span class="line">var config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">var webpackConfig &#x3D; require(&#39;.&#x2F;webpack.prod.conf&#39;)</span><br><span class="line"></span><br><span class="line">var spinner &#x3D; ora(&#39;building for production...&#39;)</span><br><span class="line">spinner.start() &#x2F;&#x2F; 开启loading动画</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 首先将整个dist文件夹以及里面的内容删除，以免遗留旧的没用的文件</span><br><span class="line">&#x2F;&#x2F; 删除完成后才开始webpack构建打包</span><br><span class="line">rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err &#x3D;&gt; &#123;</span><br><span class="line">  if (err) throw err</span><br><span class="line">  &#x2F;&#x2F; 执行webpack构建打包，完成之后在终端输出构建完成的相关信息或者输出报错信息并退出程序</span><br><span class="line">  webpack(webpackConfig, function (err, stats) &#123;</span><br><span class="line">    spinner.stop()</span><br><span class="line">    if (err) throw err</span><br><span class="line">    process.stdout.write(stats.toString(&#123;</span><br><span class="line">      colors: true,</span><br><span class="line">      modules: false,</span><br><span class="line">      children: false,</span><br><span class="line">      chunks: false,</span><br><span class="line">      chunkModules: false</span><br><span class="line">    &#125;) + &#39;\n\n&#39;)</span><br><span class="line"></span><br><span class="line">    if (stats.hasErrors()) &#123;</span><br><span class="line">      console.log(chalk.red(&#39;  Build failed with errors.\n&#39;))</span><br><span class="line">      process.exit(1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(chalk.cyan(&#39;  Build complete.\n&#39;))</span><br><span class="line">    console.log(chalk.yellow(</span><br><span class="line">      &#39;  Tip: built files are meant to be served over an HTTP server.\n&#39; +</span><br><span class="line">      &#39;  Opening index.html over file:&#x2F;&#x2F; won\&#39;t work.\n&#39;</span><br><span class="line">    ))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="build-webpack-prod-conf-js"><a href="#build-webpack-prod-conf-js" class="headerlink" title="build/webpack.prod.conf.js"></a>build/webpack.prod.conf.js</h3><p>构建的时候用到的webpack配置来自webpack.prod.conf.js，该配置同样是在webpack.base.conf基础上的进一步完善。主要完成下面几件事情：</p>
<ol>
<li>合并基础的webpack配置</li>
<li>配置样式文件的处理规则，styleLoaders</li>
<li>配置webpack的输出</li>
<li>配置webpack插件</li>
<li>gzip模式下的webpack插件配置</li>
<li>webpack-bundle分析</li>
</ol>
<p>说明： webpack插件里面多了丑化压缩代码以及抽离css文件等插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var path &#x3D; require(&#39;path&#39;)</span><br><span class="line">var utils &#x3D; require(&#39;.&#x2F;utils&#39;)</span><br><span class="line">var webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">var config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">var merge &#x3D; require(&#39;webpack-merge&#39;)</span><br><span class="line">var baseWebpackConfig &#x3D; require(&#39;.&#x2F;webpack.base.conf&#39;)</span><br><span class="line">&#x2F;&#x2F; copy-webpack-plugin，用于将static中的静态文件复制到产品文件夹dist</span><br><span class="line">var CopyWebpackPlugin &#x3D; require(&#39;copy-webpack-plugin&#39;)</span><br><span class="line">var HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)</span><br><span class="line">var ExtractTextPlugin &#x3D; require(&#39;extract-text-webpack-plugin&#39;)</span><br><span class="line">&#x2F;&#x2F; optimize-css-assets-webpack-plugin，用于优化和最小化css资源</span><br><span class="line">var OptimizeCSSPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;)</span><br><span class="line"></span><br><span class="line">var env &#x3D; config.build.env</span><br><span class="line"></span><br><span class="line">var webpackConfig &#x3D; merge(baseWebpackConfig, &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    &#x2F;&#x2F; 样式文件的处理规则，对css&#x2F;sass&#x2F;scss等不同内容使用相应的styleLoaders</span><br><span class="line">    &#x2F;&#x2F; 由utils配置出各种类型的预处理语言所需要使用的loader，例如sass需要使用sass-loader</span><br><span class="line">    rules: utils.styleLoaders(&#123;</span><br><span class="line">      sourceMap: config.build.productionSourceMap,</span><br><span class="line">      extract: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 是否使用source-map</span><br><span class="line">  devtool: config.build.productionSourceMap ? &#39;#source-map&#39; : false,</span><br><span class="line">  &#x2F;&#x2F; webpack输出路径和命名规则</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    filename: utils.assetsPath(&#39;js&#x2F;[name].[chunkhash].js&#39;),</span><br><span class="line">    chunkFilename: utils.assetsPath(&#39;js&#x2F;[id].[chunkhash].js&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; webpack插件</span><br><span class="line">  plugins: [</span><br><span class="line">    &#x2F;&#x2F; http:&#x2F;&#x2F;vuejs.github.io&#x2F;vue-loader&#x2F;en&#x2F;workflow&#x2F;production.html</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &#39;process.env&#39;: env</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; 丑化压缩JS代码</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: false</span><br><span class="line">      &#125;,</span><br><span class="line">      sourceMap: true</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; extract css into its own file</span><br><span class="line">    &#x2F;&#x2F; 将css提取到单独的文件</span><br><span class="line">    new ExtractTextPlugin(&#123;</span><br><span class="line">      filename: utils.assetsPath(&#39;css&#x2F;[name].[contenthash].css&#39;)</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; Compress extracted CSS. We are using this plugin so that possible</span><br><span class="line">    &#x2F;&#x2F; duplicated CSS from different components can be deduped.</span><br><span class="line">    &#x2F;&#x2F; 优化、最小化css代码，如果只简单使用extract-text-plugin可能会造成css重复</span><br><span class="line">    &#x2F;&#x2F; 具体原因可以看npm上面optimize-css-assets-webpack-plugin的介绍</span><br><span class="line">    new OptimizeCSSPlugin(&#123;</span><br><span class="line">      cssProcessorOptions: &#123;</span><br><span class="line">        safe: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; generate dist index.html with correct asset hash for caching.</span><br><span class="line">    &#x2F;&#x2F; you can customize output by editing &#x2F;index.html</span><br><span class="line">    &#x2F;&#x2F; see https:&#x2F;&#x2F;github.com&#x2F;ampedandwired&#x2F;html-webpack-plugin</span><br><span class="line">    &#x2F;&#x2F; 将产品文件的引用注入到index.html</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: config.build.index,</span><br><span class="line">      template: &#39;index.html&#39;,</span><br><span class="line">      inject: true,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        &#x2F;&#x2F; 删除index.html中的注释</span><br><span class="line">        removeComments: true,</span><br><span class="line">        &#x2F;&#x2F; 删除index.html中的空格</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        &#x2F;&#x2F; 删除各种html标签属性值的双引号</span><br><span class="line">        removeAttributeQuotes: true</span><br><span class="line">        &#x2F;&#x2F; more options:</span><br><span class="line">        &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;kangax&#x2F;html-minifier#options-quick-reference</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; necessary to consistently work with multiple chunks via CommonsChunkPlugin</span><br><span class="line">      &#x2F;&#x2F; 注入依赖的时候按照依赖先后顺序进行注入，比如，需要先注入vendor.js，再注入app.js</span><br><span class="line">      chunksSortMode: &#39;dependency&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; keep module.id stable when vender modules does not change</span><br><span class="line">    new webpack.HashedModuleIdsPlugin(),</span><br><span class="line">    &#x2F;&#x2F; split vendor js into its own file</span><br><span class="line">    &#x2F;&#x2F; 将所有从node_modules中引入的js提取到vendor.js，即抽取库文件</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: &#39;vendor&#39;,</span><br><span class="line">      minChunks: function (module, count) &#123;</span><br><span class="line">        &#x2F;&#x2F; any required modules inside node_modules are extracted to vendor</span><br><span class="line">        return (</span><br><span class="line">          module.resource &amp;&amp;</span><br><span class="line">          &#x2F;\.js$&#x2F;.test(module.resource) &amp;&amp;</span><br><span class="line">          module.resource.indexOf(</span><br><span class="line">            path.join(__dirname, &#39;..&#x2F;node_modules&#39;)</span><br><span class="line">          ) &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; extract webpack runtime and module manifest to its own file in order to</span><br><span class="line">    &#x2F;&#x2F; prevent vendor hash from being updated whenever app bundle is updated</span><br><span class="line">    &#x2F;&#x2F; 从vendor中提取出manifest，原因如上</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: &#39;manifest&#39;,</span><br><span class="line">      chunks: [&#39;vendor&#39;]</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; copy custom static assets</span><br><span class="line">    &#x2F;&#x2F; 将static文件夹里面的静态资源复制到dist&#x2F;static</span><br><span class="line">    new CopyWebpackPlugin([</span><br><span class="line">      &#123;</span><br><span class="line">        from: path.resolve(__dirname, &#39;..&#x2F;static&#39;),</span><br><span class="line">        to: config.build.assetsSubDirectory,</span><br><span class="line">        ignore: [&#39;.*&#39;]</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果开启了产品gzip压缩，则利用插件将构建后的产品文件进行压缩</span><br><span class="line">if (config.build.productionGzip) &#123;</span><br><span class="line">  &#x2F;&#x2F; 一个用于压缩的webpack插件</span><br><span class="line">  var CompressionWebpackPlugin &#x3D; require(&#39;compression-webpack-plugin&#39;)</span><br><span class="line"></span><br><span class="line">  webpackConfig.plugins.push(</span><br><span class="line">    new CompressionWebpackPlugin(&#123;</span><br><span class="line">      asset: &#39;[path].gz[query]&#39;,</span><br><span class="line">      &#x2F;&#x2F; 压缩算法</span><br><span class="line">      algorithm: &#39;gzip&#39;,</span><br><span class="line">      test: new RegExp(</span><br><span class="line">        &#39;\\.(&#39; +</span><br><span class="line">        config.build.productionGzipExtensions.join(&#39;|&#39;) +</span><br><span class="line">        &#39;)$&#39;</span><br><span class="line">      ),</span><br><span class="line">      threshold: 10240,</span><br><span class="line">      minRatio: 0.8</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果启动了report，则通过插件给出webpack构建打包后的产品文件分析报告</span><br><span class="line">if (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">  var BundleAnalyzerPlugin &#x3D; require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin</span><br><span class="line">  webpackConfig.plugins.push(new BundleAnalyzerPlugin())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; webpackConfig</span><br></pre></td></tr></table></figure>

<h3 id="build-check-versions-js"><a href="#build-check-versions-js" class="headerlink" title="build/check-versions.js"></a>build/check-versions.js</h3><p>最后是build文件夹下的check-version.js，它完成对node和npm的版本检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; chalk, 用于在控制台输出带颜色字体的插件</span><br><span class="line">var chalk &#x3D; require(&#39;chalk&#39;)</span><br><span class="line">&#x2F;&#x2F; semver, 语义化版本检查插件（The semantic version parser used by npm）</span><br><span class="line">var semver &#x3D; require(&#39;semver&#39;)</span><br><span class="line">var packageConfig &#x3D; require(&#39;..&#x2F;package.json&#39;)</span><br><span class="line">&#x2F;&#x2F; shelljs, 执行Unix命令行的插件</span><br><span class="line">var shell &#x3D; require(&#39;shelljs&#39;)</span><br><span class="line">&#x2F;&#x2F; 开辟子进程执行指令cmd并返回结果</span><br><span class="line">function exec (cmd) &#123;</span><br><span class="line">  &#x2F;&#x2F;返回通过child_process模块的新建子进程，执行 Unix 系统命令后转成没有空格的字符串</span><br><span class="line">  return require(&#39;child_process&#39;).execSync(cmd).toString().trim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; node和npm版本需求</span><br><span class="line">var versionRequirements &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &#39;node&#39;,</span><br><span class="line">    currentVersion: semver.clean(process.version), &#x2F;&#x2F;使用semver格式化版本</span><br><span class="line">    versionRequirement: packageConfig.engines.node &#x2F;&#x2F;获取package.json中设置的node版本</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">if (shell.which(&#39;npm&#39;)) &#123;</span><br><span class="line">  versionRequirements.push(&#123;</span><br><span class="line">    name: &#39;npm&#39;,</span><br><span class="line">    currentVersion: exec(&#39;npm --version&#39;), &#x2F;&#x2F; 自动调用npm --version命令，并且把参数返回给exec函数，从而获取纯净的版本号</span><br><span class="line">    versionRequirement: packageConfig.engines.npm</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function () &#123;</span><br><span class="line">  var warnings &#x3D; []</span><br><span class="line">  &#x2F;&#x2F; 依次判断版本是否符合要求</span><br><span class="line">  for (var i &#x3D; 0; i &lt; versionRequirements.length; i++) &#123;</span><br><span class="line">    var mod &#x3D; versionRequirements[i]</span><br><span class="line">    if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123;</span><br><span class="line">      &#x2F;&#x2F;上面这个判断就是如果版本号不符合package.json文件中指定的版本号，就执行下面错误提示的代码</span><br><span class="line">      warnings.push(mod.name + &#39;: &#39; +</span><br><span class="line">        chalk.red(mod.currentVersion) + &#39; should be &#39; +</span><br><span class="line">        chalk.green(mod.versionRequirement)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 如果有警告则将其输出到控制台</span><br><span class="line">  if (warnings.length) &#123;</span><br><span class="line">    console.log(&#39;&#39;)</span><br><span class="line">    console.log(chalk.yellow(&#39;To use this template, you must update following to modules:&#39;))</span><br><span class="line">    console.log()</span><br><span class="line">    for (var i &#x3D; 0; i &lt; warnings.length; i++) &#123;</span><br><span class="line">      var warning &#x3D; warnings[i]</span><br><span class="line">      console.log(&#39;  &#39; + warning)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log()</span><br><span class="line">    process.exit(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="config-index-js"><a href="#config-index-js" class="headerlink" title="config/index.js"></a>config/index.js</h3><p>config文件夹下最主要的文件就是index.js了，在这里面描述了开发和构建两种环境下的配置，前面的build文件夹下也有不少文件引用了index.js里面的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; see http:&#x2F;&#x2F;vuejs-templates.github.io&#x2F;webpack for documentation.</span><br><span class="line">var path &#x3D; require(&#39;path&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 构建产品时使用的配置</span><br><span class="line">  build: &#123;</span><br><span class="line">    &#x2F;&#x2F; 环境变量</span><br><span class="line">    env: require(&#39;.&#x2F;prod.env&#39;),</span><br><span class="line">    &#x2F;&#x2F; html入口文件</span><br><span class="line">    index: path.resolve(__dirname, &#39;..&#x2F;dist&#x2F;index.html&#39;),</span><br><span class="line">    &#x2F;&#x2F; 产品文件的存放路径</span><br><span class="line">    assetsRoot: path.resolve(__dirname, &#39;..&#x2F;dist&#39;),</span><br><span class="line">    &#x2F;&#x2F; 二级目录，存放静态资源文件的目录，位于dist文件夹下</span><br><span class="line">    assetsSubDirectory: &#39;static&#39;,</span><br><span class="line">    &#x2F;&#x2F; 发布路径，如果构建后的产品文件有用于发布CDN或者放到其他域名的服务器，可以在这里进行设置</span><br><span class="line">    &#x2F;&#x2F; 设置之后构建的产品文件在注入到index.html中的时候就会带上这里的发布路径</span><br><span class="line">    assetsPublicPath: &#39;&#x2F;&#39;,</span><br><span class="line">    &#x2F;&#x2F; 是否使用source-map</span><br><span class="line">    productionSourceMap: true,</span><br><span class="line">    &#x2F;&#x2F; Gzip off by default as many popular static hosts such as</span><br><span class="line">    &#x2F;&#x2F; Surge or Netlify already gzip all static assets for you.</span><br><span class="line">    &#x2F;&#x2F; Before setting to &#96;true&#96;, make sure to:</span><br><span class="line">    &#x2F;&#x2F; npm install --save-dev compression-webpack-plugin</span><br><span class="line">    &#x2F;&#x2F; 是否开启gzip压缩</span><br><span class="line">    productionGzip: false,</span><br><span class="line">    &#x2F;&#x2F; gzip模式下需要压缩的文件的扩展名，设置js、css之后就只会对js和css文件进行压缩</span><br><span class="line">    productionGzipExtensions: [&#39;js&#39;, &#39;css&#39;],</span><br><span class="line">    &#x2F;&#x2F; Run the build command with an extra argument to</span><br><span class="line">    &#x2F;&#x2F; View the bundle analyzer report after build finishes:</span><br><span class="line">    &#x2F;&#x2F; &#96;npm run build --report&#96;</span><br><span class="line">    &#x2F;&#x2F; Set to &#96;true&#96; or &#96;false&#96; to always turn it on or off</span><br><span class="line">    &#x2F;&#x2F; 是否展示webpack构建打包之后的分析报告</span><br><span class="line">    bundleAnalyzerReport: process.env.npm_config_report</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 开发过程中使用的配置</span><br><span class="line">  dev: &#123;</span><br><span class="line">    &#x2F;&#x2F; 环境变量</span><br><span class="line">    env: require(&#39;.&#x2F;dev.env&#39;),</span><br><span class="line">    &#x2F;&#x2F; dev-server监听的端口</span><br><span class="line">    port: 8080,</span><br><span class="line">    &#x2F;&#x2F; 是否自动打开浏览器</span><br><span class="line">    autoOpenBrowser: true,</span><br><span class="line">    &#x2F;&#x2F; 静态资源文件夹</span><br><span class="line">    assetsSubDirectory: &#39;static&#39;,</span><br><span class="line">    &#x2F;&#x2F; 发布路径</span><br><span class="line">    assetsPublicPath: &#39;&#x2F;&#39;,</span><br><span class="line">    &#x2F;&#x2F; 代理配置表，在这里可以配置特定的请求代理到对应的API接口</span><br><span class="line">    &#x2F;&#x2F; 例如将&#39;localhost:8080&#x2F;api&#x2F;xxx&#39;代理到&#39;www.example.com&#x2F;api&#x2F;xxx&#39;</span><br><span class="line">    proxyTable: &#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;</span><br><span class="line">    &#x2F;&#x2F; with this option, according to the CSS-Loader README</span><br><span class="line">    &#x2F;&#x2F; (https:&#x2F;&#x2F;github.com&#x2F;webpack&#x2F;css-loader#sourcemaps)</span><br><span class="line">    &#x2F;&#x2F; In our experience, they generally work as expected,</span><br><span class="line">    &#x2F;&#x2F; just be aware of this issue when enabling this option.</span><br><span class="line">    &#x2F;&#x2F; 是否开启 cssSourceMap</span><br><span class="line">    cssSourceMap: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>其实更多的还是webpack的配置,以后有时间我会专门写一下webpack的博客</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Html5中的webApp适配</title>
    <url>/2018/02/14/53-Html5-webApp%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>适配一直都是前端比较重视的问题，今天主要是记录一下自己的学习过程</p>
</blockquote>
<a id="more"></a>

<p>之前总结过vue-cli中的适配问题，今天记录一下在html5中怎么使用</p>
<p>我们同样用到lib-flexible，可以<a href="https://codeload.github.com/amfe/lib-flexible/zip/master" target="_blank" rel="noopener">点击这里</a>下载相关文件。</p>
<p>在build文件夹中找到 flexible.css 和 flexible.js 导入进来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;flexible.css&quot; &#x2F;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;js&#x2F;flexible.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以直接使用阿里CDN：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;g.tbcdn.cn&#x2F;mtb&#x2F;lib-flexible&#x2F;&#123;&#123;version&#125;&#125;&#x2F;??flexible_css.js,flexible.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这样就可以了使用lib-flexible，接下来就是如何换算px了，我的IDE用的是Hbuilder的，现在就简单的说一下怎么进行换算</p>
<p>一般是为某个项目单独设置的，我们找到项目，右键点击属性，打开代码助手设置，选中 启用px转rem提示，填写合适的 px转rem比例 和 rem小数点部分保留长度， 保存配置，记得勾选最上面的启用项目特定的配置。</p>
<p>好了，以上就是我对Html5的适配的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>前端适配</category>
      </categories>
      <tags>
        <tag>前端适配</tag>
      </tags>
  </entry>
  <entry>
    <title>在vue-cli中的webApp适配</title>
    <url>/2018/02/05/52-vue-cli%E7%9A%84webApp%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>适配一直都是前端比较重视的问题，今天主要是记录一下自己的学习过程，适配之前先初始化样式，我用的是Amaze UI的那一套，这个看个人喜好</p>
</blockquote>
<a id="more"></a>

<p>使用Flexible实现H5页面的终端适配，先给大家一个连接，写的很详细  <a href="https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">点我!!点我!!</a></p>
<p>由于我的项目是用vue来搭建的，就先说一下在vue中如何使用吧</p>
<p>实现的原理我就不说了，由于我理解的也不是很深入，就不误人子弟，小伙伴们自己看看上面的文档吧</p>
<blockquote>
<p>首先在你的项目中导入 Flexible</p>
</blockquote>
<p>npm i lib-flexible –save</p>
<blockquote>
<p>之后在 main.js的页面导入</p>
</blockquote>
<p>import ‘lib-flexible’</p>
<blockquote>
<p>实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。<br>将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader</p>
</blockquote>
<p>npm install px2rem-loader</p>
<p>在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。</p>
<p>我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cssLoader = &#123;</span><br><span class="line">  loader: <span class="string">'css-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    minimize: process.env.NODE_ENV === <span class="string">'production'</span>,</span><br><span class="line">    sourceMap: options.sourceMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> px2remLoader = &#123;</span><br><span class="line">  loader: <span class="string">'px2rem-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    remUnit: <span class="number">75</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并放进 loaders 数组中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loaders = options.usePostCSS ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (loader) &#123;</span><br><span class="line">  loaders.push(&#123;</span><br><span class="line">    loader: loader + <span class="string">'-loader'</span>,</span><br><span class="line">    options: <span class="built_in">Object</span>.assign(&#123;&#125;, loaderOptions, &#123;</span><br><span class="line">      sourceMap: options.sourceMap</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.selector &#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 64px; &#x2F;*px*&#x2F;</span><br><span class="line">    font-size: 28px; &#x2F;*px*&#x2F;</span><br><span class="line">    border: 1px solid #ddd; &#x2F;*no*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的&#x2F;no&#x2F;和&#x2F;px&#x2F; 标识 不需要变成rem的一定要加上 这样最终不会把px变成rem px2rem处理之后将会变成：</span><br><span class="line">.selector &#123;</span><br><span class="line">    width: 2rem;</span><br><span class="line">    border: 1px solid #ddd;</span><br><span class="line">&#125;</span><br><span class="line">[data-dpr&#x3D;&quot;1&quot;] .selector &#123;</span><br><span class="line">    height: 32px;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">[data-dpr&#x3D;&quot;2&quot;] .selector &#123;</span><br><span class="line">    height: 64px;</span><br><span class="line">    font-size: 28px;</span><br><span class="line">&#125;</span><br><span class="line">[data-dpr&#x3D;&quot;3&quot;] .selector &#123;</span><br><span class="line">    height: 96px;</span><br><span class="line">    font-size: 42px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p>font-size:26px /<em>no</em>/ px不转成rem<br>font-size:26px /<em>px</em>/ px根据设备转化<br>font-size:26px px转成rem</p>
<p>好了，以上就是我对vue-cli的适配的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>前端适配</category>
      </categories>
      <tags>
        <tag>前端适配</tag>
      </tags>
  </entry>
  <entry>
    <title>前端的兼容解决方案</title>
    <url>/2018/02/23/54-%E5%89%8D%E7%AB%AF%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>兼容一直都是前端比较重视的问题，今天主要是记录一下自己的学习过程</p>
</blockquote>
<a id="more"></a>

<p>兼容性我用的是Autoprefixer这个插件，Autoprefixer是一个后处理程序，你可以同Sass，Stylus或LESS等预处理器共通使用。它适用于普通的CSS，而你无需关心要为哪些浏览器加前缀，只需使用W3C最新的规范关注于实现。</p>
<p>我的IDE用的是HBuilder 一款适合新手的Html5开发环境，接下来说一下怎么将Autoprefixer 装在HBuilder中</p>
<h2 id="配置autoprefixer"><a href="#配置autoprefixer" class="headerlink" title="配置autoprefixer"></a>配置autoprefixer</h2><p>首先在命令行中输入  npm install autoprefixer -g</p>
<p>Autoprefixer其实是postcss的插件 ，所以也要安装postcss-cli<br>npm install postcss-cli -g</p>
<p>打开HBuilder，运行-外部工具-外部工具配置</p>
<p>名称填写  autoprefixer（这个随意）</p>
<p>要执行的命令或文件填写npm安装目录  D:\Program Files\nodejs\node_global\postcss.cmd  这个目录是看自己安装在哪里</p>
<p>工作目录填写  ${project_loc}</p>
<p>参数填写  -u autoprefixer -o ${resource_loc} ${resource_loc}</p>
<p>配置完后应用，运行。</p>
<h2 id="使用autoprefixer"><a href="#使用autoprefixer" class="headerlink" title="使用autoprefixer"></a>使用autoprefixer</h2><p>点击你的css、sass文件，然后右键，依次点击外部工具-autoprefixer（此处为你新建外部工具的名称）等待编译，编译完毕即可</p>
<h2 id="创建快捷方式"><a href="#创建快捷方式" class="headerlink" title="创建快捷方式"></a>创建快捷方式</h2><p>工具-选项-常规-快捷键，搜索autoprefixer（此处为你新建外部工具的名称），设置快捷键即可</p>
<p>好了，以上就是我对兼容性解决的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>兼容</category>
      </categories>
      <tags>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title>关于CSS的一些事(一)</title>
    <url>/2018/02/24/55-%E5%85%B3%E4%BA%8ECSS%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>今天来聊一聊CSS</p>
</blockquote>
<a id="more"></a>

<p>我的博客始终没有讲到css,不是因为它不重要,而是太杂了,知识点零碎的太多了,今天说一些容易混淆的知识点</p>
<h3 id="display-none-和-visibility-hidden的区别？"><a href="#display-none-和-visibility-hidden的区别？" class="headerlink" title="display:none 和 visibility:hidden的区别？"></a>display:none 和 visibility:hidden的区别？</h3><p>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</p>
<p>visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>
<p>需要注意一点,绑定元素监听的时候,display:none是可以监听到的,在vue中,v-show就是动态切换display属性,所以需要监听的元素不要使用v-if</p>
<h3 id="CSS中-link-和-import-的区别是？"><a href="#CSS中-link-和-import-的区别是？" class="headerlink" title="CSS中 link 和@import 的区别是？"></a>CSS中 link 和@import 的区别是？</h3><ol>
<li>link属于HTML标签，而@import是CSS提供的; </li>
<li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</li>
<li>import只在IE5以上才能识别，而link是HTML标签，无兼容问题; </li>
<li>link方式的样式的权重 高于@import的权重.</li>
</ol>
<h3 id="position-absolute和float属性的异同"><a href="#position-absolute和float属性的异同" class="headerlink" title="position:absolute和float属性的异同"></a>position:absolute和float属性的异同</h3><p>A：共同点：<br>对内联元素设置<code>float</code>和<code>absolute</code>属性，可以让元素脱离文档流，并且可以设置其宽高。</p>
<p>B：不同点：<br>float仍会占据位置，position会覆盖文档流中的其他元素。</p>
<h3 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h3><p>box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。</p>
<p>content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高</p>
<p>border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content</p>
<p>标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。</p>
<h3 id="CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？"><a href="#CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？" class="headerlink" title="CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？"></a>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h3><ol>
<li>id选择器（ # myid）</li>
<li>类选择器（.myclassname）</li>
<li>标签选择器（div, h1, p）</li>
<li>相邻选择器（h1 + p）</li>
<li>子选择器（ul &gt; li）</li>
<li>后代选择器（li a）</li>
<li>通配符选择器（ * ）</li>
<li>属性选择器（a[rel = “external”]）</li>
<li>伪类选择器（a: hover, li:nth-child）</li>
</ol>
<blockquote>
<p>哪些属性可以继承</p>
</blockquote>
<ul>
<li><p>可继承的样式： font-size font-family color, text-indent;</p>
</li>
<li><p>不可继承的样式：border padding margin width height ;</p>
</li>
<li><p>优先级就近原则，同权重情况下样式定义最近者为准;</p>
</li>
<li><p>载入样式以最后载入的定位为准;</p>
</li>
</ul>
<blockquote>
<p>优先级</p>
</blockquote>
<p>!important &gt; 内联 &gt; id &gt; class &gt; tag  </p>
<blockquote>
<p>CSS3新增伪类举例</p>
</blockquote>
<ul>
<li>p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。</li>
<li>p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。</li>
<li>p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。</li>
<li>p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。</li>
<li>p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。</li>
<li>:enabled  :disabled 控制表单控件的禁用状态。</li>
<li>:checked        单选框或复选框被选中。</li>
</ul>
<h3 id="inline-block对齐问题"><a href="#inline-block对齐问题" class="headerlink" title="inline-block对齐问题"></a>inline-block对齐问题</h3><p>出现这个问题的原因归根结底就是inline-block的特性，两个inline-block之间的布局类似两个行内元素，但是可以设置width，height，上下margin。。。<br>类似行内元素布局，两个inline-block元素并排时，没有写明vertical-align时，默认是以baseline对齐的，<br>而inlineblock元素的baseline在哪里就要分有文字和没文字的情况，没有文字的情况baseline就是“margin-bottom的那条线”<br>有文字的情况baseline就是“最后一行文本的baseline”</p>
<h3 id="父子元素顶部重合"><a href="#父子元素顶部重合" class="headerlink" title="父子元素顶部重合"></a>父子元素顶部重合</h3><p>不知道大家有没有试过,子元素写<code>margin-top:100px;</code>,父级元素却下移了</p>
<p>当父元素没有设置padding值以及border值时，出现了一个bug–父元素的上方与子元素的上方完全重合在了一起，无法分开。所以才会导致上述这种父元素和子元素同时向下的情况。</p>
<p>对于这种问题解决方法有下面几种：</p>
<ul>
<li>给父元素添加padding-top值</li>
<li>给父元素添加border值</li>
<li>给父元素添加属性overflow:hidden;</li>
<li>给父元素或者子元素声明浮动float</li>
<li>使父元素或子元素声明为绝对定位：position:absolute;</li>
<li>给父元素添加属性 overflow:auto; positon:relative；</li>
</ul>
<h3 id="CSS3有哪些新特性"><a href="#CSS3有哪些新特性" class="headerlink" title="CSS3有哪些新特性"></a>CSS3有哪些新特性</h3><p>CSS3实现圆角（border-radius），阴影（box-shadow），<br>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）<br>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜<br>增加了更多的CSS选择器  多背景 rgba<br>在CSS3中唯一引入的伪元素是::selection.<br>媒体查询，多栏布局<br>border-image</p>
<h3 id="BFC规范"><a href="#BFC规范" class="headerlink" title="BFC规范"></a>BFC规范</h3><p>BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。<br>在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。<br>（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。）</p>
<h3 id="css中常见的兼容性问题"><a href="#css中常见的兼容性问题" class="headerlink" title="css中常见的兼容性问题"></a>css中常见的兼容性问题</h3><ul>
<li><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</p>
</li>
<li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>
</li>
<li><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 </p>
</li>
<li><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）<br><code>#box{ float:left; width:10px; margin:0 0 0 100px;}</code></p>
<p>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入<code>_display:inline;</code>将其转化为行内属性。(_这个符号只有ie6会识别)</p>
</li>
<li><p>渐进识别的方式，从总体中逐渐排除局部。 </p>
<p>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bb&#123;</span><br><span class="line">  background-color:#f1ee18;&#x2F;*所有识别*&#x2F;</span><br><span class="line">  .background-color:#00deff\9; &#x2F;*IE6、7、8识别*&#x2F;</span><br><span class="line">  +background-color:#a200ff;&#x2F;*IE6、7识别*&#x2F;</span><br><span class="line">  _background-color:#1e0bd1;&#x2F;*IE6识别*&#x2F; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>IE下,可以使用获取常规属性的方法来获取自定义属性,<br>也可以使用getAttribute()获取自定义属性;<br>Firefox下,只能使用getAttribute()获取自定义属性.<br>解决方法:统一通过getAttribute()获取自定义属性.</p>
</li>
<li><p>IE下,event对象有x,y属性,但是没有pageX,pageY属性;<br>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.</p>
</li>
<li><p>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p>
</li>
<li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,<br>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</p>
</li>
<li><p>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:<br>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</p>
</li>
<li><p>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用<a href="http://www.w3.org/TR/html5/single-page.html" target="_blank" rel="noopener">html5</a>推荐的写法：<code>&lt;doctype html&gt;</code></p>
</li>
<li><p>上下margin重合问题<br>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p>
</li>
<li><p>ie6对png图片格式支持不好(引用一段脚本处理)</p>
</li>
</ul>
<h3 id="CSS3画图形"><a href="#CSS3画图形" class="headerlink" title="CSS3画图形"></a>CSS3画图形</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;!-- css3画三角形 --&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;sanjiao&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!-- 画对话框 --&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;duihua&quot;&gt;你好啊&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!-- 画菱形 --&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;lingxing&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!-- 画平行四边形 --&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;pingxing&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!-- 画五角星 --&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;star&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!-- 鸡蛋 --&gt;</span><br><span class="line">  &lt;div class&#x3D;&#39;egg&#39;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 三角形</span><br><span class="line">  .sanjiao &#123;</span><br><span class="line">    border-top: 50px solid transparent;</span><br><span class="line">    border-bottom: 50px solid transparent;</span><br><span class="line">    border-left: 0px solid yellow;</span><br><span class="line">    border-right: 50px solid blue;</span><br><span class="line">    height: 0px;</span><br><span class="line">    width: 0px;</span><br><span class="line">    margin: 50px auto;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 对话框</span><br><span class="line">  .duihua &#123;</span><br><span class="line">    width:300px;</span><br><span class="line">    height:36px;</span><br><span class="line">    line-height: 36px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    background-color: #a60;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    color:#fff;</span><br><span class="line">    margin: 50px auto;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  .duihua::before &#123;</span><br><span class="line">    content: &#39;&#39;;</span><br><span class="line">    border-top: 10px solid transparent;</span><br><span class="line">    border-bottom: 10px solid transparent;</span><br><span class="line">    border-left: 0px solid #a60;</span><br><span class="line">    border-right: 10px solid #a60;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left:-10px;</span><br><span class="line">    top:8px;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 菱形</span><br><span class="line">  .lingxing &#123;</span><br><span class="line">    width:100px;</span><br><span class="line">    height:100px;</span><br><span class="line">    background-color: orangered;</span><br><span class="line">    margin: 50px auto;</span><br><span class="line">    transform: rotate(45deg)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 平行四边形</span><br><span class="line">  .pingxing &#123;</span><br><span class="line">    width:150px;</span><br><span class="line">    height:100px;</span><br><span class="line">    background-color: firebrick;</span><br><span class="line">    margin: 50px auto;</span><br><span class="line">    &#x2F;&#x2F; 第一个是X轴倾斜的角度，第二个是Y轴倾斜的角度</span><br><span class="line">    transform: skew(20deg,20deg)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 五角星</span><br><span class="line">  .star &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    border-top: 0px solid transparent;</span><br><span class="line">    border-bottom: 70px solid red;</span><br><span class="line">    border-left: 100px solid transparent;</span><br><span class="line">    border-right: 100px solid transparent;</span><br><span class="line">    height: 0px;</span><br><span class="line">    width: 0px;</span><br><span class="line">    margin: 50px auto;</span><br><span class="line">    transform: rotate(35deg)</span><br><span class="line">  &#125;</span><br><span class="line">  .star::before &#123;</span><br><span class="line">    content: &#39;&#39;;</span><br><span class="line">    border-top: 0px solid transparent;</span><br><span class="line">    border-bottom: 80px solid red;</span><br><span class="line">    border-left: 30px solid transparent;</span><br><span class="line">    border-right: 30px solid transparent;</span><br><span class="line">    height: 0px;</span><br><span class="line">    width: 0px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: -45px;</span><br><span class="line">    left: -65px;</span><br><span class="line">    transform: rotate(-35deg)</span><br><span class="line">  &#125;</span><br><span class="line">  .star::after &#123;</span><br><span class="line">    content: &#39;&#39;;</span><br><span class="line">    border-top: 0px solid transparent;</span><br><span class="line">    border-bottom: 70px solid red;</span><br><span class="line">    border-left: 100px solid transparent;</span><br><span class="line">    border-right: 100px solid transparent;</span><br><span class="line">    height: 0px;</span><br><span class="line">    width: 0px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 3px;</span><br><span class="line">    left: -105px;</span><br><span class="line">    transform: rotate(-70deg)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 鸡蛋</span><br><span class="line">  .egg &#123;</span><br><span class="line">    width: 126px;</span><br><span class="line">    height: 180px;</span><br><span class="line">    background-color: #fa3;</span><br><span class="line">    &#x2F;&#x2F; 斜杠之前的是设置X轴的，后面是设置Y轴的</span><br><span class="line">    border-radius: 50% 50% 50% 50% &#x2F; 60% 60% 40% 40%;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>axios封装</title>
    <url>/2018/02/25/56-axios%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>vue中也推荐使用axios来调数据</p>
</blockquote>
<a id="more"></a>

<p>新建一个axios.js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 配置axios拦截器 *&#x2F;</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">import router from &#39;@&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建axios实例</span><br><span class="line">const service &#x3D; axios.create(&#123;</span><br><span class="line">  &#x2F;&#x2F;baseURL: process.env.BASE_API, &#x2F;&#x2F; api的base_url</span><br><span class="line">  timeout: 60000 &#x2F;&#x2F; 请求超时时间</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; request拦截器</span><br><span class="line">service.interceptors.request.use(config &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 假如有Tn,就加入</span><br><span class="line">  if (getToken()) &#123;</span><br><span class="line">    config.headers[&#39;tn&#39;] &#x3D; getToken() &#x2F;&#x2F; 让每个请求携带token--[&#39;X-Token&#39;]为自定义key 请根据实际情况自行修改</span><br><span class="line">  &#125;</span><br><span class="line">  return config</span><br><span class="line">&#125;, error &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Do something with request error</span><br><span class="line">  &#x2F;&#x2F;console.log(error) &#x2F;&#x2F; for debug</span><br><span class="line">  Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; respone拦截器</span><br><span class="line">service.interceptors.response.use(response &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 下面的注释为通过response自定义code来标示请求状态，当code返回如下情况为权限有问题，登出并返回到登录页</span><br><span class="line">   * 如通过xmlhttprequest 状态码标识 逻辑可写在下面error中</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  return response</span><br><span class="line">&#125;, error &#x3D;&gt; &#123;	</span><br><span class="line">	var errorObj &#x3D; &#123;</span><br><span class="line">		message: &#39;c1000&#39;,</span><br><span class="line">		data: []</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if (error &amp;&amp; error.response) &#123;</span><br><span class="line">		switch (error.response.status) &#123;</span><br><span class="line">			case 400: errorObj.message &#x3D; &#39;(c1400)&#39; ; break; &#x2F;&#x2F; 请求错误</span><br><span class="line">			case 401: errorObj.message &#x3D; &#39;(c1401)&#39;; break; &#x2F;&#x2F; 未授权</span><br><span class="line">			case 403: errorObj.message &#x3D; &#39;(c1403)&#39;; break; &#x2F;&#x2F; 拒绝访问</span><br><span class="line">			case 404: errorObj.message &#x3D; &#39;(c1404)&#39;; break; &#x2F;&#x2F; 请求出错</span><br><span class="line">			case 408: errorObj.message &#x3D; &#39;(c1408)&#39;; break; &#x2F;&#x2F; 请求超时</span><br><span class="line">			case 500: errorObj.message &#x3D; &#39;(c1500)&#39;; break; &#x2F;&#x2F; 服务器错误</span><br><span class="line">			case 501: errorObj.message &#x3D; &#39;(c1501)&#39;; break; &#x2F;&#x2F; 服务未实现</span><br><span class="line">			case 502: errorObj.message &#x3D; &#39;(c1502)&#39;; break; &#x2F;&#x2F; 网络错误</span><br><span class="line">			case 503: errorObj.message &#x3D; &#39;(c1503)&#39;; break; &#x2F;&#x2F; 服务不可用</span><br><span class="line">			case 504: errorObj.message &#x3D; &#39;(c1504)&#39;; break; &#x2F;&#x2F; 网络超时</span><br><span class="line">			case 505: errorObj.message &#x3D; &#39;(c1505)&#39;; break; &#x2F;&#x2F; HTTP版本不受支持</span><br><span class="line">			default: errorObj.message &#x3D; &#96;连接出错($&#123;error.response.status&#125;)!&#96;;  &#x2F;&#x2F; 连接出错</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		errorObj.message &#x3D; &#39;(c3289)&#39;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Notice.error(&#123;</span><br><span class="line">		title: &#39;网络繁忙,请稍后再试&#39; + errorObj.message,</span><br><span class="line">		duration: 5</span><br><span class="line">	&#125;);</span><br><span class="line">  &#x2F;&#x2F; Do something with request error</span><br><span class="line">  &#x2F;&#x2F;console.log(error) &#x2F;&#x2F; for debug</span><br><span class="line">  Promise.reject(error)</span><br><span class="line">	return errorObj</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default service</span><br></pre></td></tr></table></figure>

<p>在 store 中 新建一个 request.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 请求后台接口数据模块*&#x2F;</span><br><span class="line">import request from &#39;@&#x2F;util&#x2F;axios&#39;</span><br><span class="line"></span><br><span class="line">var state &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">var mutations &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">var getters &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">var actions &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; action只接受一个参数,所以url与请求参数需要放在一个对象里面</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;post请求</span><br><span class="line">  Post(&#123; commit, state &#125;,obj)&#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      request(&#123;</span><br><span class="line">        url: obj.url,</span><br><span class="line">        method: &#39;post&#39;,</span><br><span class="line">        data: obj.PostData</span><br><span class="line">      &#125;).then(response &#x3D;&gt; &#123;</span><br><span class="line">        resolve(response.data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;get请求</span><br><span class="line">  Get(&#123; commit, state &#125;,obj)&#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      request(&#123;</span><br><span class="line">        url: obj.url,</span><br><span class="line">        method: &#39;get&#39;,</span><br><span class="line">        params: obj.PostData,</span><br><span class="line">      &#125;).then(response &#x3D;&gt; &#123;</span><br><span class="line">        resolve(response.data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将这些对象引入后导出到总的状态管理当中</span><br><span class="line">export default &#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  getters,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候直接派发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sendMessage &#x3D; &#123;</span><br><span class="line">  url: this.$api.List,</span><br><span class="line">  PostData: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line">this.$store.dispatch(&#39;Post&#39;, sendMessage).then((data) &#x3D;&gt; &#123;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能遇到的问题</p>
</blockquote>
<p>发送的数据后端收不到…</p>
<p>解决方案引入qs库</p>
<p><code>npm install qs --save</code></p>
<p>在main.js中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import qs from &#39;qs&#39;</span><br><span class="line">&#x2F;* 注入vue全局中，这样我们可以在组件内或者JS内通过使用this.$qs来使用qs库*&#x2F;</span><br><span class="line">Vue.prototype.$qs &#x3D; qs</span><br></pre></td></tr></table></figure>

<p>使用的时候,用qs包裹住参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$qs.stringify(data)</span><br></pre></td></tr></table></figure>

<p>问题解决了,我们来看一下是为什么</p>
<p>在之前公司做项目时，也是用axios发送的数据，且并未修改过什么东西，但是为什么现在后端接收不到我们的json类型的参数呢？</p>
<p>通过翻看axios的文档得知：在axios使用Post发送数据时，默认是直接把json放到请求体中提交到后端的，而后端获取数据的方式有两种，一种是@RequestParam（通过字符串中解析出参数）,另一种是@ResponseBody（从请求体中取参数），很显然，后端用了第一种方式。</p>
<p>那么，既然知道了原因，兄弟们，懒得改前端代码的话，就怼回去吧( ‵▽′)ψ</p>
]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中的按需加载和懒加载</title>
    <url>/2018/02/26/57-vue%E4%B8%AD%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>vue打包之后,经常首页白屏时间过长,这时候就需要使用按需加载和懒加载了</p>
</blockquote>
<a id="more"></a>

<h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>直接说一下官方推荐</p>
<p>vue官方的一种方法，import()方法和增加webpackChunkName。</p>
<ol>
<li>需要安装 cnpm i -s @babel/plugin-syntax-dynamic-import</li>
<li>配置webpack，在webpack-base-conf.js的output加入chunkFilename: ‘[name].js’</li>
</ol>
<blockquote>
<p>按需加载 + js打包分离,这样做的好处,每个组件单独打包，加载的时候文件不会太大。webpackChunkName中的名称一样,就打包在同一个文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">     &#123;</span><br><span class="line">       path: &#39;&#x2F;&#39;,</span><br><span class="line">       name: &#39;HelloWorld&#39;,</span><br><span class="line">       component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;HelloWorld&quot; *&#x2F; &#39;@&#x2F;components&#x2F;HelloWorld&#39;)</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果觉得麻烦,不想装插件</p>
<p><code>component: resolve =&gt; require([&#39;@/components/HelloWorld&#39;], resolve),</code> 也是可以的</p>
<h3 id="组件懒加载"><a href="#组件懒加载" class="headerlink" title="组件懒加载"></a>组件懒加载</h3><p>组件懒加载其实用法和路由是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  historyTab:resolve &#x3D;&gt; &#123;</span><br><span class="line">    require([&#39;@&#x2F;components&#x2F;Tab.vue&#39;],resolve)</span><br><span class="line">  &#125;,   </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="UI组件库按需加载"><a href="#UI组件库按需加载" class="headerlink" title="UI组件库按需加载"></a>UI组件库按需加载</h3><p>引入的第三方库过于庞大,也是导致首页白屏的很大原因</p>
<p>我们可以对组件库进行按需加载,我常用的就是element和iview,说一下这两个吧,其实官网也都有说的</p>
<h4 id="element"><a href="#element" class="headerlink" title="element"></a>element</h4><p><code>npm install babel-plugin-component –D</code></p>
<p><code>npm install babel-plugin-import --save-dev</code></p>
<p>然后配置插件，将 .babelrc修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;env&quot;, &#123;</span><br><span class="line">      &quot;modules&quot;: false,</span><br><span class="line">      &quot;targets&quot;: &#123;</span><br><span class="line">        &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;&#x3D; 8&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;,</span><br><span class="line">		[</span><br><span class="line">      &quot;component&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;libraryName&quot;: &quot;element-ui&quot;,</span><br><span class="line">        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要那些就在main.js中引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按需加载</span><br><span class="line">import &#123; Table, TableColumn, Button&#125; from &#39;element-ui&#39;;</span><br><span class="line">Vue.use(Table)</span><br><span class="line">Vue.use(TableColumn)</span><br><span class="line">Vue.use(Button)</span><br></pre></td></tr></table></figure>


<h4 id="iview"><a href="#iview" class="headerlink" title="iview"></a>iview</h4><p>其实道理都一样</p>
<p><code>npm install babel-plugin-import --save-dev</code></p>
<p>然后修改.babelrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [[&quot;import&quot;, &#123;</span><br><span class="line">    &quot;libraryName&quot;: &quot;iview&quot;,</span><br><span class="line">    &quot;libraryDirectory&quot;: &quot;src&#x2F;components&quot;</span><br><span class="line">  &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用也是一样的,就不说了</p>
<blockquote>
<p>可能每个版本的vue-cli的.babelrc初始配置不一样,照着改就好了,多试几次</p>
</blockquote>
<p>以上就是我对Vue按需加载的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex模块化封装</title>
    <url>/2018/02/27/58-vuex%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>之前已经写过vuex的相关知识了,模块化操作也说了一点,但是感觉过于的繁琐,于是学着electron-vue那样封装了一层</p>
</blockquote>
<a id="more"></a>

<p>之前的模块化封装,每一个文件,都要在index中写一次导入,太过于麻烦,于是封装了一下</p>
<p>首先在根目录下创建一个story,里面的结构是这样的</p>
<p>story<br>  |–modules<br>      |–index.js<br>  |–index.js</p>
<p>最外面的index.js内容: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">import modules from &#39;.&#x2F;modules&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  modules</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样会默认导入modules中的index.js</p>
<p>重点就在里层的index.js了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The file enables &#96;@&#x2F;store&#x2F;index.js&#96; to import all vuex modules</span><br><span class="line"> * in a one-shot manner. There should not be any reason to edit this file.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">const files &#x3D; require.context(&#39;.&#39;, false, &#x2F;\.js$&#x2F;)</span><br><span class="line">const modules &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">files.keys().forEach(key &#x3D;&gt; &#123;</span><br><span class="line">  if (key &#x3D;&#x3D;&#x3D; &#39;.&#x2F;index.js&#39;) return</span><br><span class="line">  modules[key.replace(&#x2F;(\.\&#x2F;|\.js)&#x2F;g, &#39;&#39;)] &#x3D; files(key).default</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default modules</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这么写,他会默认去找所有路径底下除了index.js的其他js文件,然后将名字作为文件名输出出来,就不用我们一个个写了</p>
</blockquote>
<p>使用的时候就在modules文件中新建一个.js,然后正常使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var state &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">var mutations &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">var getters &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">var actions &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将这些对象引入后导出到总的状态管理当中</span><br><span class="line">export default &#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  getters,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上就是我对vuex模块化封装的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Html5常用的meta标签总结</title>
    <url>/2018/03/02/59-html5%E5%B8%B8%E7%94%A8%E7%9A%84meta%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>移动前端开发中添加一些webkit专属的HTML5头部标签，帮助浏览器更好解析HTML代码，更好地将移动web前端页面表现出来。本文整理一些常用的meta标签。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;zh-cmn-Hans&quot;&gt; &lt;!-- 更加标准的 lang 属性写法 http:&#x2F;&#x2F;zhi.hu&#x2F;XyIa --&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;!-- 声明文档使用的字符编码 --&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&#39;utf-8&#39;&gt;</span><br><span class="line">    &lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 页面描述 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;不超过150个字符&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 页面关键词 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 网页作者 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;author&quot; content&#x3D;&quot;name, email@gmail.com&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 搜索引擎抓取 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;index,follow&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 为移动设备添加 viewport --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;initial-scale&#x3D;1, maximum-scale&#x3D;3, minimum-scale&#x3D;1, user-scalable&#x3D;no&quot;&gt;</span><br><span class="line">    &lt;!-- &#96;width&#x3D;device-width&#96; 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http:&#x2F;&#x2F;bigc.at&#x2F;ios-webapp-viewport-meta.orz --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- iOS 设备 begin --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;apple-mobile-web-app-title&quot; content&#x3D;&quot;标题&quot;&gt;</span><br><span class="line">    &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta name&#x3D;&quot;apple-itunes-app&quot; content&#x3D;&quot;app-id&#x3D;myAppStoreID, affiliate-data&#x3D;myAffiliateData, app-argument&#x3D;myURL&quot;&gt;</span><br><span class="line">    &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;black&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 设置苹果工具栏颜色 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telphone&#x3D;no, email&#x3D;no&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;</span><br><span class="line">    &lt;!-- 启用360浏览器的极速模式(webkit) --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;renderer&quot; content&#x3D;&quot;webkit&quot;&gt;</span><br><span class="line">    &lt;!-- 避免IE使用兼容模式 --&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;!-- 不让百度转码 --&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;Cache-Control&quot; content&#x3D;&quot;no-siteapp&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;HandheldFriendly&quot; content&#x3D;&quot;true&quot;&gt;</span><br><span class="line">    &lt;!-- 微软的老式浏览器 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;MobileOptimized&quot; content&#x3D;&quot;320&quot;&gt;</span><br><span class="line">    &lt;!-- uc强制竖屏 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;screen-orientation&quot; content&#x3D;&quot;portrait&quot;&gt;</span><br><span class="line">    &lt;!-- QQ强制竖屏 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;x5-orientation&quot; content&#x3D;&quot;portrait&quot;&gt;</span><br><span class="line">    &lt;!-- UC强制全屏 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;full-screen&quot; content&#x3D;&quot;yes&quot;&gt;</span><br><span class="line">    &lt;!-- QQ强制全屏 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;x5-fullscreen&quot; content&#x3D;&quot;true&quot;&gt;</span><br><span class="line">    &lt;!-- UC应用模式 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;browsermode&quot; content&#x3D;&quot;application&quot;&gt;</span><br><span class="line">    &lt;!-- QQ应用模式 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;x5-page-mode&quot; content&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- windows phone 点击无高光 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;msapplication-tap-highlight&quot; content&#x3D;&quot;no&quot;&gt;</span><br><span class="line">    &lt;!-- iOS 图标 begin --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;apple-touch-icon-precomposed&quot; href&#x3D;&quot;&#x2F;apple-touch-icon-57x57-precomposed.png&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;apple-touch-icon-precomposed&quot; sizes&#x3D;&quot;114x114&quot; href&#x3D;&quot;&#x2F;apple-touch-icon-114x114-precomposed.png&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;apple-touch-icon-precomposed&quot; sizes&#x3D;&quot;144x144&quot; href&#x3D;&quot;&#x2F;apple-touch-icon-144x144-precomposed.png&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;</span><br><span class="line">    &lt;!-- iOS 图标 end --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- iOS 启动画面 begin --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;apple-touch-startup-image&quot; sizes&#x3D;&quot;768x1004&quot; href&#x3D;&quot;&#x2F;splash-screen-768x1004.png&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;apple-touch-startup-image&quot; sizes&#x3D;&quot;1536x2008&quot; href&#x3D;&quot;&#x2F;splash-screen-1536x2008.png&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;apple-touch-startup-image&quot; sizes&#x3D;&quot;1024x748&quot; href&#x3D;&quot;&#x2F;Default-Portrait-1024x748.png&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;apple-touch-startup-image&quot; sizes&#x3D;&quot;2048x1496&quot; href&#x3D;&quot;&#x2F;splash-screen-2048x1496.png&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- iPad 横屏 2048x1496（Retina） --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link rel&#x3D;&quot;apple-touch-startup-image&quot; href&#x3D;&quot;&#x2F;splash-screen-320x480.png&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- iPhone&#x2F;iPod Touch 竖屏 320x480 (标准分辨率) --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;apple-touch-startup-image&quot; sizes&#x3D;&quot;640x960&quot; href&#x3D;&quot;&#x2F;splash-screen-640x960.png&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- iPhone&#x2F;iPod Touch 竖屏 640x960 (Retina) --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;apple-touch-startup-image&quot; sizes&#x3D;&quot;640x1136&quot; href&#x3D;&quot;&#x2F;splash-screen-640x1136.png&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- iPhone 5&#x2F;iPod Touch 5 竖屏 640x1136 (Retina) --&gt;</span><br><span class="line">    &lt;!-- iOS 启动画面 end --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- iOS 设备 end --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;msapplication-TileColor&quot; content&#x3D;&quot;#000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- Windows 8 磁贴颜色 --&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;msapplication-TileImage&quot; content&#x3D;&quot;icon.png&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- Windows 8 磁贴图标 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link rel&#x3D;&quot;alternate&quot; type&#x3D;&quot;application&#x2F;rss+xml&quot; title&#x3D;&quot;RSS&quot; href&#x3D;&quot;&#x2F;rss.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 添加 RSS 订阅 --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;shortcut icon&quot; type&#x3D;&quot;image&#x2F;ico&quot; href&#x3D;&quot;&#x2F;favicon.ico&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 添加 favicon icon --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- sns 社交标签 begin --&gt;</span><br><span class="line">    &lt;!-- 参考微博API --&gt;</span><br><span class="line">    &lt;meta property&#x3D;&quot;og:type&quot; content&#x3D;&quot;类型&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta property&#x3D;&quot;og:url&quot; content&#x3D;&quot;URL地址&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta property&#x3D;&quot;og:title&quot; content&#x3D;&quot;标题&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta property&#x3D;&quot;og:image&quot; content&#x3D;&quot;图片&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta property&#x3D;&quot;og:description&quot; content&#x3D;&quot;描述&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- sns 社交标签 end --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;标题&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>

<p>meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文；</p>
<p>meta标签的charset的信息参数如BIG5时，代表说明网站是采用的编码是繁体中文；</p>
<p>meta标签的charset的信息参数如iso-2022-jp时，代表说明网站是采用的编码是日文；</p>
<p>meta标签的charset的信息参数如ks_c_5601时，代表说明网站是采用的编码是韩文；</p>
<p>meta标签的charset的信息参数如ISO-8859-1时，代表说明网站是采用的编码是英文；</p>
<p>meta标签的charset的信息参数如UTF-8时，代表世界通用的语言编码；</p>
<p>好了，以上就是我对meta的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>meta</category>
      </categories>
      <tags>
        <tag>meta</tag>
      </tags>
  </entry>
  <entry>
    <title>scss/sass的使用</title>
    <url>/2018/03/12/60-scss%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>前端写样式总是一件很繁琐的事情，这时候，有人就开始为CSS加入编程元素，这被叫做”CSS预处理器”。它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>本篇参考了阮一峰老师的博客，感谢各位大神对代码的无私奉献</p>
</blockquote>
<p>css预处理器也有很多版本，之前接触过less，感觉挺好用的，但是没有继续使用它，一方面觉得有点不适应，一方面是觉得还不满足自己对预处理器的需求，直到出了scss！</p>
<h2 id="什么是scss"><a href="#什么是scss" class="headerlink" title="什么是scss"></a>什么是scss</h2><p>scss是sass3中的引入的新语法，相比较其他的，我个人更喜欢使用scss</p>
<h2 id="安装scss"><a href="#安装scss" class="headerlink" title="安装scss"></a>安装scss</h2><p>SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先<a href="http://www.ruby-lang.org/zh_cn/downloads/" target="_blank" rel="noopener">安装Ruby</a>，然后再安装SASS。</p>
<p>如果你已经安装好了Ruby，接着在命令行输入下面的命令：</p>
<blockquote>
<p>gem install sass</p>
</blockquote>
<p>这样就安装好啦</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="在html文件中使用"><a href="#在html文件中使用" class="headerlink" title="在html文件中使用"></a>在html文件中使用</h3><p>SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。</p>
<ol>
<li>下面的命令，可以在屏幕上显示.scss文件转化的css代码。要先cd到你要转化的scss的文件夹中（假设文件名为style。）</li>
</ol>
<blockquote>
<p>sass style.scss</p>
</blockquote>
<ol start="2">
<li>如果要将显示结果保存成文件，后面再跟一个.css文件名。</li>
</ol>
<blockquote>
<p>sass style.scss style.css</p>
</blockquote>
<ol start="3">
<li>SASS提供四个编译风格的选项：</li>
</ol>
<ul>
<li>nested：嵌套缩进的css代码，它是默认值。</li>
<li>expanded：没有缩进的、扩展的css代码。</li>
<li>compact：简洁格式的css代码。</li>
<li>compressed：压缩后的css代码。</li>
</ul>
<ol start="4">
<li>生产环境当中，一般使用最后一个选项:</li>
</ol>
<blockquote>
<p>sass –style compressed style.scss style.css</p>
</blockquote>
<ol start="5">
<li>可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。</li>
</ol>
<blockquote>
<p>sass –watch style.scss:style.css</p>
</blockquote>
<h3 id="vue中使用sass"><a href="#vue中使用sass" class="headerlink" title="vue中使用sass"></a>vue中使用sass</h3><p>首先先安装sass</p>
<blockquote>
<p>npm install node-sass –save-dev<br>  npm install sass-loader –save-dev</p>
</blockquote>
<p>之后在使用的时候声明一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style lang&#x3D;&quot;scss&quot;&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>语法的解释我就不按照文档的顺序来排列了，我把我个人觉的比较重要的，经常用到的，放在前面</p>
<h3 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h3><h4 id="标签支持嵌套"><a href="#标签支持嵌套" class="headerlink" title="标签支持嵌套"></a>标签支持嵌套</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">header &#123;</span><br><span class="line">  margin-top: 50px;</span><br><span class="line">  nav &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="属性也支持嵌套-但是要加"><a href="#属性也支持嵌套-但是要加" class="headerlink" title="属性也支持嵌套,但是要加:"></a>属性也支持嵌套,但是要加:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nav &#123;</span><br><span class="line">  background: &#123;</span><br><span class="line">    color: $header-color;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套代码中使用-amp"><a href="#嵌套代码中使用-amp" class="headerlink" title="嵌套代码中使用&amp;"></a>嵌套代码中使用&amp;</h3><blockquote>
<p>在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  color: aqua;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: antiquewhite;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量的用法"><a href="#变量的用法" class="headerlink" title="变量的用法"></a>变量的用法</h3><h4 id="所有变量以-开头"><a href="#所有变量以-开头" class="headerlink" title="所有变量以$开头"></a>所有变量以$开头</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$header-color: red;</span><br><span class="line">.header&#123;</span><br><span class="line">  color: $header-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串中使用变量"><a href="#字符串中使用变量" class="headerlink" title="字符串中使用变量"></a>字符串中使用变量</h4><p>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$side: left;</span><br><span class="line">.header &#123;</span><br><span class="line">  margin-#&#123;$side&#125;: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算功能"><a href="#计算功能" class="headerlink" title="计算功能"></a>计算功能</h3><p>/ 尽量把括号加上去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.hp-two-span &#123;</span><br><span class="line">  margin-#&#123;$side&#125;: (100px&#x2F;2);</span><br><span class="line">  padding-#&#123;$side&#125;: 25px + 25px;</span><br><span class="line">  padding-top: 25px * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码的重用"><a href="#代码的重用" class="headerlink" title="代码的重用"></a>代码的重用</h3><h4 id="继承-extend"><a href="#继承-extend" class="headerlink" title="继承(@extend)"></a>继承(@extend)</h4><p>这是一个非常好用的方法，假如一个类想用另一个类的样式，就可以直接继承过来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.main-title &#123;</span><br><span class="line">  background: &#123;</span><br><span class="line">    color: aquamarine;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main-text要继承main-title，就要使用@extend命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.main-text &#123;</span><br><span class="line">  @extend .main-title;</span><br><span class="line">  color: darkorange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义方法-Mixin"><a href="#定义方法-Mixin" class="headerlink" title="定义方法(Mixin)"></a>定义方法(Mixin)</h4><p>使用@mixin命令，定义一个代码块。这个代码块可以重复使用,有点类似定义一个方法,可以传入参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@mixin cart($vcolor,$vwidth) &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 25%;</span><br><span class="line">  height: 40px;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  background: &#123;</span><br><span class="line">    color: $vcolor;</span><br><span class="line">  &#125;;</span><br><span class="line">  border: $vwidth solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候要@include</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.main-ul &#123;</span><br><span class="line">  list-style: none;</span><br><span class="line">  font-size: 0;</span><br><span class="line">    li &#123;</span><br><span class="line">      font-size: 10px * 2;</span><br><span class="line">      &amp;:nth-of-type(1)&#123;</span><br><span class="line">        @include cart(yellow,2px);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 单行注释，只保留在SASS源文件中，编译后被省略。</span><br></pre></td></tr></table></figure>
<h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 标准的CSS注释,会保留到编译后的文件 *&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="重要注释"><a href="#重要注释" class="headerlink" title="重要注释"></a>重要注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*! 后面加一个感叹号，表示这是&quot;重要注释&quot;。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 *&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="导入外部样式-这个和css一样"><a href="#导入外部样式-这个和css一样" class="headerlink" title="导入外部样式,这个和css一样"></a>导入外部样式,这个和css一样</h3><p>@import “react.css”;</p>
<blockquote>
<p>一定记得加分号</p>
</blockquote>
<h3 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a>颜色函数</h3><p>SASS提供了一些内置的颜色函数，以便生成系列颜色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lighten(#cc3, 10%) &#x2F;&#x2F; #d6d65c</span><br><span class="line">darken(#cc3, 10%) &#x2F;&#x2F; #a3a329</span><br><span class="line">grayscale(#cc3) &#x2F;&#x2F; #808080</span><br><span class="line">complement(#cc3) &#x2F;&#x2F; #33c</span><br></pre></td></tr></table></figure>

<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>@if可以用来判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  @if 1 + 1 &#x3D;&#x3D; 2 &#123; border: 1px solid; &#125;</span><br><span class="line">  @if 5 &lt; 3 &#123; border: 2px dotted; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配套的还有@else命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@if lightness($color) &gt; 30% &#123;</span><br><span class="line">　　background-color: #000;</span><br><span class="line">&#125; @else &#123;</span><br><span class="line">　　background-color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@for $i from 1 to 10 &#123;</span><br><span class="line">  .border-#&#123;$i&#125; &#123;</span><br><span class="line">    border: #&#123;$i&#125;px solid blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$i: 6;</span><br><span class="line">@while $i &gt; 0 &#123;</span><br><span class="line">  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;</span><br><span class="line">  $i: $i - 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="each命令，作用与for类似"><a href="#each命令，作用与for类似" class="headerlink" title="each命令，作用与for类似"></a>each命令，作用与for类似</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@each $member in a, b, c, d &#123;</span><br><span class="line">  .#&#123;$member&#125; &#123;</span><br><span class="line">    background-image: url(&quot;&#x2F;image&#x2F;#&#123;$member&#125;.jpg&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>和之前的Mixin有点类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@function double($n) &#123;</span><br><span class="line">  @return $n * 2;</span><br><span class="line">&#125;</span><br><span class="line">#sidebar &#123;</span><br><span class="line">  width: double(5px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>差不多经常用的内容就是这些啦，还有一些零散的知识点没有用到，大家可以去SASS的官方去看看文档</p>
<p>好了，以上就是我对sass的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>scss</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 部署报错</title>
    <url>/2018/03/15/61-hexo%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>今年的1月份还一切正常,二月份的时候,当我部署当github上时,发现报错了:fatal: could not read Username for ‘GitHub’</p>
</blockquote>
<a id="more"></a>

<p>解决办法:</p>
<p>修改配置文件：</p>
<p>根目录下的_config.yml，修改deploy节点。</p>
<blockquote>
<p>原来的配置为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;yourname&#x2F;yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改为如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;yourname:yourpassword@github.com&#x2F;yourname&#x2F;yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>



<p>好了，成功,如果不行,再去找找其他的解决办法把</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>弹性布局深入</title>
    <url>/2018/08/08/62-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>因为工作原因,今天才来更新一下博客,记录一下学习的过程,弹性布局的深入..(display: flex)</p>
</blockquote>
<a id="more"></a>

<p>CSS3之前,我们对面布局是怎么设计的,图文列表并排的时候,大多数都是绝对定位,浮动布局,这不失为一个好的办法,今天来讲一下新的布局,弹性布局</p>
<h3 id="什么是Flex-布局"><a href="#什么是Flex-布局" class="headerlink" title="什么是Flex 布局"></a>什么是Flex 布局</h3><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。(任何一个容器都可以指定为 Flex 布局)</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>
<h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><blockquote>
<p>容器属性也就是父级元素中样式设置的属性</p>
</blockquote>
<h4 id="决定主轴的方向-即项目的排列方向-横或者竖"><a href="#决定主轴的方向-即项目的排列方向-横或者竖" class="headerlink" title="决定主轴的方向(即项目的排列方向,横或者竖)"></a>决定主轴的方向(即项目的排列方向,横或者竖)</h4><blockquote>
<p>flex-direction: row;</p>
</blockquote>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<h4 id="项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。"><a href="#项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。" class="headerlink" title="项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。"></a>项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</h4><blockquote>
<p>flex-wrap: wrap;</p>
</blockquote>
<ul>
<li>nowrap（默认）：不换行。</li>
<li>wrap：换行，第一行在上方。</li>
<li>wrap-reverse：换行，第一行在下方。</li>
</ul>
<h4 id="flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap。"><a href="#flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap。" class="headerlink" title="flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。"></a>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</h4><blockquote>
<p>flex-flow: row wrap;</p>
</blockquote>
<h4 id="justify-content属性定义了项目在主轴-x轴-上的对齐方式。"><a href="#justify-content属性定义了项目在主轴-x轴-上的对齐方式。" class="headerlink" title="justify-content属性定义了项目在主轴(x轴)上的对齐方式。"></a>justify-content属性定义了项目在主轴(x轴)上的对齐方式。</h4><blockquote>
<p>justify-content: space-around;</p>
</blockquote>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。*/</li>
</ul>
<h4 id="align-items属性定义项目在交叉-y轴-轴上如何对齐。-总体的布局"><a href="#align-items属性定义项目在交叉-y轴-轴上如何对齐。-总体的布局" class="headerlink" title="align-items属性定义项目在交叉(y轴)轴上如何对齐。(总体的布局)"></a>align-items属性定义项目在交叉(y轴)轴上如何对齐。(总体的布局)</h4><blockquote>
<p>align-items: center;</p>
</blockquote>
<ul>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
</ul>
<h4 id="align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。"><a href="#align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。" class="headerlink" title="align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。"></a>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</h4><blockquote>
<p>align-content: space-around;</p>
</blockquote>
<ul>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
</ul>
<h3 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h3><blockquote>
<p>项目属性也就是子级元素中样式设置的属性</p>
</blockquote>
<h4 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h4><blockquote>
<p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br>order: 0;</p>
</blockquote>
<h4 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h4><blockquote>
<p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>flex-grow: 0;</p>
</blockquote>
<h4 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h4><blockquote>
<p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>flex-shrink: 1;</p>
</blockquote>
<h4 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h4><blockquote>
<p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br>flex-basis: auto;</p>
</blockquote>
<h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><blockquote>
<p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>flex: 0 1 auto;</p>
</blockquote>
<h4 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h4><blockquote>
<p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该属性可能取6个值，除了auto，其他都与align-items属性完全一致。<br>align-self: auto;</p>
</blockquote>
<p>好了，以上就是我对弹性布局的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端跨域深入</title>
    <url>/2018/10/10/63-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>跨域想必大家都不陌生,解决的方法之前的博客也有提到,今天来一起学习一下,跨域的时候,浏览器做了哪些操作,后台的服务器能否收到前端在跨域时发出的参数</p>
</blockquote>
<a id="more"></a>

<p>跨域的原因就不在重复的描述了,今天了解一下两点,浏览器同源政策及跨域资源共享</p>
<h3 id="浏览器同源政策"><a href="#浏览器同源政策" class="headerlink" title="浏览器同源政策"></a>浏览器同源政策</h3><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>同源政策共有三种行为受到限制</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li>DOM 无法获得。</li>
<li>AJAX 请求不能发送。</li>
</ul>
<blockquote>
<p>提交表单不受同源政策的限制。</p>
</blockquote>
<p>其实很好理解的,如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<h3 id="跨域资源共享CORS（Cross-origin-resource-sharing）"><a href="#跨域资源共享CORS（Cross-origin-resource-sharing）" class="headerlink" title="跨域资源共享CORS（Cross-origin resource sharing）"></a>跨域资源共享CORS（Cross-origin resource sharing）</h3><p>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。稍后通过一些例子来具体说明</p>
<h4 id="CORS请求"><a href="#CORS请求" class="headerlink" title="CORS请求"></a>CORS请求</h4><blockquote>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
</blockquote>
<p>一丶请求方法是以下三种方法之一</p>
<ol>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ol>
<p>二丶HTTP的头信息不超出以下几种字段</p>
<ol>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ol>
<blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。</p>
</blockquote>
<h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>假设有一个post请求,是一个简单请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.post(&#123;</span><br><span class="line">  url: <span class="string">'http://127.0.0.1:3000/ceshi'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">'我是谁'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">resData</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resData);</span><br><span class="line">  &#125;,</span><br><span class="line">  error:<span class="function"><span class="keyword">function</span>(<span class="params">resData</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对应的服务端代码为(详细的代码就不贴出来了,之前的博客有)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">'/ceshi'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body)</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    code:<span class="string">'success'</span>,</span><br><span class="line">    message:<span class="string">'你好'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这时服务器并没有设置允许跨域,前端浏览器发现跨域,返回了提示,但是,后端的服务器是可以接受到前端传过来的值的</p>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>将上面的请求稍微改一下,添加一个contentType: ‘application/json’</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.post(&#123;</span><br><span class="line">  url: <span class="string">'http://127.0.0.1:3000/ceshi'</span>,</span><br><span class="line">  contentType: <span class="string">'application/json'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">'我是谁'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">resData</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resData);</span><br><span class="line">  &#125;,</span><br><span class="line">  error:<span class="function"><span class="keyword">function</span>(<span class="params">resData</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>服务器就接受不到前端传递的参数了,这是为什么呢,同样都是跨域,为什么一个收的到,一个却不行</p>
<p>因为非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<blockquote>
<p>当服务端允许跨域后</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Origin, X-Requested-With, Content-Type, Accept"</span>);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Methods"</span>,<span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</span><br><span class="line">  res.header(<span class="string">"X-Powered-By"</span>,<span class="string">' 3.2.1'</span>)</span><br><span class="line">  res.header(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>服务器返回的响应，会多出几个头信息字段。</p>
<p>Access-Control-Allow-Origin: *<br>Access-Control-Allow-Credentials: true<br>Access-Control-Expose-Headers: Origin, X-Requested-With, Content-Type, Accept<br>Content-Type: text/html; charset=utf-8</p>
<p>好了，以上就是我对跨域的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入研究webApp适配</title>
    <url>/2018/11/21/64-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6webApp%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>前面的博客我们有研究过webApp的页面适配以及sass的用法,已经知道怎么做了,我们就来讨论一下,为什么这么做</p>
</blockquote>
<a id="more"></a>

<p>首页,webApp的适配大致分为两种</p>
<ul>
<li><p>宽度百分比,高度定死</p>
</li>
<li><p>宽高都是百分比</p>
</li>
</ul>
<p>做法是各有好处,但是虽然页面越来越复杂,定高的设计已经不满足我们的需求了,所以宽高都是根据比例来动态适配的。之前也有谈过,大部分流行的还是Flexible来实现适配,那为什么UI稿给是750px按照iPhone6为基准呢?</p>
<p>首先先说一下为什么用750px,手机碎屏化越来越严重,如何兼容现在这么多分辨率的设备就是一个问题了,这时候iPhone6的实际分辨率750就被关注到,向上兼容和向下兼容都不会怎么失真,是一个比较完美的折中方案.</p>
<p>再来说说iPhone6明明宽度的像素是375,为什么UI稿是两倍的像素也就是750px.</p>
<p>这里就是对于像素的定义了,750px是iPhone6的物理像素，也叫屏幕分辨率,就是设备屏幕上的实际像素。也就是说这个手机被出厂造出来的时候，这个屏幕上有多少个像素点，他的物理像素就是多少.</p>
<p>而谷歌模拟器上的375像素叫做设备独立像素,也叫做逻辑像素,对于前端来说，和我们的css像素是一样的,在viewport为ideal-viewport模式时,如iPhone6此时的viewport为375px,也就是说,iPhone6的设备宽度和高度为375pt * 667pt,可以理解为设备的独立像素,而其dpr为2，我们可以很轻松得知其物理像素为750pt * 1334pt。所以设计师给我们的UI为750px.</p>
<p>在手淘的设计师和前端开发协作过程中：手淘设计师常选择iPhone6作为基准设计尺寸，交付给前端的设计尺寸是按750px * 1334px为准(高度会随着内容多少而改变)。前端开发人员通过一套适配规则自动适配到其他的尺寸。</p>
<p><img src="http://www.w3cplus.com/sites/default/files/blogs/2015/1511/rem-6.jpg" alt="我是图片"></p>
<p>接下来说说在项目中的具体实现</p>
<h3 id="手淘flexible"><a href="#手淘flexible" class="headerlink" title="手淘flexible"></a>手淘flexible</h3><p>之前有讨论过sass,现在来看看sass与flexible怎么结合</p>
<p>首先先安装sass</p>
<blockquote>
<p>cnpm install node-sass –-save<br>  cnpm install sass-loader –-save</p>
</blockquote>
<p>然后再之后在使用的时候声明一下 <style lang="scss"></style></p>
<p>sass的功能我们都知道,有一个自定义函数的功能,我们可以通过这个,来使我们的px转化为rem</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@function px2rem($px) &#123;</span><br><span class="line">  $rem : 75px;</span><br><span class="line">  @return ($px &#x2F; $rem) + rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这个sass文件放在全局中,在每个样式中就可以直接px2rem(675px)去使用了,可是要怎么引入呢</p>
<p>首先安装一下插件</p>
<blockquote>
<p>cnpm install sass-resources-loader –save</p>
</blockquote>
<p>在build文件下的utils.js中修改sass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return &#123;</span><br><span class="line">  css: generateLoaders(),</span><br><span class="line">  postcss: generateLoaders(),</span><br><span class="line">  less: generateLoaders(&#39;less&#39;),</span><br><span class="line">  sass: generateLoaders(&#39;sass&#39;, &#123; indentedSyntax: true &#125;),</span><br><span class="line">  scss: generateLoaders(&#39;sass&#39;).concat(</span><br><span class="line">  &#123;</span><br><span class="line">    loader: &#39;sass-resources-loader&#39;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      resources: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;assets&#x2F;style&#x2F;index.scss&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  stylus: generateLoaders(&#39;stylus&#39;),</span><br><span class="line">  styl: generateLoaders(&#39;stylus&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将自己的全局sass文件的文件替换一下</p>
<p>接下来就是安装 flexible</p>
<blockquote>
<p>cnpm install lib-flexible –save</p>
</blockquote>
<p>在main.js中 导入就OK啦 import ‘lib-flexible’</p>
<h3 id="VW来适配页面"><a href="#VW来适配页面" class="headerlink" title="VW来适配页面"></a>VW来适配页面</h3><p>接下来我们说说最近流行起来的vw适配页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@function vw($px) &#123;</span><br><span class="line">  @return ($px &#x2F; 750) * 100vw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UI稿的比例是多少,就写多少,但是需要注意的是字体</p>
<p>假如 字体我们设置的是 font-size: 3vw; 意味着在一个屏幕宽度为320px的设备(移动)上，文本大小将为10px,这种字体明显太小了,而在1440px的笔记本屏幕上,字体又太大了,所以我们应该这样写</p>
<p><code>font-size: calc(18px + 0.25vw)</code></p>
<p>这样既不会让字体太小,也不会让字体太大,可是在 Mac上的Safari并不通用,可以换一种办法</p>
<p><code>font-size: calc(112.5% + 0.5vw)</code></p>
<p>我以为这样就可以了,就完成了页面适配,直到我今天看到了大漠老师的文章,豁然开朗  <a href="https://www.w3cplus.com/mobile/vw-layout-in-vue.html" target="_blank" rel="noopener">戳我戳我</a></p>
<blockquote>
<p>下回再说,先让我研究一下</p>
</blockquote>
<p>好了，以上就是我对webApp适配的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>前端适配</category>
      </categories>
      <tags>
        <tag>前端适配</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>vw终极适配方案</title>
    <url>/2018/11/23/65-vw%E7%BB%88%E6%9E%81%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>这篇文章,主要摘录大漠老师的文章,地址在上篇博客有提到,记录学习一下现在H5适配的主流方向</p>
</blockquote>
<a id="more"></a>

<p>大漠老师自己也提到了,现在已经弃用了Flexible的布局方案,开始彻底拥抱vw适配方案,当然到目前为止不管是哪一种方案，都还存在一定的缺陷。言外之意，还没有哪一个方案是完美的</p>
<p>废话不多说,直接进入正题,vue-cli中如何使用vw来适配webApp页面</p>
<p>首先,我们需要用到这些工具</p>
<ul>
<li>NodeJs</li>
<li>NPM</li>
<li>Webpack</li>
<li>Vue-cli</li>
<li>postcss-import</li>
<li>postcss-url</li>
<li>postcss-aspect-ratio-mini</li>
<li>postcss-cssnext</li>
<li>autoprefixer</li>
<li>postcss-px-to-viewport</li>
<li>postcss-write-svg</li>
<li>cssnano</li>
</ul>
<p>好了,后面会说这些都是干嘛用的,进入项目</p>
<h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><p><code>vue init webpack project</code></p>
<blockquote>
<p>通过Vue-cli构建的项目，在项目的根目录下有一个.postcssrc.js,我们来看看他们具体都是干什么的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &quot;plugins&quot;: &#123;</span><br><span class="line">    &#x2F;&#x2F; postcss-import主要功有是解决@import引入路径问题。使用这个插件，可以让你很轻易的使用本地文件、node_modules或者web_modules的文件。这个插件配合postcss-url让你引入文件变得更轻松。</span><br><span class="line">    &quot;postcss-import&quot;: &#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; 该插件主要用来处理文件，比如图片文件、字体文件等引用路径的处理。在Vue项目中，vue-loader已具有类似的功能，只需要配置中将vue-loader配置进去。</span><br><span class="line">    &quot;postcss-url&quot;: &#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; autoprefixer插件是用来自动处理浏览器前缀的一个插件。如果你配置了postcss-cssnext，其中就已具备了autoprefixer的功能。在配置的时候，未显示的配置相关参数的话，表示使用的是Browserslist指定的列表参数，你也可以像这样来指定last 2 versions 或者 &gt; 5%。如此一来，你在编码时不再需要考虑任何浏览器前缀的问题，可以专心撸码。这也是PostCSS最常用的一个插件之一。</span><br><span class="line">    &quot;autoprefixer&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>我们需要的插件,vue-cli已经默认帮我们安装了三个了,接下来按照剩下的插件</p>
<p><code>npm i postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext cssnano --S</code></p>
<p>安装失败的小伙伴就多安装几次</p>
<blockquote>
<p>注意!注意!注意! 敲黑板了! cssnano的版本一定要<code>3.10.0</code>的, 4.0的版本不兼容报错</p>
</blockquote>
<p>安装成功后,package.json里面应该是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;cssnano&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">  &quot;cssnano-preset-advanced&quot;: &quot;^4.0.5&quot;,</span><br><span class="line">  &quot;postcss-aspect-ratio-mini&quot;: &quot;0.0.2&quot;,</span><br><span class="line">  &quot;postcss-cssnext&quot;: &quot;^3.1.0&quot;,</span><br><span class="line">  &quot;postcss-px-to-viewport&quot;: &quot;0.0.3&quot;,</span><br><span class="line">  &quot;postcss-write-svg&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">  &quot;vue&quot;: &quot;^2.5.2&quot;,</span><br><span class="line">  &quot;vue-router&quot;: &quot;^3.0.1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote>
<p>接下来在.postcssrc.js文件对新安装的PostCSS插件进行配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &quot;plugins&quot;: &#123;</span><br><span class="line">    &quot;postcss-import&quot;: &#123;&#125;,</span><br><span class="line">    &quot;postcss-url&quot;: &#123;&#125;,</span><br><span class="line">    &quot;postcss-aspect-ratio-mini&quot;: &#123;&#125;,</span><br><span class="line">    &quot;postcss-write-svg&quot;: &#123;</span><br><span class="line">      utf8: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; postcss-cssnext: postcss-cssnext其实就是cssnext。该插件可以让我们使用CSS未来的特性，其会对这些特性做相关的兼容性处理</span><br><span class="line">    &quot;postcss-cssnext&quot;: &#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; postcss-px-to-viewport: postcss-px-to-viewport插件主要用来把px单位转换为vw、vh、vmin或者vmax这样的视窗单位</span><br><span class="line">    &quot;postcss-px-to-viewport&quot;: &#123;</span><br><span class="line">      viewportWidth: 750, &#x2F;&#x2F; 视窗的宽度，对应的是我们设计稿的宽度，一般是750</span><br><span class="line">      viewportHeight: 1334, &#x2F;&#x2F; 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置</span><br><span class="line">      unitPrecision: 3, &#x2F;&#x2F; 指定&#96;px&#96;转换为视窗单位值的小数位数（很多时候无法整除）</span><br><span class="line">      viewportUnit: &#39;vw&#39;, &#x2F;&#x2F; 指定需要转换成的视窗单位，建议使用vw</span><br><span class="line">      selectorBlackList: [&#39;.ignore&#39;, &#39;.hairlines&#39;], &#x2F;&#x2F; 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名。</span><br><span class="line">      minPixelValue: 1, &#x2F;&#x2F; 小于或等于&#96;1px&#96;不转换为视窗单位，你也可以设置为你想要的值。</span><br><span class="line">      mediaQuery: false &#x2F;&#x2F; 允许在媒体查询中转换&#96;px&#96;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; cssnano: cssnano主要用来压缩和清理CSS代码。在Webpack中，cssnano和css-loader捆绑在一起，所以不需要自己加载它。不过你也可以使用postcss-loader显式的使用cssnano</span><br><span class="line">    &quot;cssnano&quot;: &#123;</span><br><span class="line">      preset: &quot;advanced&quot;,</span><br><span class="line">      autoprefixer: false,</span><br><span class="line">      &quot;postcss-zindex&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别声明：由于cssnext和cssnano都具有autoprefixer,事实上只需要一个，所以把默认的autoprefixer删除掉，然后把cssnano中的autoprefixer设置为false。对于其他的插件使用，代码中的注释都做了简单的介绍。</p>
</blockquote>
<p>在cssnano的配置中，使用了preset: “advanced”，所以我们需要另外安装</p>
<p><code>npm i cssnano-preset-advanced --save-dev</code></p>
<p>cssnano集成了一些其他的PostCSS插件，如果你想禁用cssnano中的某个插件的时候，可以像下面这样操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;cssnano&quot;: &#123;</span><br><span class="line">  preset: &quot;advanced&quot;,</span><br><span class="line">  autoprefixer: false,</span><br><span class="line">  &quot;postcss-zindex&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码把autoprefixer和postcss-zindex禁掉了。前者是有重复调用，后者是一个讨厌的东东。只要启用了这个插件，z-index的值就会重置为1。这是一个天坑，千万记得将postcss-zindex设置为false。</p>
</blockquote>
<p>到此,配置结束,可以开始撸代码了,直接按照设计稿的大小写样式,编译后会自动转化为vw</p>
<blockquote>
<p>在不想要把px转换为vw的时候，首先在对应的元素（html）中添加配置中指定的类名.ignore或.hairlines(.hairlines一般用于设置border-width:0.5px的元素中)</p>
</blockquote>
<p>类似这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;box ignore&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ignore 的类,里面的样式不会被转变,这样一个div中,box的类为想要转变的内容,ignore不转变</span><br><span class="line"></span><br><span class="line">.ignore &#123;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大漠老师还用到了postcss-aspect-ratio-mini</p>
<p>postcss-aspect-ratio-mini主要用来处理元素容器宽高比。在实际使用的时候，具有一个默认的结构。</p>
<p>简单的来说就是自定义属性吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div aspectratio w-188-246&gt;</span><br><span class="line">  &lt;div aspectratio-content&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有一点需要特别注意：aspect-ratio属性不能和其他属性写在一起，否则编译出来的属性只会留下aspect-ratio的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[aspectratio] &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[aspectratio]::before &#123;</span><br><span class="line">  content: &#39;&#39;;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 1px;</span><br><span class="line">  margin-left: -1px;</span><br><span class="line">  height: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[aspectratio-content] &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[w-188-246] &#123;</span><br><span class="line">  aspect-ratio: &#39;188:246&#39;;</span><br><span class="line">&#125;</span><br><span class="line">[w-188-246] &#123;</span><br><span class="line">  width: 188px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我个人觉得用起来不大习惯…</p>
<h3 id="1px适配"><a href="#1px适配" class="headerlink" title="1px适配"></a>1px适配</h3><p>postcss-write-svg插件主要用来处理移动端1px的解决方案。该插件主要使用的是border-image和background来做1px的相关处理。</p>
<p>这里和大漠老师的方法有点不太一样,原理是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@svg 1px-border &#123;</span><br><span class="line">  width: 4px;</span><br><span class="line">  height: 4px;</span><br><span class="line">  @rect &#123;</span><br><span class="line">    fill: transparent;  &#x2F;*content为透明*&#x2F;</span><br><span class="line">    width: 100%;  &#x2F;*宽度为4px * 100%*&#x2F;</span><br><span class="line">    height: 100%;  &#x2F;*高度为4px * 100%*&#x2F;</span><br><span class="line">    stroke-width: 25%;  &#x2F;*边框宽度 4px * 25%(即1px)*&#x2F;</span><br><span class="line">    stroke: var(--color, black);  &#x2F;*颜色*&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.example &#123;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">  border-image: svg(1px-border param(--color red)) 1 1 stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于字体"><a href="#关于字体" class="headerlink" title="关于字体"></a>关于字体</h3><p>字体的话,大漠老师说了可以直接使用vw适配,如果有小伙伴感觉字体不想变动太大,可以这样子</p>
<p><code>font-size: calc(18px + 0.25vw)</code></p>
<p>差不多了,现阶段前端的适配就是这么多了,溜了溜了</p>
<p>以上就是我对webApp适配的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>前端适配</category>
      </categories>
      <tags>
        <tag>前端适配</tag>
      </tags>
  </entry>
  <entry>
    <title>H5离线缓存</title>
    <url>/2018/11/27/66-H5%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>我们浏览网页的时候经常遇到断网,这时候网页就提示失败了,对用户的体验很不好,前端是可以进行离线缓存的,一起看看怎么实现</p>
</blockquote>
<a id="more"></a>

<p>记得两年前用过离线缓存,用的是manifest,当时用的兴高采烈,配置一下就完事了,今天打开一看,报错了,.manifest文件不识别,web服务器未配置,依稀记得使用node服务器的express框架的时候,自动就会识别的,查一下文档,发现这个马上就要被弃用了,得了,学习一下H5新的离线缓存吧</p>
<h3 id="Service-Worker实现缓存"><a href="#Service-Worker实现缓存" class="headerlink" title="Service Worker实现缓存"></a>Service Worker实现缓存</h3><p>service worker也称服务器工作线程，是浏览器在后台独立网页运行的脚本。我们平常浏览器窗口中跑的页面运行的是主JavaScript线程，DOM和window全局变量都是可以访问的。而Service Worker是走的另外的线程，可以理解为在浏览器背后默默运行的一个线程，脱离浏览器窗体，因此，window以及DOM都是不能访问的，此时我们可以使用self访问全局上下文。</p>
<blockquote>
<p>出于安全原因，Service Workers 要求必须在 HTTPS 下才能运行。为了便于本地开发，localhost 也被浏览器认为是安全源。</p>
</blockquote>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://img-blog.csdn.net/20160610225250056" alt="我是图片"></p>
<p>总结起来Service Worker的生命周期有如下几个关键步骤（就是常常需要监听并制定回调函数的事件）：</p>
<ol>
<li>注册（register）当你的应用未注册过service worker，那么第一步就是注册；</li>
<li>安装（install）,注册完成之后，会触发install,在这一步我们可以进行文件缓存；</li>
<li>响应请求（fetch）,fetch用于拦截用户请求，并响应，返回Promise对象,成功安装service worker后，待用户下次再进入页面，返回已返回的文件。</li>
<li>更新（activate），当网站上当前页面被关闭，旧服务线程被终止。重新打开网页时，新服务工作线程取得控制权后，会触发activate事件。这一步我们可以清楚就版本缓存。</li>
<li>销毁，是否销毁由浏览器决定，如果一个service worker长期不使用或者机器内存有限，则可能会销毁这个worker</li>
</ol>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>在index.html页面中去注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查浏览器是否对 serviceWorker 有原生支持</span><br><span class="line">if (&#39;serviceWorker&#39; in navigator) &#123;</span><br><span class="line">  &#x2F;&#x2F; 有原生支持时，在页面加载后开启新的 Service Worker 线程，从而优化首屏加载速度</span><br><span class="line">  &#x2F;&#x2F; 注册 service worker</span><br><span class="line">  window.addEventListener(&#39;load&#39;, function() &#123;</span><br><span class="line">  &#x2F;&#x2F; register 方法里第一个参数为 Service Worker 要加载的文件；第二个参数 scope 可选，用来指定 Service Worker 控制的内容的子目录</span><br><span class="line">    navigator.serviceWorker.register(&#39;.&#x2F;ServiceWorker.js&#39;,&#123;scope: &#39;&#x2F;&#39;&#125;).then(function(registration) &#123;</span><br><span class="line">      &#x2F;&#x2F; Service Worker 注册成功</span><br><span class="line">      console.log(&#39;ServiceWorker 注册成功: &#39;, registration.scope);</span><br><span class="line">    &#125;).catch(function(err) &#123;</span><br><span class="line">      &#x2F;&#x2F; Service Worker 注册失败</span><br><span class="line">      console.log(&#39;ServiceWorker 注册失败: &#39;, err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在index.html同级下创建ServiceWorker.js,在里面进行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 用于标注创建的缓存，也可以根据它来建立版本规范</span><br><span class="line">const CACHE_NAME &#x3D; &quot;cs_cache_v1.0.0&quot;;</span><br><span class="line">&#x2F;&#x2F; 列举要默认缓存的静态资源，一般用于离线使用</span><br><span class="line">const urlsToCache &#x3D; [</span><br><span class="line">  &#39;&#x2F;index.html&#39;,</span><br><span class="line">  &#39;.&#x2F;images&#x2F;complete.jpg&#39;,</span><br><span class="line">  &#39;.&#x2F;images&#x2F;timeout.jpg&#39;,</span><br><span class="line">  &#39;.&#x2F;js&#x2F;TimeoutScene.js&#39;,</span><br><span class="line">  &#39;.&#x2F;js&#x2F;CompleteScene.js&#39;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const offlineUrl &#x3D; &#39;index.html&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; self 为当前 scope 内的上下文</span><br><span class="line">&#x2F;&#x2F;当页面加载时触发该事件。常用于缓存离线页面，当断开网络时，在该事件中缓存的页面将被返回给用户。</span><br><span class="line">self.addEventListener(&#39;install&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; event.waitUtil 用于在安装成功之前执行一些预装逻辑</span><br><span class="line">  &#x2F;&#x2F; 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率</span><br><span class="line">  &#x2F;&#x2F; 安装成功后 ServiceWorker 状态会从 installing 变为 installed</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    &#x2F;&#x2F; 使用 cache API 打开指定的 cache 文件</span><br><span class="line">    caches.open(CACHE_NAME).then(cache &#x3D;&gt; &#123;</span><br><span class="line">      console.log(cache);</span><br><span class="line">      &#x2F;&#x2F; 添加要缓存的资源列表</span><br><span class="line">      return cache.addAll(urlsToCache);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h3><p>也是在ServiceWorker.js下继续写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.addEventListener(&#39;fetch&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">  if(event.request.mode &#x3D;&#x3D;&#x3D; &#39;navigate&#39; || (event.request.method &#x3D;&#x3D;&#x3D; &#39;GET&#39; &amp;&amp; event.request.headers.get(&#39;accept&#39;).includes(&#39;text&#x2F;html&#39;))) &#123;</span><br><span class="line">    event.respondWith(</span><br><span class="line">      fetch(event.request.url).catch(error &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; Return the offline page</span><br><span class="line">        return caches.match(offlineUrl);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    event.respondWith(caches.match(event.request)</span><br><span class="line">      .then(function(response) &#123;</span><br><span class="line">        return response || fetch(event.request);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>也是在ServiceWorker.js下继续写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.addEventListener(&#39;activate&#39;, event &#x3D;&gt; event.waitUntil(</span><br><span class="line">  Promise.all([</span><br><span class="line">    &#x2F;&#x2F; 更新客户端</span><br><span class="line">    clients.claim(),</span><br><span class="line">    &#x2F;&#x2F; 清理旧版本</span><br><span class="line">    caches.keys().then(cacheList &#x3D;&gt; Promise.all(</span><br><span class="line">      cacheList.map(cacheName &#x3D;&gt; &#123;</span><br><span class="line">        if(cacheName !&#x3D;&#x3D; CACHE_NAME) &#123;</span><br><span class="line">          caches.delete(cacheName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    ))</span><br><span class="line">  ])</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<h3 id="手动更新"><a href="#手动更新" class="headerlink" title="手动更新"></a>手动更新</h3><p>其实在页面中，也可以手动来管理更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const version &#x3D; &#39;1.0.1&#39;;</span><br><span class="line"></span><br><span class="line">navigator.serviceWorker.register(&#39;&#x2F;ServiceWorker.js&#39;).then(reg &#x3D;&gt; &#123;</span><br><span class="line">  if (localStorage.getItem(&#39;sw_version&#39;) !&#x3D;&#x3D; version) &#123;</span><br><span class="line">    reg.update().then(() &#x3D;&gt; localStorage.setItem(&#39;sw_version&#39;, version));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>差不多就是这样的啦,有一些其他的功能还没有研究透,到时候再来补上,有兴趣的小伙伴可以看看官网文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener">戳我戳我</a></p>
<p>以上就是我对离线缓存的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>离线缓存</category>
      </categories>
      <tags>
        <tag>离线缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Html转PDF</title>
    <url>/2018/11/29/68-Html%E8%BD%ACPDF/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>有时候,我们需要将html转化为pdf,在此记录一下</p>
</blockquote>
<a id="more"></a>

<p>用到了两个插件 html2canvas与 jspdf,重要的策略就是讲html转化为图片,再将图片转化为pdf</p>
<p>其他的没有了,我也是在网上找的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;转PDF&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- .pdf文件下载  download --&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;html2canvas&#x2F;0.5.0-beta4&#x2F;html2canvas.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jspdf&#x2F;1.3.4&#x2F;jspdf.debug.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;!-- jQuery 2.2.3 --&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;plugins&#x2F;jQuery&#x2F;jquery-2.2.3.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">      #pdfDom&#123;</span><br><span class="line">        text-align: center;</span><br><span class="line">        border: 1px solid blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right-aside&quot; id&#x3D;&quot;pdfDom&quot; class&#x3D;&quot;right-aside&quot;&gt;</span><br><span class="line">      &lt;div&gt;点击下面的按钮，内容将会被导出为pdf.&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;</span><br><span class="line">        &lt;defs&gt;</span><br><span class="line">          &lt;filter id&#x3D;&quot;MyFilter&quot; filterUnits&#x3D;&quot;userSpaceOnUse&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;120&quot;&gt;</span><br><span class="line">            &lt;feGaussianBlur in&#x3D;&quot;SourceAlpha&quot; stdDeviation&#x3D;&quot;4&quot; result&#x3D;&quot;blur&quot;&gt;&lt;&#x2F;feGaussianBlur&gt;</span><br><span class="line">            &lt;feOffset in&#x3D;&quot;blur&quot; dx&#x3D;&quot;4&quot; dy&#x3D;&quot;4&quot; result&#x3D;&quot;offsetBlur&quot;&gt;&lt;&#x2F;feOffset&gt;</span><br><span class="line">            &lt;feSpecularLighting in&#x3D;&quot;blur&quot; surfaceScale&#x3D;&quot;5&quot; specularConstant&#x3D;&quot;.75&quot; specularExponent&#x3D;&quot;20&quot; lighting-color&#x3D;&quot;#bbbbbb&quot; result&#x3D;&quot;specOut&quot;&gt;</span><br><span class="line">              &lt;fePointLight x&#x3D;&quot;-5000&quot; y&#x3D;&quot;-10000&quot; z&#x3D;&quot;20000&quot;&gt;&lt;&#x2F;fePointLight&gt;</span><br><span class="line">            &lt;&#x2F;feSpecularLighting&gt;</span><br><span class="line">            &lt;feComposite in&#x3D;&quot;specOut&quot; in2&#x3D;&quot;SourceAlpha&quot; operator&#x3D;&quot;in&quot; result&#x3D;&quot;specOut&quot;&gt;&lt;&#x2F;feComposite&gt;</span><br><span class="line">            &lt;feComposite in&#x3D;&quot;SourceGraphic&quot; in2&#x3D;&quot;specOut&quot; operator&#x3D;&quot;arithmetic&quot; k1&#x3D;&quot;0&quot; k2&#x3D;&quot;1&quot; k3&#x3D;&quot;1&quot; k4&#x3D;&quot;0&quot; result&#x3D;&quot;litPaint&quot;&gt;&lt;&#x2F;feComposite&gt;</span><br><span class="line">            &lt;feMerge&gt;</span><br><span class="line">              &lt;feMergeNode in&#x3D;&quot;offsetBlur&quot;&gt;&lt;&#x2F;feMergeNode&gt;</span><br><span class="line">              &lt;feMergeNode in&#x3D;&quot;litPaint&quot;&gt;&lt;&#x2F;feMergeNode&gt;</span><br><span class="line">            &lt;&#x2F;feMerge&gt;</span><br><span class="line">          &lt;&#x2F;filter&gt;</span><br><span class="line">        &lt;&#x2F;defs&gt;</span><br><span class="line">        &lt;rect x&#x3D;&quot;1&quot; y&#x3D;&quot;1&quot; width&#x3D;&quot;198&quot; height&#x3D;&quot;118&quot; fill&#x3D;&quot;#cccccc&quot;&gt;&lt;&#x2F;rect&gt;</span><br><span class="line">        &lt;g filter&#x3D;&quot;url(#MyFilter)&quot;&gt;</span><br><span class="line">          &lt;path fill&#x3D;&quot;none&quot; stroke&#x3D;&quot;#D90000&quot; stroke-width&#x3D;&quot;10&quot; d&#x3D;&quot;M50,90 C0,90 0,30 50,30 L150,30 C200,30 200,90 150,90 z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">          &lt;text fill&#x3D;&quot;#FFFFFF&quot; stroke&#x3D;&quot;black&quot; font-size&#x3D;&quot;45&quot; font-family&#x3D;&quot;Verdana&quot; x&#x3D;&quot;52&quot; y&#x3D;&quot;76&quot;&gt;SVG&lt;&#x2F;text&gt;</span><br><span class="line">        &lt;&#x2F;g&gt;</span><br><span class="line">      &lt;&#x2F;svg&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;button onclick&#x3D;&quot;makeMpdf(&#39;测试&#39;)&quot;&gt;导出PDF文件&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F;将html页面导出.pdf格式文件(适用于jQuery、vue库)  -- cs 2018&#x2F;11&#x2F;28</span><br><span class="line">    function makeMpdf(pdfName) &#123;</span><br><span class="line">      if(confirm(&quot;您确认下载该PDF文件吗?&quot;)) &#123;</span><br><span class="line">        var target &#x3D; document.getElementsByClassName(&quot;right-aside&quot;)[0];</span><br><span class="line">        target.style.background &#x3D; &quot;#FFFFFF&quot;;</span><br><span class="line">        if(pdfName &#x3D;&#x3D; &#39;&#39; || pdfName &#x3D;&#x3D; undefined) pdfName &#x3D; getNowFormatDate();</span><br><span class="line"></span><br><span class="line">        html2canvas(target, &#123;</span><br><span class="line">          onrendered: function(canvas) &#123;</span><br><span class="line">            var contentWidth &#x3D; canvas.width;</span><br><span class="line">            var contentHeight &#x3D; canvas.height;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;一页pdf显示html页面生成的canvas高度;</span><br><span class="line">            var pageHeight &#x3D; contentWidth &#x2F; 592.28 * 841.89;</span><br><span class="line">            &#x2F;&#x2F;未生成pdf的html页面高度</span><br><span class="line">            var leftHeight &#x3D; contentHeight;</span><br><span class="line">            &#x2F;&#x2F;页面偏移</span><br><span class="line">            var position &#x3D; 0;</span><br><span class="line">            &#x2F;&#x2F;a4纸的尺寸[595.28,841.89]，html页面生成的canvas在pdf中图片的宽高</span><br><span class="line">            var imgWidth &#x3D; 595.28;</span><br><span class="line">            var imgHeight &#x3D; 592.28 &#x2F; contentWidth * contentHeight;</span><br><span class="line"></span><br><span class="line">            var pageData &#x3D; canvas.toDataURL(&#39;image&#x2F;jpeg&#39;, 1.0);</span><br><span class="line">            &#x2F;&#x2F;p：横向，a4：纸张大小，默认是a4;</span><br><span class="line">            var pdf &#x3D; new jsPDF(&#39;&#39;, &#39;pt&#39;, &#39;a4&#39;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)</span><br><span class="line">            &#x2F;&#x2F;当内容未超过pdf一页显示的范围，无需分页</span><br><span class="line">            if(leftHeight &lt; pageHeight) &#123;</span><br><span class="line">              pdf.addImage(pageData, &#39;JPEG&#39;, 0, 0, imgWidth, imgHeight);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              while(leftHeight &gt; 0) &#123;</span><br><span class="line">                pdf.addImage(pageData, &#39;JPEG&#39;, 0, position, imgWidth, imgHeight)</span><br><span class="line">                leftHeight -&#x3D; pageHeight;</span><br><span class="line">                position -&#x3D; 841.89;</span><br><span class="line">                &#x2F;&#x2F;避免添加空白页</span><br><span class="line">                if(leftHeight &gt; 0) &#123;</span><br><span class="line">                  pdf.addPage();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pdf.save(pdfName + &quot;.pdf&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>


<p>以上就是我对Html转PDF的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>图片上传与压缩</title>
    <url>/2018/11/28/67-%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E4%B8%8E%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>整理一下图片上传和图片压缩,以及canvas的一些小BUG</p>
</blockquote>
<a id="more"></a>

<p>图片上传应该是老生常谈的问题了,今天记录一下,方便以后造轮子</p>
<p>上传图片一般分为两种,一种是文件流,一种是base64的数据</p>
<h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p>先是html的代码,样式就不写了,点击添加之后可以多图上传</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;chooseImg&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;1.png&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;photo&quot; accept&#x3D;&quot;image&#x2F;*&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!--处理添加空白--&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;upload&quot;&gt;</span><br><span class="line">    &lt;!--&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;添加&quot; &#x2F;&gt;--&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;添加&quot; @click&#x3D;&quot;addimg&quot; &#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>接下来是逻辑部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init() &#123;</span><br><span class="line">  &#x2F;&#x2F; 监听提交</span><br><span class="line">  $(&#39;form&#39;).submit(function(event) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    var data &#x3D; new FormData(this);</span><br><span class="line">    $.post(&#123;</span><br><span class="line">      url: &#39;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;singlePic&#39;,</span><br><span class="line">      data: data,</span><br><span class="line">      &#x2F;&#x2F;false:是告诉jquery不使用默认的数据类型</span><br><span class="line">      contentType: false,</span><br><span class="line">      processData: false,</span><br><span class="line">      success: function(resData) &#123;</span><br><span class="line">        if(resData.code &#x3D;&#x3D; &#39;success&#39;) &#123;</span><br><span class="line">          console.log(resData);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      error:function(resData)&#123;</span><br><span class="line">        console.log(resData);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 点击添加后出现添加图片</span><br><span class="line">  addimg()&#123;</span><br><span class="line">    &#x2F;&#x2F; 获取最外层大框的div</span><br><span class="line">    var chooseImgDiv &#x3D; document.querySelector(&#39;.chooseImg&#39;);</span><br><span class="line">    &#x2F;&#x2F; 创建img标签元素</span><br><span class="line">    var img &#x3D; document.createElement(&#39;img&#39;);</span><br><span class="line">    &#x2F;&#x2F; src赋值图片</span><br><span class="line">    img.src &#x3D; &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAAWYAAAFpCAYAAACvcILDAAAG2ElEQVR4nO3dsU5cBxiE0SxKBaVb137&#x2F;5+EdKE0JsYlugbW2CIHZGe05zUqJrrRC6M+nFTs5Pf&#x2F;wFwA1bi79BgB4zWEGKOMwA5RxmAHKOMwAZRxmgDJ&#x2F;n&#x2F;uH9&#x2F;f3f3zoy5cvr14PDw8Pr1495znPec5zr93e3r68fv369ey&#x2F;&#x2F;0kxA5Q5nfuCyVHM3759i78hgGunmAHKnP2M+dfPTADIUcwAZc5+xgzA5zj+WuNPn0woZoAyDjNA0M9i&#x2F;t3fOB8cZoAyZw&#x2F;zWy46AJ9DMQOUUcwAZRQzQJmz3&#x2F;wD4HO85ZvVihmgjGIGCFLMAIOsywGUUcwAZazLAQRZlwMY5DADBFmXAxhkKwOgjGIGKKOYAcooZoAytjIAgmxlAAxSzABBihlgkHU5gDKKGaCMdTmAIOtyAIMcZoAg63IAg2xlAJRRzABlFDNAGcUMUMZWBkCQrQyAQYoZIEgxAwyyLgdQRjEDlLEuBxBkXQ5gkMMMEGRdDmCQrQyAMooZoIxiBiijmAHK2MoACLKVATBIMQMEKWaAQdblAMooZoAy1uUAgqzLAQxymAGCrMsBDLKVAVBGMQOUUcwAZRQzQBlbGQBBtjIABilmgCDFDDDIuhxAGcUMUMa6HECQdTmAQQ4zQJB1OYBBtjIAyihmgDKKGaCMYgYoYysDIMhWBsAgxQwQpJgBBlmXAyijmAHKWJcDCLIuBzDIYQYIsi4HMMhWBkAZxQxQRjEDlFHMAGVsZQAE2coAGKSYmXN8WfW9X1o9nU6vXiFJMQMMsi7HnMfHx5fXp6endz1&#x2F;c&#x2F;Nvj9zd3X3Ye4KPpJgByihmgCDrcgCDHGaAIOtyAINsZQCUUcwAZRQzQBnFDFDGVgZAkK0MgEGKGSBIMQMMspUBUEYxA5RRzABB1uUABjnMAEHW5QAG2coAKKOYAcooZoAyihmgjK0MgCBbGQCDFDNAkGIGGGQrA6CMYgYoo5gBgqzLAQxymAGCrMsBDLKVAVBGMQOUUcwAZRQzQBlbGQBBtjIABilmgCDFDDDIVgZAGcUMUEYxAwRZlwMY5DADBFmXAxhkKwOgjGIGKKOYAcooZoAytjIAgmxlAAxSzABBihlgkK0MgDKKGaCMYgYIsi4HMMhhBgiyLgcw6OxnzG&#x2F;5DITLeX5+fnl9fHy88Du5jKenpw95&#x2F;vv37x&#x2F;xdubc3t6+vJ5Opwu&#x2F;E35HMQOUUcyDjmL+v+V47a7153f8&#x2F;ijmXooZoIytDIAgWxkAgxQzQJBiBhhkKwOgjGIGKKOYAYKsywEMcpgBgqzLAQw6e5jfctEB+ByKGaCMdblBxyrYzc11&#x2F;nf1o1bhrvXnZ1Wu33X+ZgIUs5Ux6Cieu7u7C7+Tyzj+zyPvLeejlK&#x2F;158dl2coAGKSYAYIUM8AgWxkAZRQzQBnFDBBkXQ5gkMMMEGRdDmCQdTmAMooZoIxiBiijmAHK2MoACLKVATBIMQMEKWaAQbYyAMooZoAyihkgyLocwCCHGSDIuhzAIFsZAGUUM0AZxQxQRjEDlLGVARBkKwNgkGIGCFLMAINsZQCUUcwAZRQzQJB1OYBBDjNAkHU5gEG2MgDKKGaAMooZoIxiBihjKwMgyFYGwCDFDBCkmAEG2coAKKOYAcooZoAg63IAgxxmgCDrcgCDbGUAlFHMAGUUM0AZxQxQxlYGQJCtDIBBihkgSDEDDLKVAVBGMQOUOT3&#x2F;cOk3Af&#x2F;F8Sv73l&#x2F;d0+n06hWSrMsBDPJXGcxRvCxTzACDbGUAlFHMAGUUM0AZxQxQxl9lAATZygAYpJgBghQzwCDrcgBlFDNAGetyAEG2MgAGOcwAQW&#x2F;5ZrXDDFDGVgZAGcUMUEYxA5RRzABlbGUABNnKABikmAGCFDPAIOtyAGUUM0AZ63IAQdblAAY5zABB1uUABtnKACijmAHKKGaAMooZoIytDIAgWxkAgxQzQJBiBhhkXQ6gjGIGKGNdDiDIuhzAIIcZIMi6HMAgWxkAZRQzQBnFDFBGMQOUsZUBEGQrA2CQYgYIUswAg6zLAZRRzABlrMsBBFmXAxjkMAMEWZcDGGQrA6CMYgYoo5gByihmgDK2MgCCbGUADFLMAEGKGWCQdTmAMooZoIx1OYAg63IAgxxmgCDrcgCDbGUAlFHMAGUUM0AZxQxQxlYGQJCtDIBBihkgSDEDDLIuB1BGMQOUsS4HEGRdDmCQwwwQZF0OYJCtDIAyihmgjGIGKKOYAcrYygAIspUBMEgxAwQpZoBB1uUAyihmgDLW5QCCrMsBDPrjX2Ucl&#x2F;133wI8Lv6vl99znvOc5zz3tufOUcwAZXzGDFBGMQOUcZgByjjMAGUcZoAyDjNAGYcZoIzDDFDmHz0CkE&#x2F;nMDSkAAAAAElFTkSuQmCC&#39;;</span><br><span class="line">    &#x2F;&#x2F; 添加子元素</span><br><span class="line">    chooseImgDiv.appendChild(img);</span><br><span class="line">    &#x2F;&#x2F; 创建input</span><br><span class="line">    var input &#x3D; document.createElement(&#39;input&#39;);</span><br><span class="line">    &#x2F;&#x2F; 赋值input为file类型,name为photo</span><br><span class="line">    input.type &#x3D; &#39;file&#39;;</span><br><span class="line">    input.name &#x3D; &#39;photo&#39;;</span><br><span class="line">    &#x2F;&#x2F;获取任意类型的图片</span><br><span class="line">    input.accept &#x3D; &#39;image&#x2F;*&#39;;</span><br><span class="line">    &#x2F;&#x2F;输入的字段是否实现自动完成功能</span><br><span class="line">    input.autocomplete &#x3D; &#39;off&#39;;</span><br><span class="line">    &#x2F;&#x2F;添加到父级节点中</span><br><span class="line">    chooseImgDiv.appendChild(input);</span><br><span class="line">    chooseImgDiv.appendChild(document.createTextNode(&#39; &#39;));</span><br><span class="line"></span><br><span class="line">    this.addEvent();</span><br><span class="line">    this.addImgInput();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 给图片添加点击事件</span><br><span class="line">  addEvent() &#123;</span><br><span class="line">    &#x2F;&#x2F;遍历找到img兄弟节点--&gt; file</span><br><span class="line">    var imgs &#x3D; document.getElementsByTagName(&#39;img&#39;);</span><br><span class="line">    &#x2F;&#x2F; 点击图片后，将事件传递给下一个兄弟节点，也就是input</span><br><span class="line">    for(var i &#x3D; 0; i &lt; imgs.length; i++) &#123;</span><br><span class="line">    imgs[i].onclick &#x3D; function() &#123;</span><br><span class="line">      this.nextElementSibling.click();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 判断上传文件的类型</span><br><span class="line">  addImgInput()&#123;</span><br><span class="line">    &#x2F;&#x2F; 获取所有的类型为file的input</span><br><span class="line">    var inputs &#x3D; document.querySelectorAll(&#39;.chooseImg input[type&#x3D;file]&#39;);</span><br><span class="line">    &#x2F;&#x2F; 添加所有input的监听状态onchange</span><br><span class="line">    for(var i &#x3D; 0; i &lt; inputs.length; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当input发生改变时，也就是上传图片了</span><br><span class="line">    inputs[i].onchange &#x3D; function() &#123;</span><br><span class="line">      console.log(this.files);</span><br><span class="line">      &#x2F;&#x2F; 获取图文件</span><br><span class="line">      var file &#x3D; this.files[0];</span><br><span class="line">      &#x2F;&#x2F;判断文件是否是image类型</span><br><span class="line">      if(file.type.startsWith(&#39;image&#39;)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将img的src赋值为这张图片</span><br><span class="line">        this.previousElementSibling.src &#x3D; URL.createObjectURL(file);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>VUE写的话就在初始化一下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  this.init();</span><br><span class="line">  this.addEvent();</span><br><span class="line">  this.addImgInput()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>同样是监听一下input改变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init() &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取所有的类型为file的input</span><br><span class="line">  var inputs &#x3D; document.querySelectorAll(&#39;input[type&#x3D;file]&#39;);</span><br><span class="line">  &#x2F;&#x2F; 添加所有input的监听状态onchange</span><br><span class="line">  for(var i &#x3D; 0; i &lt; inputs.length; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当input发生改变时，也就是上传图片了</span><br><span class="line">    inputs[i].onchange &#x3D; function() &#123;</span><br><span class="line">      var file &#x3D; document.querySelector(&#39;input&#39;).files[0];</span><br><span class="line">      var reader &#x3D; new FileReader();</span><br><span class="line">      &#x2F;&#x2F; 文件读取成功完成时触发</span><br><span class="line">      reader.onload &#x3D; function(e)&#123;</span><br><span class="line">        &#x2F;&#x2F; onload事件的回调函数接受一个事件对象，该对象的target.result就是文件的内容</span><br><span class="line">        console.log(e.target.result)</span><br><span class="line">        &#x2F;&#x2F; 这里的e.target.result就已经是base64数据流了</span><br><span class="line">        document.querySelector(&#39;img&#39;).src &#x3D; e.target.result;</span><br><span class="line">      &#125;;</span><br><span class="line">      reader.readAsDataURL(file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3><p>图片压缩也是我们经常需要用到的,每行代码都有注释,直接上代码,不多说</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compress(res, index) &#123;</span><br><span class="line">  var preview &#x3D; document.getElementById(&quot;imgPreview&quot;);</span><br><span class="line">  &#x2F;&#x2F; new Image()是可以用来做预加载的</span><br><span class="line">  var img &#x3D; new Image();</span><br><span class="line">  &#x2F;&#x2F;用来设置压缩比例,越低,越失真</span><br><span class="line">  var maxHeight &#x3D; 300;</span><br><span class="line">  &#x2F;&#x2F;要先确保图片完整获取到,这是个异步事件</span><br><span class="line">  img.onload &#x3D; ()&#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建canvas标签</span><br><span class="line">    var canvas &#x3D; document.createElement(&#39;canvas&#39;);</span><br><span class="line">    &#x2F;&#x2F; 创建 context对象,getContext(&quot;2d&quot;)对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</span><br><span class="line">    var ctx &#x3D; canvas.getContext(&#39;2d&#39;);</span><br><span class="line">    &#x2F;&#x2F; 判断是否需要压缩</span><br><span class="line">    if(img.height &gt; maxHeight) &#123;</span><br><span class="line">      img.width *&#x3D; maxHeight &#x2F; img.height;</span><br><span class="line">      img.height &#x3D; maxHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 重新赋值</span><br><span class="line">    canvas.height &#x3D; img.height;</span><br><span class="line">    canvas.width &#x3D; img.width;</span><br><span class="line">    &#x2F;&#x2F; clearRect() 方法清空给定矩形内的指定像素。要清除的矩形左上角的 x 坐标,要清除的矩形左上角的 y 坐标,要清除的矩形的宽度，以像素计,要清除的矩形的高度，以像素计</span><br><span class="line">    ctx.clearRect(0, 0, canvas.width, canvas.height);</span><br><span class="line">    &#x2F;&#x2F; 在canvas绘制前填充白色背景,否则jpeg图片的透明背景会变成黑色,在clearRect()方法之后,否则会被清空</span><br><span class="line">    ctx.fillStyle &#x3D; &quot;#fff&quot;;</span><br><span class="line">    ctx.fillRect(0, 0, canvas.width, canvas.height);</span><br><span class="line">    &#x2F;&#x2F; 在画布上定位图像，并规定图像的宽度和高度：context.drawImage(img,x,y,width,height);</span><br><span class="line">    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);</span><br><span class="line">    &#x2F;&#x2F;转换图片为dataURL(图片格式,图片质量)</span><br><span class="line">    &#x2F;&#x2F; 这是一个功能函数，FileReader对象也有类似的方法，比如.readAsDataURL(),canvas正巧拥有.toDataURL()方法。</span><br><span class="line">    &#x2F;&#x2F; canvas.toDataURL([type, encoderOptions]);参数type指定图片类型，如果指定的类型不被支持则以默认值image&#x2F;png替代,encoderOptions可以为image&#x2F;jpeg 或 image&#x2F;webp类型的图片设置图片质量</span><br><span class="line">    var dataUrl &#x3D; canvas.toDataURL(&#39;image&#x2F;jpeg&#39;, 1);</span><br><span class="line">    &#x2F;&#x2F; 创建标签</span><br><span class="line">    var div &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">    var img1 &#x3D; document.createElement(&#39;img&#39;);</span><br><span class="line">    &#x2F;&#x2F;把得到的base64赋值到img标签显示</span><br><span class="line">    img1.src &#x3D; dataUrl;</span><br><span class="line">    div.appendChild(img1);</span><br><span class="line">    preview.appendChild(div);</span><br><span class="line">    this.urlArr.push(dataUrl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 在img对象中添加src,否则图片不显示</span><br><span class="line">  img.src &#x3D; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用也很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init() &#123;</span><br><span class="line">  var _this &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 获取所有的类型为file的input</span><br><span class="line">  var inputs &#x3D; document.querySelectorAll(&#39;input[type&#x3D;file]&#39;);</span><br><span class="line">  &#x2F;&#x2F; 添加所有input的监听状态onchange</span><br><span class="line">  for(var i &#x3D; 0; i &lt; inputs.length; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当input发生改变时，也就是上传图片了</span><br><span class="line">    inputs[i].onchange &#x3D; function() &#123;</span><br><span class="line">      var file &#x3D; document.querySelector(&#39;input&#39;).files[0];</span><br><span class="line">      var reader &#x3D; new FileReader();</span><br><span class="line">      &#x2F;&#x2F; 文件读取成功完成时触发</span><br><span class="line">      reader.onload &#x3D; function(e) &#123;</span><br><span class="line">        &#x2F;&#x2F; onload事件的回调函数接受一个事件对象，该对象的target.result就是文件的内容</span><br><span class="line">        var temp &#x3D; i;</span><br><span class="line">        &#x2F;&#x2F; 这里是调用压缩</span><br><span class="line">        _this.compress(e.target.result, temp);</span><br><span class="line">      &#125;;</span><br><span class="line">      reader.readAsDataURL(file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基本上图片上传的文件流,数据流,压缩就是这样的了,以后遇到具体问题再具体分析吧</p>
</blockquote>
<h3 id="服务端的代码"><a href="#服务端的代码" class="headerlink" title="服务端的代码"></a>服务端的代码</h3><blockquote>
<p>服务端接受文件流和数据流的方法是不同的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这些就不介绍了,可以看我专门介绍node的博客</span><br><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var bodyParser &#x3D; require(&#39;body-parser&#39;);</span><br><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">var multer &#x3D; require(&#39;multer&#39;);</span><br><span class="line">var form &#x3D; multer();</span><br><span class="line">var app &#x3D; express();</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: false &#125;));</span><br><span class="line">&#x2F;&#x2F; 跨域设置</span><br><span class="line">app.all(&#39;*&#39;, function(req, res, next) &#123;</span><br><span class="line">  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</span><br><span class="line">  res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">  res.header(&quot;X-Powered-By&quot;,&#39; 3.2.1&#39;)</span><br><span class="line">  res.header(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(express.static(&#39;wwwroot&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个存储对象</span><br><span class="line">var storage &#x3D; multer.diskStorage(&#123;</span><br><span class="line">&#x2F;&#x2F;  目录路径,存储位置</span><br><span class="line">  destination:&#39;.&#x2F;uploadIMG&#39;,</span><br><span class="line">&#x2F;&#x2F;    设置文件的名称</span><br><span class="line">  filename:function(req,file,cb)&#123;</span><br><span class="line">&#x2F;&#x2F;    cb(null,Date.now()+&#39;.jpg&#39;);</span><br><span class="line">    console.log(file.originalname);</span><br><span class="line">    cb(null,file.originalname);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;让存储对象来接收数据</span><br><span class="line">&#x2F;&#x2F;storage这个对象来接受数据</span><br><span class="line">var upload &#x3D; multer(&#123;storage:storage&#125;)</span><br><span class="line"></span><br><span class="line">app.post(&#39;&#x2F;singlePic&#39;,upload.array(&#39;photo&#39;),function(req,res)&#123;</span><br><span class="line">  upload.array(&#39;photo&#39;)</span><br><span class="line">  console.log(upload.array(&#39;photo&#39;))</span><br><span class="line"></span><br><span class="line">  res.send(&#123;</span><br><span class="line">    code:&#39;success&#39;,</span><br><span class="line">    message:&#39;成功&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接受数据流</span><br><span class="line">app.post(&#39;&#x2F;base64Img&#39;,function(req,res)&#123;</span><br><span class="line">  console.log(req.body)</span><br><span class="line">  &#x2F;&#x2F;接收前端POST过来的base64</span><br><span class="line">  var imgData &#x3D; req.body.imgMsg;</span><br><span class="line">  &#x2F;&#x2F;过滤data:URL</span><br><span class="line">  var base64Data &#x3D; imgData.replace(&#x2F;^data:image\&#x2F;\w+;base64,&#x2F;, &quot;&quot;);</span><br><span class="line">  var dataBuffer &#x3D; new Buffer(base64Data, &#39;base64&#39;);</span><br><span class="line">  fs.writeFile(&quot;uploadIMG&#x2F;image.jpeg&quot;, dataBuffer, function(err) &#123;</span><br><span class="line">    if(err) &#123;</span><br><span class="line">      res.send(err)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      res.send(&#123;</span><br><span class="line">        code:&#39;success&#39;,</span><br><span class="line">        message:&#39;成功&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.post(&#39;&#x2F;hello&#39;,function(req,res)&#123;</span><br><span class="line">  console.log(req.body)</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    code:&#39;success&#39;,</span><br><span class="line">    message:&#39;你好陈先生&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000,function()&#123;</span><br><span class="line">  console.log(&#39;服务启动成功,端口号3000&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>以上就是我对上传图片的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 变量声明</title>
    <url>/2018/12/04/69-ES6%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>很早就想记录一下学习ES6的过程,因为一些事情一直拖到了现在,现在总结一下ES6,准备拥抱ES7,一个一个知识点来吧</p>
</blockquote>
<a id="more"></a>

<p>首先先介绍一下ECMAScript和JavaScript到底是什么关系</p>
<p>简单的来说ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。日常场合，这两个词是可以互换的。</p>
<p>对于ES6的支持度和转码,我这里就不再多说了,总结一下ES6常用到的语法知识</p>
<blockquote>
<p>ES6新增了let和const命令</p>
</blockquote>
<h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><p>先说一下let,之前我们都是使用var来声明变量,但是当项目庞大的时候,对象容易混乱,let很好的解决了这个问题:</p>
<ul>
<li>不存在变量提升</li>
<li>块级作用域</li>
<li>不允许重复声明</li>
</ul>
<p>我们一点一点来看</p>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>举个例子,在ES5的时候</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(cs); &#x2F;&#x2F; 输出undefined</span><br><span class="line">var cs &#x3D; 2;</span><br></pre></td></tr></table></figure>

<p>运行时,var会将变量提升,使的代码变成这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cs</span><br><span class="line">console.log(cs);</span><br><span class="line">cs &#x3D; 2;</span><br></pre></td></tr></table></figure>

<p>所以变量输出undefined</p>
<p>但是let就杜绝了这种情况发生</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(cs); &#x2F;&#x2F; 报错ReferenceError</span><br><span class="line">let bar &#x3D; 2;</span><br><span class="line">let cs &#x3D; 2;</span><br></pre></td></tr></table></figure>


<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>按照阮一峰老师的话来说,叫作暂时性死区,同样举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cs &#x3D; 123;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line">  cs &#x3D; &#39;abc&#39;; &#x2F;&#x2F; ReferenceError</span><br><span class="line">  let cs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
</blockquote>
<p>再说一个块级作用域的作用,下面的这个循环,var和let的输出就不一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(let i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class="line">  setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><blockquote>
<p>let不允许在相同作用域内，重复声明同一个变量。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a &#x3D; 10;</span><br><span class="line">  var a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a &#x3D; 10;</span><br><span class="line">  let a &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><blockquote>
<p>这个就很好理解了,const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PI &#x3D; 3.1415;</span><br><span class="line">PI &#x2F;&#x2F; 3.1415</span><br><span class="line"></span><br><span class="line">PI &#x3D; 3; &#x2F;&#x2F;报错</span><br></pre></td></tr></table></figure>

<blockquote>
<p>const声明的常量，也与let一样不可重复声明。</p>
</blockquote>
<p>以上就是我对ECMAScript 6声明变量的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 解构赋值</title>
    <url>/2018/12/04/70-ES6%20%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>ES6的知识点我会都的分享在博客里面,今天总结一下解构赋值</p>
</blockquote>
<a id="more"></a>

<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p>
<p>之前的赋值我们都是这样写的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 1;</span><br><span class="line">let b &#x3D; 2;</span><br><span class="line">let c &#x3D; 3;</span><br></pre></td></tr></table></figure>

<p>但是当要声明的变量比较多的时候,这样赋值就显的代码很冗余了</p>
<h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p><code>let [a, b, d] = [1, 2, 3];</code></p>
<p><code>let [a, [b,c], d] = [1, [2,3], 4];</code></p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<blockquote>
<p>如果等号两边形式不一样，很可能获得undefined或者直接报错。</p>
</blockquote>
<h3 id="解构的默认值"><a href="#解构的默认值" class="headerlink" title="解构的默认值"></a>解构的默认值</h3><p>默认值也是很好理解的,直接上一个比较特殊的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [cs &#x3D; 1] &#x3D; [undefined]; &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">let [cs &#x3D; 1] &#x3D; [null]; &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解构赋值允许指定默认值。需要注意的地方在于,null不严格等于undefined。</p>
</blockquote>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123;c,s&#125; &#x3D; &#123;c:&#39;csing&#39;,s:&#39;chensheng&#39;&#125;;</span><br><span class="line">console.log(c,s) &#x2F;&#x2F; &#39;csing&#39;,&#39;chensheng&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
</blockquote>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; foo: baz &#125; &#x3D; &#123; foo: &#39;aaa&#39;&#125;;</span><br><span class="line">console.log(baz) &#x2F;&#x2F; &#39;aaa&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显而易见,我们之前使用对象解构赋值是简写的状态.举下面的这个例子</span><br><span class="line"></span><br><span class="line">let &#123; foo &#125; &#x3D; &#123; foo: &#39;aaa&#39;&#125;; &#x2F;&#x2F;简写</span><br><span class="line">let &#123; foo: foo &#125; &#x3D; &#123; foo: &#39;aaa&#39;&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
</blockquote>
<h3 id="对象的解构嵌套"><a href="#对象的解构嵌套" class="headerlink" title="对象的解构嵌套"></a>对象的解构嵌套</h3><p>和数组一样，解构也可以用于嵌套结构的对象。</p>
<p>举一些由浅入深的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  p: [</span><br><span class="line">    &#39;Hello&#39;,</span><br><span class="line">    &#123; y: &#39;World&#39; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; p, p: [x, &#123; y &#125;] &#125; &#x3D; obj;</span><br><span class="line"></span><br><span class="line">x &#x2F;&#x2F; &quot;Hello&quot;</span><br><span class="line">y &#x2F;&#x2F; &quot;World&quot;</span><br><span class="line">p &#x2F;&#x2F; [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span><br><span class="line"></span><br><span class="line">这里还是很好理解的,我们可以分开理解</span><br><span class="line"></span><br><span class="line">let &#123; p &#125; &#x3D; &#123; p: [&#39;Hello&#39;,&#123; y: &#39;World&#39; &#125;] &#125;</span><br><span class="line"></span><br><span class="line">所以输出p 为  [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span><br><span class="line"></span><br><span class="line">let &#123; p: [x, &#123; y &#125;] &#125; &#x3D; &#123; p: [&#39;Hello&#39;,&#123; y: &#39;World&#39; &#125;] &#125;;</span><br><span class="line"></span><br><span class="line">就等于  let [x, &#123; y &#125;]  &#x3D; [&#39;Hello&#39;,&#123; y: &#39;World&#39; &#125;];</span><br><span class="line"></span><br><span class="line">所以就很好理解 , x的输出为 &quot;Hello&quot; , y的输出为 &quot;World&quot;</span><br></pre></td></tr></table></figure>

<p>再举一个难一点的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const node &#x3D; &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: 1,</span><br><span class="line">      column: 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; &#x3D; node;</span><br><span class="line"></span><br><span class="line">loc   &#x2F;&#x2F; &#123; start: &#123;line: 1, column: 5&#125; &#125;</span><br><span class="line">start &#x2F;&#x2F; &#123;line: 1, column: 5&#125;</span><br><span class="line">line  &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们一样可以分开理解</span><br><span class="line"></span><br><span class="line">let &#123; loc &#125; &#x3D; &#123; loc: &#123;start: &#123;line: 1,column: 5&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">let &#123; loc: &#123; start &#125; &#125; &#x3D; &#123; loc: &#123;start: &#123;line: 1,column: 5&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line"></span><br><span class="line">let &#123; start &#125; &#x3D; &#123; start: &#123;line: 1,column: 5&#125; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; line我就不说了,方法都是一样的</span><br></pre></td></tr></table></figure>

<p>有一个地方一定需要注意</p>
<blockquote>
<p>如果在解构之前就定义了变量，这时候你再解构会出现问题。这时候只要在解构的语句外边加一个圆括号就可以了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x;</span><br><span class="line">(&#123;x&#125; &#x3D;&#123;x:&#39;csing&#39;&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
</blockquote>
<h3 id="字符串解构"><a href="#字符串解构" class="headerlink" title="字符串解构"></a>字符串解构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [a,b,c,d,e,f]&#x3D;&quot;csing&quot;;</span><br><span class="line">console.log(a); &#x2F;&#x2F;c</span><br><span class="line">console.log(b); &#x2F;&#x2F;s</span><br><span class="line">console.log(c); &#x2F;&#x2F;i</span><br><span class="line">console.log(d); &#x2F;&#x2F;n</span><br><span class="line">console.log(e); &#x2F;&#x2F;g</span><br></pre></td></tr></table></figure>

<h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add([x, y])&#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<h3 id="经常用到的功能"><a href="#经常用到的功能" class="headerlink" title="经常用到的功能"></a>经常用到的功能</h3><h4 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h4><blockquote>
<p>这个是我挺喜欢的一个功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x &#x3D; 1;</span><br><span class="line">let y &#x3D; 2;</span><br><span class="line"></span><br><span class="line">[x, y] &#x3D; [y, x];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
</blockquote>
<h4 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回一个数组</span><br><span class="line">function example() &#123;</span><br><span class="line">  return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">let [a, b, c] &#x3D; example();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回一个对象</span><br><span class="line">function example() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let &#123; foo, bar &#125; &#x3D; example();</span><br></pre></td></tr></table></figure>

<h4 id="提取-JSON-数据"><a href="#提取-JSON-数据" class="headerlink" title="提取 JSON 数据"></a>提取 JSON 数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let jsonData &#x3D; &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: &quot;OK&quot;,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, status, data: number &#125; &#x3D; jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">&#x2F;&#x2F; 42, &quot;OK&quot;, [867, 5309]</span><br></pre></td></tr></table></figure>

<h3 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="输入模块的指定方法"></a>输入模块的指定方法</h3><p>这个也是经常用到的</p>
<p><code>const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code></p>
<p>以上就是我对ECMAScript 6解构赋值的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 扩展运算符</title>
    <url>/2018/12/07/71-ES6%20%E8%BF%90%E7%AE%97%E7%AC%A6%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>扩展运算符和rest运算符是ES6新推出的,大家可能比较陌生,本来我是打算放在数组扩展里面一起讲的,但是觉得他们挺好用也挺重要的,所以就提前拿出来单独分享一下</p>
</blockquote>
<a id="more"></a>

<p>文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界…</p>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符（spread）是三个点（…），将一个数组转为分隔的参数序列。</p>
<p>举一个简单的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3]</span><br><span class="line">console.log(...arr) &#x2F;&#x2F; 1 2 3</span><br><span class="line"></span><br><span class="line">function add(x,y,z)&#123;</span><br><span class="line">  return x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(...arr) &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用，否则就会报错。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(...[1,2]) &#x2F;&#x2F; 报错</span><br><span class="line"></span><br><span class="line">console.log((...[1,2])) &#x2F;&#x2F; 报错</span><br><span class="line"></span><br><span class="line">console.log(...[1,2]) &#x2F;&#x2F; 不会报错,因为这时是函数调用。</span><br></pre></td></tr></table></figure>

<p>接下来讲一下扩展运算符的基本用法</p>
<h3 id="代替apply方法"><a href="#代替apply方法" class="headerlink" title="代替apply方法"></a>代替apply方法</h3><p>举一个求数组中最大值的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5 的写法</span><br><span class="line">Math.max.apply(null, [14, 3, 77])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 的写法</span><br><span class="line">Math.max(...[14, 3, 77])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不明白apply用法的可以看我之前的博客,<a href="https://www.chensheng.group/2016/09/15/03-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/">原型与原型链</a>,这篇文章有讲到apply的用法</p>
</blockquote>
<h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><p>我们之前复制数组的时候,用的是深拷贝和浅拷贝,这里我就不再说什么是深拷贝了,来看看ES6怎么复制数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a1 &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">let a2 &#x3D; [...a1]; &#x2F;&#x2F; 写法一</span><br><span class="line"></span><br><span class="line">let [...a2] &#x3D; a1; &#x2F;&#x2F; 写法二</span><br></pre></td></tr></table></figure>

<h3 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr1 &#x3D; [&#123;cs:&#39;123&#39;&#125;, &#39;b&#39;];</span><br><span class="line">let arr2 &#x3D; [&#39;c&#39;];</span><br><span class="line">let arr3 &#x3D; [&#39;d&#39;, &#39;e&#39;];</span><br><span class="line"></span><br><span class="line">let arr4 &#x3D; [...arr1, ...arr2, ...arr3]</span><br><span class="line"></span><br><span class="line">arr1[0].cs &#x3D; &#39;csing&#39;</span><br><span class="line"></span><br><span class="line">console.log(arr4) &#x2F;&#x2F; [ &#123;cs:&#39;csing&#39;&#125;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意!!! 这种方法是浅拷贝,这个坑需要注意一下</p>
</blockquote>
<h2 id="rest运算符"><a href="#rest运算符" class="headerlink" title="rest运算符"></a>rest运算符</h2><p>rest运算符也是用…(三个点)来表示,甚至很多时候你不用特意去区分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(one,...rest)&#123;</span><br><span class="line">  console.log(rest) &#x2F;&#x2F; [2,3,4,5,6]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1,2,3,4,5,6)</span><br></pre></td></tr></table></figure>

<p>这样写的好处在于,当你不知道函数会传进来几个参数的时候,…rest可以全部接受后转为数组</p>
<h3 id="与解构赋值结合"><a href="#与解构赋值结合" class="headerlink" title="与解构赋值结合"></a>与解构赋值结合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [first, ...rest] &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">first &#x2F;&#x2F; 1</span><br><span class="line">rest  &#x2F;&#x2F; [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const [first, ...rest] &#x3D; [];</span><br><span class="line">first &#x2F;&#x2F; undefined</span><br><span class="line">rest  &#x2F;&#x2F; []</span><br><span class="line"></span><br><span class="line">const [first, ...rest] &#x3D; [&quot;foo&quot;];</span><br><span class="line">first  &#x2F;&#x2F; &quot;foo&quot;</span><br><span class="line">rest   &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是,如果将扩展运算符用于数组赋值,只能放在参数的最后一位,否则会报错。</p>
</blockquote>
<p>以上就是我对ECMAScript 6运算符扩展的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 字符串的扩展</title>
    <url>/2018/12/08/72-ES6%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>ES6 提供了许多对字符串的方法,让我们一起学习一下</p>
</blockquote>
<a id="more"></a>

<p>文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界…</p>
<p>字符串的方法新增了很多种,我挑几个我认为常用的来分享</p>
<h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>别的先不说,先来看一下字符串模板,是我认为的都ES6中比较好用的一个功能了</p>
<p>我们之前拼接字符串的时候 都是用”+”号,并且拼接的时候还不能换行,容易出错.ES6引入了字符串模板 ``,解决了这一个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let key &#x3D; &#39;chensheng&#39;</span><br><span class="line">let a &#x3D; 1</span><br><span class="line">let b &#x3D; 2</span><br><span class="line"></span><br><span class="line">function fn() &#123;</span><br><span class="line">  return &quot;Hello World&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; trim()可以去掉 &#96;&#96;前后的空格</span><br><span class="line">let htmlMsg &#x3D; &#96;&lt;b&gt;我是$&#123;key&#125;&lt;&#x2F;b&gt;,输出$&#123;1+2&#125;,$&#123;fn()&#125;&#96;.trim()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符串不仅可以换行,还可以进行简单的运算,调用函数,使用el表达式可以将参数添加到字符串当中</p>
</blockquote>
<h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &#39;Hello world!&#39;;</span><br><span class="line"></span><br><span class="line">str.startsWith(&#39;Hello&#39;) &#x2F;&#x2F; true</span><br><span class="line">str.endsWith(&#39;!&#39;) &#x2F;&#x2F; true</span><br><span class="line">str.includes(&#39;o&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相比较已经用indexOf,includes将代码更简洁化了</p>
</blockquote>
<h2 id="复制字符串"><a href="#复制字符串" class="headerlink" title="复制字符串"></a>复制字符串</h2><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<p>使用起来也是很简单,具体什么时候用,还是看项目需求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;x&#39;.repeat(3) &#x2F;&#x2F; &quot;xxx&quot;</span><br><span class="line">&#39;hello&#39;.repeat(2) &#x2F;&#x2F; &quot;hellohello&quot;</span><br><span class="line">&#39;na&#39;.repeat(0) &#x2F;&#x2F; &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>有几个地方需要注意一下的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 参数如果是小数，会被取整。</span><br><span class="line">&#39;na&#39;.repeat(2.9) &#x2F;&#x2F; &quot;nana&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果repeat的参数是负数会报错。</span><br><span class="line">&#39;na&#39;.repeat(-1) &#x2F;&#x2F; 报错</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</span><br><span class="line">&#39;na&#39;.repeat(-0.9) &#x2F;&#x2F; &quot;&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 参数NaN等同于 0。</span><br><span class="line">&#39;na&#39;.repeat(NaN) &#x2F;&#x2F; &quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="字符串补全"><a href="#字符串补全" class="headerlink" title="字符串补全"></a>字符串补全</h2><p>如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</span><br><span class="line"></span><br><span class="line">&#39;x&#39;.padStart(5, &#39;ab&#39;) &#x2F;&#x2F; &#39;ababx&#39;</span><br><span class="line">&#39;x&#39;.padStart(4, &#39;ab&#39;) &#x2F;&#x2F; &#39;abax&#39;</span><br><span class="line"></span><br><span class="line">&#39;x&#39;.padEnd(5, &#39;ab&#39;) &#x2F;&#x2F; &#39;xabab&#39;</span><br><span class="line">&#39;x&#39;.padEnd(4, &#39;ab&#39;) &#x2F;&#x2F; &#39;xaba&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果省略第二个参数，默认使用空格补全长度。</span><br><span class="line">&#39;x&#39;.padStart(4) &#x2F;&#x2F; &#39;   x&#39;</span><br><span class="line">&#39;x&#39;.padEnd(4) &#x2F;&#x2F; &#39;x   &#39;</span><br></pre></td></tr></table></figure>




<p>以上就是我对ECMAScript 6字符串扩展的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 数值的扩展</title>
    <url>/2018/12/12/73-ES6%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>ES6将数值的许多操作都封装了起来,相比较ES5,规范了许多,提供了更为简洁的最大安全值</p>
</blockquote>
<a id="more"></a>

<p>文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界…</p>
<h2 id="二进制与八进制"><a href="#二进制与八进制" class="headerlink" title="二进制与八进制"></a>二进制与八进制</h2><p>这个其实不算是ES6的语法,只是ES6规范了写法,顺便提一下</p>
<blockquote>
<p>二进制声明：二进制的英文单词是Binary,二进制的开始是0（零），然后第二个位置是b（注意这里大小写都可以实现），然后跟上二进制的值就可以了。</p>
</blockquote>
<blockquote>
<p>八进制声明：八进制的英文单词是Octal，也是以0（零）开始的，然后第二个位置是O（欧），然后跟上八进制的值就可以了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二进制声明Binary</span><br><span class="line">let binary &#x3D; 0B010101</span><br><span class="line">console.log(binary)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 八进制声明Octal</span><br><span class="line">let octal &#x3D; 0O777</span><br><span class="line">console.log(octal)</span><br></pre></td></tr></table></figure>

<h2 id="判断数值"><a href="#判断数值" class="headerlink" title="判断数值"></a>判断数值</h2><blockquote>
<p>使用Number.isFinite()来进行数字验证，只要是数字，不论是浮点型还是整形都会返回true，其他时候会返回false。</p>
</blockquote>
<p>阮一峰老师是这样解释的: Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。<br>需要注意,这里的无限指的不是无限循环的小数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果参数类型不是数值，Number.isFinite一律返回false。</span><br><span class="line">Number.isFinite(10&#x2F;3) &#x2F;&#x2F; true</span><br><span class="line">Number.isFinite(NaN); &#x2F;&#x2F; false</span><br><span class="line">Number.isFinite(Infinity); &#x2F;&#x2F; false</span><br><span class="line">Number.isFinite(-Infinity); &#x2F;&#x2F; false</span><br><span class="line">Number.isFinite(&#39;foo&#39;); &#x2F;&#x2F; false</span><br><span class="line">Number.isFinite(&#39;15&#39;); &#x2F;&#x2F; false</span><br><span class="line">Number.isFinite(true); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Number.isNaN()用来检查一个值是否为NaN。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果参数类型不是NaN，Number.isNaN一律返回false。</span><br><span class="line">Number.isNaN(NaN) &#x2F;&#x2F; true</span><br><span class="line">Number.isNaN(15) &#x2F;&#x2F; false</span><br><span class="line">Number.isNaN(&#39;15&#39;) &#x2F;&#x2F; false</span><br><span class="line">Number.isNaN(true) &#x2F;&#x2F; false</span><br><span class="line">Number.isNaN(9&#x2F;NaN) &#x2F;&#x2F; true</span><br><span class="line">Number.isNaN(&#39;true&#39; &#x2F; 0) &#x2F;&#x2F; true</span><br><span class="line">Number.isNaN(&#39;true&#39; &#x2F; &#39;true&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意!!! isFinite() 和 Number.isFinite() 是不一样的,前者是先将非数值的转为数值,再进行判断</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isFinite(25) &#x2F;&#x2F; true</span><br><span class="line">isFinite(&quot;25&quot;) &#x2F;&#x2F; true</span><br><span class="line">Number.isFinite(25) &#x2F;&#x2F; true</span><br><span class="line">Number.isFinite(&quot;25&quot;) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Number.isInteger()用来判断一个数值是否为整数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number.isInteger(25) &#x2F;&#x2F; true</span><br><span class="line">Number.isInteger(25.1) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><p>和ES5的区别不大,只是移植到Number对象上面,逐步减少全局性方法，使得语言逐步模块化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES6的写法</span><br><span class="line">Number.parseInt(&#39;12.34&#39;) &#x2F;&#x2F; 12</span><br><span class="line">Number.parseFloat(&#39;123.45#&#39;) &#x2F;&#x2F; 123.45</span><br></pre></td></tr></table></figure>

<h2 id="最小进度"><a href="#最小进度" class="headerlink" title="最小进度"></a>最小进度</h2><p>Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
<p>这也是javaScript上经典的 0.1 + 0.2 === 0.3 //false 的原因了</p>
<p>写个代码解释一下..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.1 + 0.2</span><br><span class="line">&#x2F;&#x2F; 0.30000000000000004</span><br><span class="line"></span><br><span class="line">0.1 + 0.2 - 0.3</span><br><span class="line">&#x2F;&#x2F; 5.551115123125783e-17</span><br><span class="line"></span><br><span class="line">5.551115123125783e-17.toFixed(20)</span><br><span class="line">&#x2F;&#x2F; &#39;0.00000000000000005551&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function withinErrorMargin (left, right) &#123;</span><br><span class="line">  return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 &#x2F;&#x2F; false</span><br><span class="line">withinErrorMargin(0.1 + 0.2, 0.3) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">1.1 + 1.3 &#x3D;&#x3D;&#x3D; 2.4 &#x2F;&#x2F; false</span><br><span class="line">withinErrorMargin(1.1 + 1.3, 2.4) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h2 id="安全整数"><a href="#安全整数" class="headerlink" title="安全整数"></a>安全整数</h2><p>整数的操作是有一个取值范围的，它的取值范围就是2的53次方。,ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</p>
<p><code>Math.pow(2, 53) // 9007199254740992</code></p>
<blockquote>
<p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number.isSafeInteger(9007199254740990) &#x2F;&#x2F; true</span><br><span class="line">Number.isSafeInteger(9007199254740992) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><blockquote>
<p>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</p>
</blockquote>
<p>这不是四舍五入 !!!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.trunc(4.1) &#x2F;&#x2F; 4</span><br><span class="line">Math.trunc(4.9) &#x2F;&#x2F; 4</span><br><span class="line">Math.trunc(-4.1) &#x2F;&#x2F; -4</span><br><span class="line">Math.trunc(-4.9) &#x2F;&#x2F; -4</span><br><span class="line">Math.trunc(-0.1234) &#x2F;&#x2F; -0</span><br></pre></td></tr></table></figure>

<p>对于非数值，Math.trunc内部使用Number方法将其先转为数值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.trunc(&#39;123.456&#39;) &#x2F;&#x2F; 123</span><br><span class="line">Math.trunc(true) &#x2F;&#x2F;1</span><br><span class="line">Math.trunc(false) &#x2F;&#x2F; 0</span><br><span class="line">Math.trunc(null) &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<p>对于空值和无法截取整数的值，返回NaN。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.trunc(NaN);      &#x2F;&#x2F; NaN</span><br><span class="line">Math.trunc(&#39;foo&#39;);    &#x2F;&#x2F; NaN</span><br><span class="line">Math.trunc();         &#x2F;&#x2F; NaN</span><br><span class="line">Math.trunc(undefined) &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<h2 id="判断正负"><a href="#判断正负" class="headerlink" title="判断正负"></a>判断正负</h2><blockquote>
<p>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.sign(-5) &#x2F;&#x2F; -1</span><br><span class="line">Math.sign(5) &#x2F;&#x2F; +1</span><br><span class="line">Math.sign(0) &#x2F;&#x2F; +0</span><br><span class="line">Math.sign(-0) &#x2F;&#x2F; -0</span><br><span class="line">Math.sign(NaN) &#x2F;&#x2F; NaN</span><br><span class="line">Math.sign(&#39;&#39;)  &#x2F;&#x2F; 0</span><br><span class="line">Math.sign(true)  &#x2F;&#x2F; +1</span><br><span class="line">Math.sign(false)  &#x2F;&#x2F; 0</span><br><span class="line">Math.sign(null)  &#x2F;&#x2F; 0</span><br><span class="line">Math.sign(&#39;9&#39;)  &#x2F;&#x2F; +1</span><br><span class="line">Math.sign(&#39;foo&#39;)  &#x2F;&#x2F; NaN</span><br><span class="line">Math.sign()  &#x2F;&#x2F; NaN</span><br><span class="line">Math.sign(undefined)  &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h2><blockquote>
<p>ES2016 新增了一个指数运算符（**）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 ** 2 &#x2F;&#x2F; 4</span><br><span class="line">2 ** 3 &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure>

<p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 相当于 2 * * (3 * * 2)</span><br><span class="line">2 * * 3 * * 2</span><br><span class="line">&#x2F;&#x2F; 512</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，V8 引擎的指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。</p>
</blockquote>
<p>以上就是我对ECMAScript 6数值扩展的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Storage监听</title>
    <url>/2018/12/20/74-Web%20Storage%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>项目中有一个需求，需要在两个页面进行传值操作并实时更新，想到了用Storage，原理就不解释了，直接上代码</p>
</blockquote>
<a id="more"></a>

<h2 id="实时监听的页面"><a href="#实时监听的页面" class="headerlink" title="实时监听的页面"></a>实时监听的页面</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;利用storage事件实时监视Web Storage中的数据&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">      &#x2F;&#x2F;利用storage事件实时监视wev Storage中的数据</span><br><span class="line">      window.addEventListener(&#39;storage&#39;, function(e) &#123; &#x2F;&#x2F;e只是一个传参</span><br><span class="line">        console.log(e)</span><br><span class="line">        &#x2F;&#x2F;获取被修改的键值</span><br><span class="line">        if(e.key &#x3D;&#x3D; &#39;test&#39;) &#123;</span><br><span class="line">          &#x2F;&#x2F;获取将要被添加内容的元素</span><br><span class="line">          var output &#x3D; document.getElementById(&#39;output&#39;);</span><br><span class="line">          &#x2F;&#x2F;将获取到的修改值在元素中输出</span><br><span class="line">          output.innerHTML &#x3D; &#39;原有值：&#39; + e.oldValue;</span><br><span class="line">          output.innerHTML +&#x3D; &#39;&lt;br &#x2F;&gt;新值:&#39; + e.newValue;</span><br><span class="line">          output.innerHTML +&#x3D; &#39;&lt;br &#x2F;&gt;变动页面地址：&#39; + e.url;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;分别打印会发现内容一致</span><br><span class="line">          console.log(e.storageArea);</span><br><span class="line">          console.log(localStorage);</span><br><span class="line">          &#x2F;&#x2F;此行代码只在Chrome浏览器中有效</span><br><span class="line">          console.log(e.storageArea &#x3D;&#x3D;&#x3D; localStorage); &#x2F;&#x2F;输出true</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, false);</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;output id&#x3D;&quot;output&quot;&gt;&lt;&#x2F;output&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="被监听的代码"><a href="#被监听的代码" class="headerlink" title="被监听的代码"></a>被监听的代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;用于修改localStorage 中数据的页面的代码&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;span&gt;请输入一些值：&lt;&#x2F;span&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;text1&quot; &#x2F;&gt;</span><br><span class="line">    &lt;button onclick&#x3D;&quot;setLOcalStorage()&quot;&gt;设置&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    function setLOcalStorage() &#123;</span><br><span class="line">      localStorage.clear();</span><br><span class="line">      &#x2F;&#x2F;设置test键值下的内容等于input框中的内容</span><br><span class="line">      localStorage.test &#x3D; document.getElementById(&#39;text1&#39;).value;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 函数的扩展</title>
    <url>/2018/12/25/75-ES6%20%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>ES6中,函数新增了几个功能,特别是箭头函数和参数默认值,在实际项目中经常用到</p>
</blockquote>
<a id="more"></a>

<p>文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界…</p>
<h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>简单来说,就是在函数的形参中可以添加默认值了,举个例子看了就明白了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a &#x3D; 1)&#123;</span><br><span class="line">  var num &#x3D; 1 + a;</span><br><span class="line">  console.log(num)</span><br><span class="line">&#125;</span><br><span class="line">add()  &#x2F;&#x2F; 2</span><br><span class="line">add(5) &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure>

<p>没有数值的时候就使用默认值,使用起来便于优化,代码一目了然.</p>
<blockquote>
<p>需要注意的是,这个形参是函数默认声明的,在函数体中，不能用let或const再次声明，否则会报错。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  function foo(x &#x3D; 5) &#123;</span><br><span class="line">  let x &#x3D; 1; &#x2F;&#x2F; error</span><br><span class="line">  const x &#x3D; 2; &#x2F;&#x2F; error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用参数默认值时，函数不能有同名参数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不报错</span><br><span class="line">function foo(x, x, y) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">function foo(x, x, y &#x3D; 1) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意!!!!参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x &#x3D; 99;</span><br><span class="line">function foo(p &#x3D; x + 1) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() &#x2F;&#x2F; 100</span><br><span class="line"></span><br><span class="line">x &#x3D; 100;</span><br><span class="line">foo() &#x2F;&#x2F; 101</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(x &#x3D; 5, y &#x3D; 6) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(undefined, null) &#x2F;&#x2F; 5 null</span><br></pre></td></tr></table></figure>

<h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(&#123;x, y &#x3D; 5&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 个人的理解是类似于参数为一个对象,所以需要传入一个对象</span><br><span class="line">&#x2F;&#x2F; 就算x是有值的,也会报错,假如参数是 &#123;x &#x3D; 2, y &#x3D; 5&#125;,不传&#123;&#125;一样是会报错的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) &#x2F;&#x2F; undefined 5</span><br><span class="line">foo(&#123;x: 1&#125;) &#x2F;&#x2F; 1 5</span><br><span class="line">foo(&#123;x: 1, y: 2&#125;) &#x2F;&#x2F; 1 2</span><br><span class="line">foo() &#x2F;&#x2F; TypeError: Cannot read property &#39;x&#39; of undefined</span><br></pre></td></tr></table></figure>

<p>但是通过提供函数参数的默认值，就可以避免这种情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(&#123;x, y &#x3D; 5&#125; &#x3D; &#123;&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() &#x2F;&#x2F; undefined 5</span><br></pre></td></tr></table></figure>

<p>再来看一个例子,来弄清楚函数形参中的解构赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">function m1(&#123;x &#x3D; 0, y &#x3D; 0&#125; &#x3D; &#123;&#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">function m2(&#123;x, y&#125; &#x3D; &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数没有参数的情况</span><br><span class="line">m1() &#x2F;&#x2F; [0, 0]</span><br><span class="line">m2() &#x2F;&#x2F; [0, 0]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; x 和 y 都有值的情况</span><br><span class="line">m1(&#123;x: 3, y: 8&#125;) &#x2F;&#x2F; [3, 8]</span><br><span class="line">m2(&#123;x: 3, y: 8&#125;) &#x2F;&#x2F; [3, 8]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; x 有值，y 无值的情况</span><br><span class="line">m1(&#123;x: 3&#125;) &#x2F;&#x2F; [3, 0]</span><br><span class="line">m2(&#123;x: 3&#125;) &#x2F;&#x2F; [3, undefined]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; x 和 y 都无值的情况</span><br><span class="line">m1(&#123;&#125;) &#x2F;&#x2F; [0, 0];</span><br><span class="line">m2(&#123;&#125;) &#x2F;&#x2F; [undefined, undefined]</span><br><span class="line"></span><br><span class="line">m1(&#123;z: 3&#125;) &#x2F;&#x2F; [0, 0]</span><br><span class="line">m2(&#123;z: 3&#125;) &#x2F;&#x2F; [undefined, undefined]</span><br></pre></td></tr></table></figure>

<h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<p>举几个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 例一</span><br><span class="line">function f(x &#x3D; 1, y) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() &#x2F;&#x2F; [1, undefined]</span><br><span class="line">f(2) &#x2F;&#x2F; [2, undefined])</span><br><span class="line">f(, 1) &#x2F;&#x2F; 报错</span><br><span class="line">f(undefined, 1) &#x2F;&#x2F; [1, 1]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例二</span><br><span class="line">function f(x, y &#x3D; 5, z) &#123;</span><br><span class="line">  return [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() &#x2F;&#x2F; [undefined, 5, undefined]</span><br><span class="line">f(1) &#x2F;&#x2F; [1, 5, undefined]</span><br><span class="line">f(1, ,2) &#x2F;&#x2F; 报错</span><br><span class="line">f(1, undefined, 2) &#x2F;&#x2F; [1, 5, 2]</span><br></pre></td></tr></table></figure>

<h3 id="函数参数的-length-属性"><a href="#函数参数的-length-属性" class="headerlink" title="函数参数的 length 属性"></a>函数参数的 length 属性</h3><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function (a) &#123;&#125;).length &#x2F;&#x2F; 1</span><br><span class="line">(function (a &#x3D; 5) &#123;&#125;).length &#x2F;&#x2F; 0</span><br><span class="line">(function (a, b, c &#x3D; 5) &#123;&#125;).length &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throwIfMissing() &#123;</span><br><span class="line">  throw new Error(&#39;Missing parameter&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(mustBeProvided &#x3D; throwIfMissing()) &#123;</span><br><span class="line">  return mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">&#x2F;&#x2F; Error: Missing parameter</span><br></pre></td></tr></table></figure>

<p>另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。</p>
<p><code>function foo(optional = undefined) { ··· }</code></p>
<h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><p>不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。也可以用到当做函数的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(...values) &#123;</span><br><span class="line">  let sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  for (var val of values) &#123;</span><br><span class="line">    sum +&#x3D; val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 3) &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意!! 函数的length属性，不包括 rest 参数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(a) &#123;&#125;).length  &#x2F;&#x2F; 1</span><br><span class="line">(function(...a) &#123;&#125;).length  &#x2F;&#x2F; 0</span><br><span class="line">(function(a, ...b) &#123;&#125;).length  &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>这个是我认为这次ES6最好用的功能之一, 如果你会C#或者Java，你肯定知道lambda表达式，ES6中新增的箭头操作符=&gt;便有异曲同工之妙。它简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。最直观体现在函数中的this指向不同,箭头函数的this指向上下文</p>
<p>代码我就不贴出来了,就是简单的 =&gt; ,说一下注意点</p>
<ol>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li>
</ol>
<p>比较容易出错的应该就是第一点了,举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Timer() &#123;</span><br><span class="line">  this.s1 &#x3D; 0;</span><br><span class="line">  this.s2 &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; 箭头函数</span><br><span class="line">  setInterval(() &#x3D;&gt; this.s1++, 1000);</span><br><span class="line">  &#x2F;&#x2F; 普通函数</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    this.s2++;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var timer &#x3D; new Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; console.log(&#39;s1: &#39;, timer.s1), 3100);</span><br><span class="line">setTimeout(() &#x3D;&gt; console.log(&#39;s2: &#39;, timer.s2), 3100);</span><br><span class="line">&#x2F;&#x2F; s1: 3</span><br><span class="line">&#x2F;&#x2F; s2: 0</span><br></pre></td></tr></table></figure>

<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>平常的递归是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n)</span><br><span class="line"></span><br><span class="line">function factorial(n) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D;&#x3D; 1) return 1;</span><br><span class="line">  return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) &#x2F;&#x2F; 120</span><br></pre></td></tr></table></figure>

<p>尾递归是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 只保留一个调用记录，复杂度 O(1) 。</span><br><span class="line"></span><br><span class="line">function factorial(n, total &#x3D; 1) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D;&#x3D; 1) return total;</span><br><span class="line">  return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) &#x2F;&#x2F; 120</span><br></pre></td></tr></table></figure>


<p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p>
<p>简单的介绍一下Fibonacci 数列</p>
<p>斐波那契数列 外文名 Fibonacci sequence<br>别称  黄金分割数列、兔子数列</p>
<p>指的是这样一个数列：1、1、2、3、5、8、13、21、34、……<br>在数学上，斐波纳契数列以如下被以递归的方法定义：<br>F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）</p>
<p>index:0  1 2 3 4 5 6 7 8 9 10<br>value:0  1 1 2 3 5 8 13 21 34 55</p>
<p>最简单是这样写的,就是算多的时候,就开始卡主了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Fibonacci (n) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D;2) &#123;return 1&#125;;</span><br><span class="line"></span><br><span class="line">  return Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以前是这样优化的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ary &#x3D; &#123;&#125;;</span><br><span class="line">var count &#x3D; 0;</span><br><span class="line">function fibonacci(t) &#123;</span><br><span class="line">  count++</span><br><span class="line">  if(ary[t]) &#123;</span><br><span class="line">    return ary[t]</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if(t &gt; 2) &#123;</span><br><span class="line">      var index &#x3D; fibonacci(t - 1) + fibonacci(t - 2);</span><br><span class="line">      ary[t] &#x3D; index;</span><br><span class="line">      return index;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ary[t] &#x3D; 1</span><br><span class="line">      return 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用尾递归的方式,就是这样子的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Fibonacci2 (n , ac1 &#x3D; 1 , ac2 &#x3D; 1) &#123;</span><br><span class="line">  if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D;2) &#123;return ac2&#125;;</span><br><span class="line">  return Fibonacci2 (n - 1, ac2, ac1 + ac2);</span><br><span class="line">  &#x2F;&#x2F; 当前所剩次数,当前值,下一个值</span><br><span class="line">  &#x2F;&#x2F; 所以当n为1或者2的时候,输出ac2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上就是我对ECMAScript 6函数扩展的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 数组的扩展</title>
    <url>/2018/12/26/76-ES6%20%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>数组是每天都要接触的东西,ES6添加的语法更是方便了许多,主要的运算符扩展我已经单独分一章了,接下来聊聊数组的其他语法糖</p>
</blockquote>
<a id="more"></a>

<p>文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界…</p>
<h2 id="数组转化"><a href="#数组转化" class="headerlink" title="数组转化"></a>数组转化</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><blockquote>
<p>Array.from方法用于将类对象转为真正的数组,所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let  json &#x3D; &#123;</span><br><span class="line">  &#39;0&#39;: &#39;a&#39;,</span><br><span class="line">  &#39;1&#39;: &#39;b&#39;,</span><br><span class="line">  &#39;2&#39;: &#39;c&#39;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 转化为arr</span><br><span class="line">let arr &#x3D; Array.from(json);</span><br></pre></td></tr></table></figure>

<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.from([1, 2, 3], (x) &#x3D;&gt; x * x)</span><br><span class="line">&#x2F;&#x2F; [1, 4, 9]</span><br><span class="line"></span><br><span class="line">Array.from([1, , 2, , 3], (n) &#x3D;&gt; n || 0)</span><br><span class="line">&#x2F;&#x2F; [1, 0, 2, 0, 3]</span><br></pre></td></tr></table></figure>

<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><blockquote>
<p>Array.of方法用于将一组值，转换为数组。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.of(3, 11, 8) &#x2F;&#x2F; [3,11,8]</span><br><span class="line">Array.of(3) &#x2F;&#x2F; [3]</span><br><span class="line">Array.of(3).length &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<h2 id="数组查找"><a href="#数组查找" class="headerlink" title="数组查找"></a>数组查找</h2><blockquote>
<p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 5, 10, 15].find(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">&#125;) &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>

<h2 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h2><blockquote>
<p>fill方法使用给定值，填充一个数组。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)</span><br><span class="line">&#x2F;&#x2F;[&#39;a&#39;, 7, &#39;c&#39;]</span><br></pre></td></tr></table></figure>

<h2 id="数组实例的-entries-，keys-和-values"><a href="#数组实例的-entries-，keys-和-values" class="headerlink" title="数组实例的 entries()，keys() 和 values()"></a>数组实例的 entries()，keys() 和 values()</h2><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let ary &#x3D; [&#39;a&#39;, &#39;b&#39;]</span><br><span class="line"></span><br><span class="line">for (let index of ary.keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">  &#x2F;&#x2F; 0</span><br><span class="line">  &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let elem of ary.values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">  &#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">  &#x2F;&#x2F; &#39;b&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of ary.entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">  &#x2F;&#x2F; 0 &quot;a&quot;</span><br><span class="line">  &#x2F;&#x2F; 1 &quot;b&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>entries()实例方式生成的是Iterator形式的数组，那这种形式的好处就是可以让我们在需要时用next()手动跳转到下一个值。举一个例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let letter &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line">let entries &#x3D; letter.entries();</span><br><span class="line">console.log(entries.next().value); &#x2F;&#x2F; [0, &#39;a&#39;]</span><br><span class="line">console.log(entries.next().value); &#x2F;&#x2F; [1, &#39;b&#39;]</span><br><span class="line">console.log(entries.next().value); &#x2F;&#x2F; [2, &#39;c&#39;]</span><br></pre></td></tr></table></figure>

<h2 id="数组实例的-includes-—-包含"><a href="#数组实例的-includes-—-包含" class="headerlink" title="数组实例的 includes()—-包含"></a>数组实例的 includes()—-包含</h2><blockquote>
<p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3].includes(2) &#x2F;&#x2F; true</span><br><span class="line">[1, 2, 3].includes(4) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3].includes(3, 3);  &#x2F;&#x2F; false</span><br><span class="line">[1, 2, 3].includes(3, -1); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h2 id="数组实例的-flat-，flatMap"><a href="#数组实例的-flat-，flatMap" class="headerlink" title="数组实例的 flat()，flatMap()"></a>数组实例的 flat()，flatMap()</h2><blockquote>
<p>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, [3, [4, 5]]].flat()</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, [4, 5]]</span><br><span class="line"></span><br><span class="line">[1, 2, [3, [4, 5]]].flat(2)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</span><br><span class="line">[1, [2, [3]]].flat(Infinity)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果原数组有空位，flat()方法会跳过空位。</span><br><span class="line">[1, 2, , 4, 5].flat()</span><br><span class="line">&#x2F;&#x2F; [1, 2, 4, 5]</span><br></pre></td></tr></table></figure>

<h3 id="数组空位"><a href="#数组空位" class="headerlink" title="数组空位"></a>数组空位</h3><blockquote>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
</blockquote>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</li>
<li>map()会跳过空位，但会保留这个值</li>
<li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</li>
</ul>
<blockquote>
<p>ES6 则是明确将空位转为undefined。</p>
</blockquote>
<p>以上就是我对ECMAScript 6数组扩展的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 对象的扩展</title>
    <url>/2019/01/10/77-ES6%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>对象是我们再熟悉不过的了,ES6新增了一些对象的语法糖,使我们操作对象变得更加的简洁了</p>
</blockquote>
<a id="more"></a>

<p>文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界…</p>
<p>对象中的扩展运算符就不再说了,说一下其他的</p>
<h2 id="对象赋值"><a href="#对象赋值" class="headerlink" title="对象赋值"></a>对象赋值</h2><h3 id="简洁表示法"><a href="#简洁表示法" class="headerlink" title="简洁表示法"></a>简洁表示法</h3><p>ES6使得对象的赋值更为的简洁了,举一个简单的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name&#x3D;&quot;csing&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">var obj&#x3D; &#123;name: name&#125;; &#x2F;&#x2F;Object &#123;name: &quot;csing&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">var obj&#x3D; &#123;name&#125;; &#x2F;&#x2F;Object &#123;name: &quot;csing&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><p>当对象的key值不明确的时候,ES6也提供了相应的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let key&#x3D;&#39;skill&#39;;</span><br><span class="line">var obj&#x3D;&#123;</span><br><span class="line">  [key]:&#39;web&#39;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.skill);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 允许字面量定义对象时，把表达式放在方括号内。</span><br><span class="line">&#x2F;&#x2F; 看一个稍微绕一点的</span><br><span class="line"></span><br><span class="line">let lastWord &#x3D; &#39;last word&#39;;</span><br><span class="line"></span><br><span class="line">const a &#x3D; &#123;</span><br><span class="line">  &#39;first word&#39;: &#39;hello&#39;,</span><br><span class="line">  [lastWord]: &#39;world&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[&#39;first word&#39;] &#x2F;&#x2F; &quot;hello&quot;</span><br><span class="line">a[lastWord] &#x2F;&#x2F; &quot;world&quot;</span><br><span class="line">a[&#39;last word&#39;] &#x2F;&#x2F; &quot;world&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">const foo &#x3D; &#39;bar&#39;;</span><br><span class="line">const bar &#x3D; &#39;abc&#39;;</span><br><span class="line">const baz &#x3D; &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">const foo &#x3D; &#39;bar&#39;;</span><br><span class="line">const baz &#x3D; &#123; [foo]: &#39;abc&#39;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const proto &#x3D; &#123;</span><br><span class="line">  foo: &#39;hello&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: &#39;world&#39;,</span><br><span class="line">  find() &#123;</span><br><span class="line">    return super.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">console.log( obj.find())&#x2F;&#x2F; &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F;true</span><br><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) &#x2F;&#x2F; false</span><br><span class="line">Object.is(NaN, NaN) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>


<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const target &#x3D; &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line">const source1 &#x3D; &#123; b: 2 &#125;;</span><br><span class="line">const source2 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target &#x2F;&#x2F; &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const target &#x3D; &#123; a: 1, b: 1 &#125;;</span><br><span class="line"></span><br><span class="line">const source1 &#x3D; &#123; b: 2, c: 2 &#125;;</span><br><span class="line">const source2 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target &#x2F;&#x2F; &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure>

<p>一说到对象的合并,有几点需要注意一下</p>
<ul>
<li><p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
</li>
<li><p>上面讲的,同名属性的替换</p>
</li>
<li><p>Object.assign只能进行值的复制</p>
</li>
<li><p>Object.assign可以用来处理数组，但是会把数组视为对象。举个例子吧</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.assign([1, 2, 3], [4, 5])</span><br><span class="line">&#x2F;&#x2F; [4, 5, 3]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; why?</span><br><span class="line">&#x2F;&#x2F; Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。</span><br></pre></td></tr></table></figure>

<h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123;keys, values, entries&#125; &#x3D; Object;</span><br><span class="line">let obj &#x3D; &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">for (let key of keys(obj)) &#123;</span><br><span class="line">  console.log(key); &#x2F;&#x2F; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let value of values(obj)) &#123;</span><br><span class="line">  console.log(value); &#x2F;&#x2F; 1, 2, 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of entries(obj)) &#123;</span><br><span class="line">  console.log([key, value]); &#x2F;&#x2F; [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是分享一些常用的对象操作,其他的希望大家可以再去深入研究</p>
<p>以上就是我对ECMAScript 6对象扩展的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 Symbol</title>
    <url>/2019/01/11/78-ES6%20Symbol/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>可能大家对Symbol很陌生,简单的来说,他就是新的原始数据类型,表示独一无二的值</p>
</blockquote>
<a id="more"></a>

<p>文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界…</p>
<h2 id="认识Symbol"><a href="#认识Symbol" class="headerlink" title="认识Symbol"></a>认识Symbol</h2><p>Symbol 值通过Symbol函数生成。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Symbol函数前不能使用new命令，否则会报错。</span><br><span class="line">let cs &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">typeof cs</span><br><span class="line">&#x2F;&#x2F; &quot;symbol&quot;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s1 &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">let s2 &#x3D; Symbol(&#39;bar&#39;);</span><br><span class="line"></span><br><span class="line">s1 &#x2F;&#x2F; Symbol(foo)</span><br><span class="line">s2 &#x2F;&#x2F; Symbol(bar)</span><br><span class="line"></span><br><span class="line">s1.toString() &#x2F;&#x2F; &quot;Symbol(foo)&quot;</span><br><span class="line">s2.toString() &#x2F;&#x2F; &quot;Symbol(bar)&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</span><br><span class="line">&#x2F;&#x2F; 所以值一样的时候,他们还是不相等的,只是一个描述</span><br></pre></td></tr></table></figure>

<h2 id="Symbol在对象中的应用"><a href="#Symbol在对象中的应用" class="headerlink" title="Symbol在对象中的应用"></a>Symbol在对象中的应用</h2><blockquote>
<p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">et mySymbol &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一种写法</span><br><span class="line">let a &#x3D; &#123;&#125;;</span><br><span class="line">a[mySymbol] &#x3D; &#39;Hello!&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二种写法</span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">  [mySymbol]: &#39;Hello!&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以上写法都得到同样结果</span><br><span class="line">a[mySymbol] &#x2F;&#x2F; &quot;Hello!&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Symbol对象元素的保护作用"><a href="#Symbol对象元素的保护作用" class="headerlink" title="Symbol对象元素的保护作用"></a>Symbol对象元素的保护作用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用Symbol来进行保护年龄。</span><br><span class="line">let obj&#x3D;&#123;name:&#39;jspang&#39;,skill:&#39;web&#39;&#125;;</span><br><span class="line">let age&#x3D;Symbol();</span><br><span class="line">obj[age]&#x3D;18;</span><br><span class="line">for (let item in obj)&#123;</span><br><span class="line">  console.log(obj[item]); &#x2F;&#x2F; 这里是看不到年龄的</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h2><blockquote>
<p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s1 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line">let s2 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">s1 &#x3D;&#x3D;&#x3D; s2 &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s1 &#x3D; Symbol.for(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s1) &#x2F;&#x2F; &quot;foo&quot;</span><br><span class="line"></span><br><span class="line">let s2 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s2) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>更多的Symbol相关的知识可以移步阮一峰老师的博客,我这里就不贴出来了</p>
<p>以上就是我对ECMAScript 6 Symbol的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 Proxy</title>
    <url>/2019/02/18/79-ES6%20Proxy/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>用过vue-cli的都配置过跨域处理,对Proxy应该也不陌生,准确的来说,Proxy 可以理解成,在目标对象之前架设一层“拦截”,外界对该对象的访问,都必须先通过这层拦截,因此提供了一种机制,可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理,用在这里表示由它来“代理”某些操作,可以译为“代理器”。</p>
</blockquote>
<a id="more"></a>

<p>文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界…</p>
<p>用new的方法对Proxy进行声明<code>new Proxy（{},{}）</code></p>
<p><code>var proxy = new Proxy(target, handler);</code></p>
<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<p>需要注意的是这里是两个花括号，第一个花括号就相当于我们方法的主体，后边的花括号就是Proxy代理处理区域，相当于我们写钩子函数的地方。</p>
<p>现在写两个例子作为比较</p>
<p>首先是我们最基础的创建对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj&#x3D;&#123;</span><br><span class="line">  add: function(val)&#123;</span><br><span class="line">    return val + 5;</span><br><span class="line">  &#125;,</span><br><span class="line">  name: &#39;I am csing&#39;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.add(5));</span><br><span class="line">console.log(obj.name);</span><br></pre></td></tr></table></figure>

<p>把上边的obj对象改成Proxy形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pro &#x3D; new Proxy(&#123;</span><br><span class="line">  add: function (val) &#123;</span><br><span class="line">    return val + 5;</span><br><span class="line">  &#125;,</span><br><span class="line">  name: &#39;I am csing&#39;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  get:function(target,key,property)&#123;</span><br><span class="line">    &#x2F;&#x2F; target：得到的目标值</span><br><span class="line">    &#x2F;&#x2F; key：目标的key值，相当于对象的属性</span><br><span class="line">    &#x2F;&#x2F; property：这个不太常用，用法还在研究中，还请大神指教。</span><br><span class="line"></span><br><span class="line">    console.log(&#39;come in Get&#39;);</span><br><span class="line">    return target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set:function(target,key,value,receiver)&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; target:目标值。</span><br><span class="line">    &#x2F;&#x2F; key：目标的Key值。</span><br><span class="line">    &#x2F;&#x2F; value：要改变的值。</span><br><span class="line">    &#x2F;&#x2F; receiver：改变前的原始值。</span><br><span class="line"></span><br><span class="line">    console.log(&#96;setting $&#123;key&#125; &#x3D; $&#123;value&#125;&#96;);</span><br><span class="line">    return target[key] &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(pro.name);</span><br><span class="line">&#x2F;&#x2F; 可以在控制台看到结果，先输出了come in Get。相当于在方法调用前的钩子函数。</span><br></pre></td></tr></table></figure>

<p>刚刚已经说过了,前面的一个花括号是方法的主题,后面一个是处理区域,区域中有13中属性,有两个属性是最常用的,get属性和set属性,理解起来也很容易</p>
<ul>
<li><p>get属性是在你得到某对象属性值时预处理的方法，他接受三个参数</p>
<ul>
<li>target：得到的目标值</li>
<li>key：目标的key值，相当于对象的属性</li>
<li>property：这个不太常用，用法还在研究中，还请大神指教。</li>
</ul>
</li>
<li><p>set属性是值你要改变Proxy属性值时，进行的预先处理。它接收四个参数。</p>
<ul>
<li>target:目标值。</li>
<li>key：目标的Key值。</li>
<li>value：要改变的值。</li>
<li>receiver：改变前的原始值。</li>
</ul>
</li>
</ul>
<p>这里先介绍两种最经常用的,多了我也记不住</p>
<p>这因为Proxy的特性,所以它很合适用来写 Web 服务的客户端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const service &#x3D; createWebService(&#39;http:&#x2F;&#x2F;example.com&#x2F;data&#39;);</span><br><span class="line"></span><br><span class="line">service.employees().then(json &#x3D;&gt; &#123;</span><br><span class="line">  const employees &#x3D; JSON.parse(json);</span><br><span class="line">  &#x2F;&#x2F; ···</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createWebService(baseUrl) &#123;</span><br><span class="line">  return new Proxy(&#123;&#125;, &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">      return () &#x3D;&gt; httpGet(baseUrl+&#39;&#x2F;&#39; + propKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上就是我对ECMAScript 6 Proxy的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 Set</title>
    <url>/2019/02/19/80-ES6%20Set/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Set想必大家是不陌生的,ES6一个较为好用的方法,和Array很像但又不同</p>
</blockquote>
<a id="more"></a>

<p>文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界…</p>
<blockquote>
<p>Set和Array 的区别是Set不允许内部有重复的值，如果有只显示一个，相当于去重。虽然Set很像数组，但是他不是数组。</p>
</blockquote>
<blockquote>
<p>[…new Set(array)]</p>
</blockquote>
<h2 id="Set的声明"><a href="#Set的声明" class="headerlink" title="Set的声明"></a>Set的声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let setArr &#x3D; new Set([&#39;cs&#39;,&#39;csing&#39;,&#39;web&#39;]);</span><br><span class="line">console.log(setArr);</span><br></pre></td></tr></table></figure>

<h3 id="Set值的追加"><a href="#Set值的追加" class="headerlink" title="Set值的追加"></a>Set值的追加</h3><p>在使用Array的时候，可以用push进行追加值，那Set稍有不同，它用更语义化的add进行追加。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let setArr &#x3D; new Set([&#39;cs&#39;,&#39;csing&#39;,&#39;web&#39;]);</span><br><span class="line">setArr.add(&#39;hello&#39;);</span><br><span class="line">console.log(setArr);</span><br></pre></td></tr></table></figure>

<h3 id="Set值的删除"><a href="#Set值的删除" class="headerlink" title="Set值的删除"></a>Set值的删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let setArr &#x3D; new Set([&#39;cs&#39;,&#39;csing&#39;,&#39;web&#39;]);</span><br><span class="line">setArr.delete(&#39;csing&#39;);</span><br><span class="line">console.log(setArr);</span><br></pre></td></tr></table></figure>

<h3 id="Set值的查找"><a href="#Set值的查找" class="headerlink" title="Set值的查找"></a>Set值的查找</h3><p>用has进行值的查找，返回的是true或者false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let setArr &#x3D; new Set([&#39;cs&#39;,&#39;csing&#39;,&#39;web&#39;]);</span><br><span class="line">console.log(setArr.has(&#39;csing&#39;));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h3 id="Set值的删除-1"><a href="#Set值的删除-1" class="headerlink" title="Set值的删除"></a>Set值的删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let setArr &#x3D; new Set([&#39;cs&#39;,&#39;csing&#39;,&#39;web&#39;]);</span><br><span class="line">setArr.clear();</span><br><span class="line">console.log(setArray);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h3 id="set的for…of循环"><a href="#set的for…of循环" class="headerlink" title="set的for…of循环"></a>set的for…of循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let setArr &#x3D; new Set([&#39;cs&#39;,&#39;csing&#39;,&#39;web&#39;]);</span><br><span class="line">for (let item of setArr)&#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set的size属性"><a href="#set的size属性" class="headerlink" title="set的size属性"></a>set的size属性</h3><p>size属性可以获得Set值的数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let setArr &#x3D; new Set([&#39;cs&#39;,&#39;csing&#39;,&#39;web&#39;]);</span><br><span class="line">console.log(setArr.size);</span><br></pre></td></tr></table></figure>

<h3 id="set的forEach循环"><a href="#set的forEach循环" class="headerlink" title="set的forEach循环"></a>set的forEach循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let setArr &#x3D; new Set([&#39;cs&#39;,&#39;csing&#39;,&#39;web&#39;]);</span><br><span class="line">setArr.forEach((value)&#x3D;&gt;console.log(value));</span><br></pre></td></tr></table></figure>

<h3 id="WeakSet的声明"><a href="#WeakSet的声明" class="headerlink" title="WeakSet的声明"></a>WeakSet的声明</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let weakObj &#x3D; new WeakSet();</span><br><span class="line">let obj &#x3D; &#123;a:&#39;cs&#39;,b:&#39;csing&#39;&#125;</span><br><span class="line">weakObj.add(obj);</span><br><span class="line">console.log(weakObj);</span><br></pre></td></tr></table></figure>

<p>在实际开发中Set用的比较多，WeakSet用的并不多，但是他对传入值必须是对象作了很好的判断，我们灵活应用还是有一定的用处的。</p>
<p>以上就是我对ECMAScript 6 Set的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 Map</title>
    <url>/2019/02/19/81-ES6%20Map/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Map是一种灵活，简单的适合一对一查找的数据结构。我们知道的数据结构，已经有了json和set。那map有什么特点。</p>
</blockquote>
<a id="more"></a>

<p>文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界…</p>
<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<p>举个简单的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let json &#x3D; &#123;</span><br><span class="line">  name:&#39;csing&#39;,</span><br><span class="line">  skill:&#39;web&#39;</span><br><span class="line">&#125;</span><br><span class="line">console.log(json.name);</span><br><span class="line">var map&#x3D;new Map();</span><br><span class="line">map.set(json,&#39;iam&#39;);</span><br><span class="line">console.log(map);</span><br></pre></td></tr></table></figure>

<p>你的key可以设置成对象，值也可以设置成字符串，让它不规律对应起来,当然也可key字符串，value是对象。我们调换一下位置，依然是符合map的数据结构规范的。</p>
<h2 id="Map值的增加"><a href="#Map值的增加" class="headerlink" title="Map值的增加"></a>Map值的增加</h2><p>上面的代码就已经体现了Map值的增加了</p>
<p><code>map.set(&#39;csing&#39;,json);</code></p>
<h2 id="Map值的获取"><a href="#Map值的获取" class="headerlink" title="Map值的获取"></a>Map值的获取</h2><p><code>map.get(json)</code></p>
<h2 id="Map值的删除"><a href="#Map值的删除" class="headerlink" title="Map值的删除"></a>Map值的删除</h2><p><code>map.delete(json);</code></p>
<h2 id="Map值的size属性"><a href="#Map值的size属性" class="headerlink" title="Map值的size属性"></a>Map值的size属性</h2><p><code>console.log(map.size);</code></p>
<h2 id="查找是否存在has"><a href="#查找是否存在has" class="headerlink" title="查找是否存在has"></a>查找是否存在has</h2><p><code>map.has(&#39;csing&#39;)</code></p>
<h2 id="清楚所有元素clear"><a href="#清楚所有元素clear" class="headerlink" title="清楚所有元素clear"></a>清楚所有元素clear</h2><p><code>map.clear()</code></p>
<p>Map在现在开发中已经经常使用，它的灵活性和高效性是我们喜欢的。</p>
<p>以上就是我对ECMAScript 6 Map的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 Promise</title>
    <url>/2019/02/19/82-ES6%20Promise/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>Promise我在很早的时候就有写过,现在放在ES6中重新的提一下,因为真的很重要</p>
</blockquote>
<a id="more"></a>

<p>文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界…</p>
<p>ES6中的promise的出现给我们很好的解决了回调地狱的问题，在使用ES5的时候，在多层嵌套回调时，写完的代码层次过多，很难进行维护和二次开发，ES6认识到了这点问题，现在promise的使用，完美解决了这个问题.</p>
<h2 id="promise的含义"><a href="#promise的含义" class="headerlink" title="promise的含义"></a>promise的含义</h2><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise对象有以下两个特点。</p>
<ol>
<li><p>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
</li>
<li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
</li>
</ol>
<h2 id="promise的基本用法"><a href="#promise的基本用法" class="headerlink" title="promise的基本用法"></a>promise的基本用法</h2><p>创造了一个Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">  &#x2F;&#x2F; ... some code</span><br><span class="line">  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>resolve – 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去.</p>
</blockquote>
<blockquote>
<p>reject – 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去.</p>
</blockquote>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  &#x2F;&#x2F; success</span><br><span class="line">  &#x2F;&#x2F; 在then中,第一个函数代表成功</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  &#x2F;&#x2F; failure</span><br><span class="line">  &#x2F;&#x2F; 第二个函数代表失败</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>value的值就是resolve函数传递出来的</p>
</blockquote>
<p>但是,一般来说,不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），而是使用catch方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(function(data) &#123; &#x2F;&#x2F;cb</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function(err) &#123;</span><br><span class="line">    &#x2F;&#x2F; error</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为这样写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）</p>
</blockquote>
<p>then是成功,catch是失败,现在我们来看一下finally</p>
<p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(result &#x3D;&gt; &#123;···&#125;)</span><br><span class="line">  .catch(error &#x3D;&gt; &#123;···&#125;)</span><br><span class="line">  .finally(() &#x3D;&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure>

<p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p>最常用到的就是这三种,更多的大家可以去看看官方的文档</p>
<p>以上就是我对ECMAScript 6 Promise的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 Class</title>
    <url>/2019/02/25/83-ES6%20Class/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>如果看过我之前的博客,构造函数和原型,应该会发现我提到过Class</p>
</blockquote>
<a id="more"></a>

<p>早期的时候,生成实例对象的传统方法是通过构造函数,具体实现可以移步<a href="https://www.chensheng.group/2016/09/15/03-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/">原型与构造函数的继承</a></p>
<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>举个简单的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  &#x2F;&#x2F; constructor方法，这就是构造方法，而this关键字则代表实例对象。</span><br><span class="line">  &#x2F;&#x2F; 传递参数后可以直接使用this.xxx进行调用。</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 静态属性的表达。前面加上static关键字</span><br><span class="line">  static uumber &#x3D; 42;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 前面加一个#表示私有的,只能在自己的内部使用this调用</span><br><span class="line">  #myValue &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 写方法之间不要用逗号,方法如果要调用,要记得return</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 可以进行传参</span><br><span class="line">  name(val)&#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var yuan &#x3D; new Point(1,2)</span><br><span class="line"></span><br><span class="line">console.log(yuan.name(&#39;name&#39;)) &#x2F;&#x2F; 最外层输出的undefined,因为没有return东西出来</span><br></pre></td></tr></table></figure>

<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>使用extends进行继承,这在我之前的博客已经提到过了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class line extends Point&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个line的新类并继承Point类，line新类里边为空，这时候我们实例化新类，并调用里边的name方法。结果也是可以调用到的。</p>
<p>Class的知识点还有很多,但是工作中最常用到的就是这一些,更多的知识可以移步官方文档</p>
<p>以上就是我对ECMAScript 6 Class的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 模块化操作</title>
    <url>/2019/02/25/84-ES6%20%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>做个项目的小伙伴肯定都知道模块化操作,我这里就不细讲了,记录几点知识</p>
</blockquote>
<a id="more"></a>

<p>模块化操作主要包括两个方面。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul>
<li>export :负责进行模块化，也是模块的输出。</li>
<li>import : 负责把模块引，也是模块的引入操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">export var m &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">var m &#x3D; 1;</span><br><span class="line">export &#123;m&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法三</span><br><span class="line">var n &#x3D; 1;</span><br><span class="line">export &#123;n as m&#125;;</span><br><span class="line">&#x2F;&#x2F; as相当于别名的作用-这里相当于把n叫做m</span><br></pre></td></tr></table></figure>

<p>读取的时候也遵守相应的规范</p>
<p><code>import {m as my} from &#39;./temp&#39;;</code></p>
<p>使用export导出,import导入需要写上{},后面写上相对路径,如果想要换一个名字,也可以使用as</p>
<h2 id="export和export-default的区别"><a href="#export和export-default的区别" class="headerlink" title="export和export default的区别"></a>export和export default的区别</h2><p>export default的使用 加上default相当是一个默认的入口。在一个文件里export default只能有一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; 1;</span><br><span class="line">export default m;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>export default 输出的时候,是可以不用加 {}的</p>
</blockquote>
<p>使用export default导出的时候,import导入是可以随意取名字的</p>
<p><code>import m from &#39;./temp&#39;;</code></p>
<p>而且不用加{}</p>
<p>以上就是我对ECMAScript 6 模块化的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>ECMAScript 6</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>electron-vue 桌面应用</title>
    <url>/2019/04/15/85-electron-vue%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>最近项目需要一个桌面应用,于是初步了解了一下electron-vue来打造桌面应用</p>
</blockquote>
<a id="more"></a>

<h1 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h1><p>什么是 electron? 官网里这么说：Electron提供了一个Nodejs的运行时，专注于构建桌面应用，同时使用web页面来作为应用的GUI，你可以将其看作是一个由JavaScript控制的迷你版的Chromium浏览器。</p>
<p>本质上，electron 就是一个带了 Chrome 浏览器的壳子（无需考虑兼容性的问题）。</p>
<p>具有两个进程，分别是主进程，以及渲染进程。</p>
<ul>
<li><p>主进程：运行 package.json 里面 main 脚本的进程成为主进程。</p>
</li>
<li><p>渲染进程： 每个 electron 的页面都运行着自己的进程，称为渲染进程。</p>
</li>
</ul>
<p>我们主要的页面代码就是放在渲染进程里面的</p>
<h1 id="electron-vue"><a href="#electron-vue" class="headerlink" title="electron-vue"></a>electron-vue</h1><p>electron-vue 是一个结合 vue-cli 与 electron 的项目，主要避免了使用 vue 手动建立起 electron 应用程序，很方便。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>假设电脑已经安装node.js,并且已经全局搭建好vue-cli脚手架</p>
<p>cd 到需要安装的目录下, vue init simulatedgreg/electron-vue project</p>
<p>一路回车</p>
<p>之后就是安装依赖了,推荐使用yarn,可以避免打包时候的一些报错</p>
<blockquote>
<p>路径千万不能有中文!!</p>
</blockquote>
<h3 id="项目结构树"><a href="#项目结构树" class="headerlink" title="项目结构树"></a>项目结构树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my-project</span><br><span class="line">├─ .electron-vue                    &lt;&#x3D;  配置文件</span><br><span class="line">│  └─ &lt;build&#x2F;development&gt;.js files</span><br><span class="line">├─ build                            &lt;&#x3D;  打包的icon,以及打包后的文件</span><br><span class="line">│  └─ icons&#x2F;</span><br><span class="line">├─ dist                             &lt;&#x3D;  编译打包</span><br><span class="line">│  ├─ electron&#x2F;</span><br><span class="line">│  └─ web&#x2F;</span><br><span class="line">├─ node_modules&#x2F;                    &lt;&#x3D;  node包</span><br><span class="line">├─ src</span><br><span class="line">│  ├─ main                          &lt;&#x3D;  主进程配置</span><br><span class="line">│  │  ├─ index.dev.js</span><br><span class="line">│  │  └─ index.js</span><br><span class="line">│  ├─ renderer                      &lt;&#x3D;  渲染进程文件</span><br><span class="line">│  │  ├─ components&#x2F;</span><br><span class="line">│  │  ├─ router&#x2F;</span><br><span class="line">│  │  ├─ store&#x2F;</span><br><span class="line">│  │  ├─ App.vue</span><br><span class="line">│  │  └─ main.js</span><br><span class="line">│  └─ index.ejs</span><br><span class="line">├─ static&#x2F;                          &lt;&#x3D;  静态资源文件</span><br><span class="line">├─ test</span><br><span class="line">│  ├─ e2e</span><br><span class="line">│  │  ├─ specs&#x2F;</span><br><span class="line">│  │  ├─ index.js</span><br><span class="line">│  │  └─ utils.js</span><br><span class="line">│  ├─ unit</span><br><span class="line">│  │  ├─ specs&#x2F;</span><br><span class="line">│  │  ├─ index.js</span><br><span class="line">│  │  └─ karma.config.js</span><br><span class="line">│  └─ .eslintrc</span><br><span class="line">├─ .babelrc</span><br><span class="line">├─ .eslintignore</span><br><span class="line">├─ .eslintrc.js</span><br><span class="line">├─ .gitignore</span><br><span class="line">├─ package.json</span><br><span class="line">└─ README.md</span><br></pre></td></tr></table></figure>

<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <p>Vue</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>VueRouter</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>Vuex</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>Vue-Electron</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>iView</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>Eslint</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>Babel</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>Webpack</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>Nodejs</p>
</li>
</ul>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>npm run dev 就可以开始运行了</p>
<p>这里贴一下基本的主进程的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mainWindow &#x3D; new BrowserWindow(&#123;</span><br><span class="line">  width: 1200,</span><br><span class="line">  minWidth: 1200,</span><br><span class="line">  height: 720,</span><br><span class="line">  minHeight: 720,</span><br><span class="line">  resizable: true, &#x2F;&#x2F; 窗口是否可调整大小</span><br><span class="line">  movable: true, &#x2F;&#x2F; 窗口是否可移动</span><br><span class="line">  skipTaskbar: false, &#x2F;&#x2F; 是否在任务栏中显示窗口。</span><br><span class="line">  center: true, &#x2F;&#x2F; 在屏幕中心显示窗口</span><br><span class="line">  useContentSize: true, &#x2F;&#x2F; 实际窗口的大小将包括窗口框架的大小并略大</span><br><span class="line">  transparent: false, &#x2F;&#x2F; 使窗口透明</span><br><span class="line">  frame: false, &#x2F;&#x2F;创建一个无框窗口</span><br><span class="line">  titleBarStyle: &quot;hidden&quot;,</span><br><span class="line">  webPreferences: &#123;</span><br><span class="line">    webSecurity: false, &#x2F;&#x2F; 跨域</span><br><span class="line">    plugins: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个主要是配置窗口的事件,更多的配置欢迎去官网查询</p>
<h2 id="自定义窗口事件-最小化到托盘"><a href="#自定义窗口事件-最小化到托盘" class="headerlink" title="自定义窗口事件(最小化到托盘)"></a>自定义窗口事件(最小化到托盘)</h2><h3 id="渲染进程中"><a href="#渲染进程中" class="headerlink" title="渲染进程中"></a>渲染进程中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置点击和发送</span><br><span class="line"></span><br><span class="line">let ipc &#x3D; require(&#39;electron&#39;).ipcRenderer;</span><br><span class="line"></span><br><span class="line">document.getElementById(&#39;minWin&#39;).addEventListener(&#39;click&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  ipc.send(&#39;window-min&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">document.getElementById(&#39;maxWin&#39;).addEventListener(&#39;click&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  ipc.send(&#39;window-max&#39;);</span><br><span class="line">  &#x2F;&#x2F; this.windowMax &#x3D; !this.windowMax;</span><br><span class="line">&#125;)</span><br><span class="line">document.getElementById(&#39;closeWin&#39;).addEventListener(&#39;click&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  ipc.send(&#39;window-close&#39;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ipc.on(&#39;main-maximize&#39;, (event, arg) &#x3D;&gt; &#123;</span><br><span class="line">  this.windowMax &#x3D; true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ipc.on(&#39;main-unmaximize&#39;, (event, arg) &#x3D;&gt; &#123;</span><br><span class="line">  this.windowMax &#x3D; false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="主进程中"><a href="#主进程中" class="headerlink" title="主进程中"></a>主进程中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  import &#123; app, BrowserWindow, Tray, Menu &#125; from &#39;electron&#39;</span><br><span class="line"></span><br><span class="line">  const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">  const electron &#x3D; require(&#39;electron&#39;)</span><br><span class="line">  let tray &#x3D; null</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 在 createWindow 中监听发送</span><br><span class="line"></span><br><span class="line">  function createWindow () &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Initial window options</span><br><span class="line">   *&#x2F;</span><br><span class="line">  mainWindow &#x3D; new BrowserWindow(&#123;</span><br><span class="line">    width: 1200,</span><br><span class="line">    minWidth: 1200,</span><br><span class="line">    height: 720,</span><br><span class="line">    minHeight: 720,</span><br><span class="line">    resizable: true, &#x2F;&#x2F; 窗口是否可调整大小</span><br><span class="line">    movable: true, &#x2F;&#x2F; 窗口是否可移动</span><br><span class="line">    skipTaskbar: false, &#x2F;&#x2F; 是否在任务栏中显示窗口。</span><br><span class="line">    center: true, &#x2F;&#x2F; 在屏幕中心显示窗口</span><br><span class="line">    useContentSize: true, &#x2F;&#x2F; 实际窗口的大小将包括窗口框架的大小并略大</span><br><span class="line">    transparent: false, &#x2F;&#x2F; 使窗口透明</span><br><span class="line">    frame: false, &#x2F;&#x2F;创建一个无框窗口</span><br><span class="line">    titleBarStyle: &quot;hidden&quot;,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      webSecurity: false, &#x2F;&#x2F; 跨域</span><br><span class="line">      plugins: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  mainWindow.loadURL(winURL)</span><br><span class="line"></span><br><span class="line">  mainWindow.on(&#39;closed&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    mainWindow &#x3D; null</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 像渲染进程发送指令</span><br><span class="line">  mainWindow.on(&#39;maximize&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    mainWindow.webContents.send(&#39;main-maximize&#39;);</span><br><span class="line">  &#125;)</span><br><span class="line">  mainWindow.on(&#39;unmaximize&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    mainWindow.webContents.send(&#39;main-unmaximize&#39;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 自定义创建监听缩小放大关闭</span><br><span class="line">  const ipc &#x3D; electron.ipcMain</span><br><span class="line">  &#x2F;&#x2F;窗口最小化</span><br><span class="line">  ipc.on(&#39;window-min&#39;,function()&#123;</span><br><span class="line">    mainWindow.minimize();</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F;窗口最大化</span><br><span class="line">  ipc.on(&#39;window-max&#39;,function()&#123;</span><br><span class="line">    if(mainWindow.isMaximized())&#123;</span><br><span class="line">        mainWindow.restore();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        mainWindow.maximize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当我们点击关闭时触发close事件，我们按照之前的思路在关闭时，隐藏窗口，隐藏任务栏窗口</span><br><span class="line">  &#x2F;&#x2F; event.preventDefault(); 禁止关闭行为(非常必要，因为我们并不是想要关闭窗口，所以需要禁止默认行为)</span><br><span class="line">  ipc.on(&#39;window-close&#39;,(event)&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; mainWindow.close();</span><br><span class="line">    mainWindow.hide();</span><br><span class="line">    mainWindow.setSkipTaskbar(true);</span><br><span class="line">    event.preventDefault();</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;创建系统通知区菜单</span><br><span class="line">  tray &#x3D; new Tray(path.join(__dirname, &#39;&#x2F;static&#x2F;icon.ico&#39;));</span><br><span class="line">  const contextMenu &#x3D; Menu.buildFromTemplate([</span><br><span class="line">      &#123;label: &#39;退出&#39;, click: () &#x3D;&gt; &#123;mainWindow.destroy()&#125;&#125;,&#x2F;&#x2F;我们需要在这里有一个真正的退出（这里直接强制退出）</span><br><span class="line">  ])</span><br><span class="line">  tray.setToolTip(&#39;易家健康管理&#39;)</span><br><span class="line">  tray.setContextMenu(contextMenu)</span><br><span class="line">  tray.on(&#39;click&#39;, ()&#x3D;&gt;&#123; &#x2F;&#x2F;我们这里模拟桌面程序点击通知区图标实现打开关闭应用的功能</span><br><span class="line">    mainWindow.isVisible() ? mainWindow.hide() : mainWindow.show()</span><br><span class="line">    mainWindow.isVisible() ? mainWindow.setSkipTaskbar(false):mainWindow.setSkipTaskbar(true);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义拖动事件"><a href="#自定义拖动事件" class="headerlink" title="自定义拖动事件"></a>自定义拖动事件</h3><p>当默认的窗口框被关闭时,就要自己去设置拖动了.</p>
<p>在需要拖动的地方设置 <code>style=&quot;-webkit-app-region: drag&quot;</code></p>
<p>在点击的地方禁止拖动 <code>style=&quot;-webkit-app-region: no-drag;&quot;</code></p>
<p>在拖动的地方设置禁止选取文字 <code>style=&quot;-webkit-user-select: none;&quot;</code></p>
<h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p>npm run build</p>
<p>打包这个东西,尽人事听天命…</p>
<blockquote>
<p>如提示缺少vue组建，是因为registry的问题，因为国内taobao镜像没有Electron的依赖环境。应该删掉node包,重新yarn一下</p>
</blockquote>
<p>打包好后,就在build文件夹底下了</p>
<p>后面在研究一下自动更新..</p>
<p>以上就是我对vue-electron 桌面应用的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>electron-vue</category>
      </categories>
      <tags>
        <tag>electron-vue</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次失败的微信分享</title>
    <url>/2019/04/24/86-%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>一直都很想做一下微信分享,奈何一直抽不出时间,今天来和大家分享一下我的失败过程</p>
</blockquote>
<a id="more"></a>

<p>我们知道微信分享会自动获取页面的title标签做为我们的分享标题，但是分享的详细描述和图标呢？如果需要自定义，我们就需要调取微信分享接口</p>
<p>看看微信的官网怎么说的 -&gt; <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1445241432" target="_blank" rel="noopener">戳我戳我</a></p>
<h2 id="流程步骤"><a href="#流程步骤" class="headerlink" title="流程步骤"></a>流程步骤</h2><p>第一步、我们需要知道, H5调用微信分享需要后端传递<code>生成签名的时间戳</code>,<code>生成签名的随机串</code>,<code>签名</code>,<code>公众号的唯一标识</code>,所以我们需要一个后端来配合我们</p>
<p>第二步、求人不如求几,自己搭建一个Node服务器,去请求微信分享接口所需要的签名</p>
<p>第三步、请求的时候发现需要在微信公众号配置IP白名单,才可以进行请求,顺手添加一下</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/86-1-%E5%BE%AE%E4%BF%A1IP%E7%99%BD%E5%90%8D%E5%8D%95.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="微信IP白名单"></p>
<p>第四步、我们的后台就可以开始请求了,<code>获取token</code>,<code>获取jsapiticket</code>,<code>获取签名</code>,具体代码下面会贴出</p>
<p>第五步、我们发现当前请求的页面和分享链接的域名需要在微信公众号中设置<code>微信JS接口安全域名</code></p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/86-2-%E5%BE%AE%E4%BF%A1JS%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E5%9F%9F%E5%90%8D.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="微信JS接口安全域名"></p>
<p>But,它需要备案的域名…一般都是公司企业进行备案,所以我使用到了<code>Natapp</code>进行内网映射外网,这里就不多做介绍了</p>
<p>到这里,备案的域名我们就绕过去了</p>
<p>第六步、可以开始写前端代码了,在<code>wx.config</code>中配置好后,<code>wx.ready</code>中就可以开始进行分享了,具体代码下面会贴出</p>
<p>第七步、将页面放到微信开发工具上,打开debug模式,测试一下看看,咦…,配置都对,为什么还是不能分享?找找万能的百度</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/86-3-%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="微信分享1"><br><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/86-4-%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="微信分享2"><br><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/86-5-%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="微信分享3"></p>
<p>绕过了备案,绕不过认证,要钱的…散了吧…最终还是已失败告终</p>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p>首先安装 <code>weixin-js-sdk</code> ,之后引入进来 <code>import wx from &#39;weixin-js-sdk&#39;</code>我们看看具体是怎么实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$axios.get(&#39;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;wxapi&#39;, &#123;</span><br><span class="line">	params: &#123;</span><br><span class="line">		&#39;url&#39;: window.location.href</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">	wx.config(&#123;</span><br><span class="line">		debug: true, &#x2F;&#x2F; 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">		appId: res.data.appId, &#x2F;&#x2F; 必填，公众号的唯一标识</span><br><span class="line">		timestamp: res.data.timestamp, &#x2F;&#x2F; 必填，生成签名的时间戳</span><br><span class="line">		nonceStr: res.data.nonceStr, &#x2F;&#x2F; 必填，生成签名的随机串</span><br><span class="line">		signature: res.data.signature, &#x2F;&#x2F; 必填，签名</span><br><span class="line">		&#x2F;&#x2F; 需要分享的列表项:发送给朋友,分享到朋友圈,分享到QQ,分享到QQ空间</span><br><span class="line">		jsApiList: [&#39;onMenuShareTimeline&#39;, &#39;onMenuShareAppMessage&#39;, &#39;updateTimelineShareData&#39;] &#x2F;&#x2F; 必填，需要使用的JS接口列表</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	wx.error(function(result) &#123;</span><br><span class="line">		alert(&#39;报错&#39;)</span><br><span class="line">		&#x2F;&#x2F; config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span><br><span class="line">		alert(result + &#39;测试报错，上线后就可以修复&#39;);</span><br><span class="line">	&#125;);</span><br><span class="line">	wx.ready(function() &#123;</span><br><span class="line">		&#x2F;&#x2F; 分享到朋友圈</span><br><span class="line">		&#x2F;&#x2F; config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</span><br><span class="line">		alert(&#39;ready成功&#39;)</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;认证JsApi</span><br><span class="line">		wx.checkJsApi(&#123;</span><br><span class="line">			jsApiList: [&quot;onMenuShareTimeline&quot;],</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;分享到朋友圈</span><br><span class="line">		wx.updateTimelineShareData(&#123;</span><br><span class="line">			title: &quot;陈先生分享一下&quot;, &#x2F;&#x2F; 分享标题</span><br><span class="line">			desc: &quot;没什么好描述的&quot;, &#x2F;&#x2F;分享描述</span><br><span class="line">			link: &#39;http:&#x2F;&#x2F;n9gtsp.natappfree.cc&#39;, &#x2F;&#x2F; 分享链接,域名和路径必须与js安全域名的一致</span><br><span class="line">			imgUrl: &#39;https:&#x2F;&#x2F;timgsa.baidu.com&#x2F;timg?image&amp;quality&#x3D;80&amp;size&#x3D;b9999_10000&amp;sec&#x3D;1555931928218&amp;di&#x3D;c510b8f413124ec54a1c15adaa8830b9&amp;imgtype&#x3D;0&amp;src&#x3D;http%3A%2F%2Fimg.gifhome.com%2Fgif%2Femoji%2F2018%2Ff5f3d4c76dc94fdb8a0d2e6cf7f02904.jpg&#39; &#x2F;&#x2F; 分享图标</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;分享给朋友</span><br><span class="line">		wx.updateAppMessageShareData(&#123;</span><br><span class="line">			title: &quot;陈先生分享一下&quot;, &#x2F;&#x2F; 分享标题</span><br><span class="line">			desc: &quot;没什么好描述的&quot;, &#x2F;&#x2F;分享描述</span><br><span class="line">			link: &#39;http:&#x2F;&#x2F;n9gtsp.natappfree.cc&#39;, &#x2F;&#x2F; 分享链接,域名和路径必须与js安全域名的一致</span><br><span class="line">			imgUrl: &#39;https:&#x2F;&#x2F;timgsa.baidu.com&#x2F;timg?image&amp;quality&#x3D;80&amp;size&#x3D;b9999_10000&amp;sec&#x3D;1555931928218&amp;di&#x3D;c510b8f413124ec54a1c15adaa8830b9&amp;imgtype&#x3D;0&amp;src&#x3D;http%3A%2F%2Fimg.gifhome.com%2Fgif%2Femoji%2F2018%2Ff5f3d4c76dc94fdb8a0d2e6cf7f02904.jpg&#39; &#x2F;&#x2F; 分享图标</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看得出来，所有的参数都需要后台返回，其实我们也可以前端获取,但是不安全,后台我是用Node来写的,贴一下代码</p>
<p>npm安装<code>wechat_interaction_jsapi</code>,之后调用<code>new Jsapi</code>传入AppId和AppSecret</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Jsapi &#x3D; require(&#39;wechat_interaction_jsapi&#39;);</span><br><span class="line">const jssdk &#x3D; new Jsapi(&#39;wx***************11&#39;,&#39;6ce********************387&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取token</span><br><span class="line">jssdk.getAccessToken().then(function(re)&#123;</span><br><span class="line">	console.log(re)</span><br><span class="line">&#125;).catch(function(err)&#123;</span><br><span class="line">	console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取jsapiticket</span><br><span class="line">jssdk.getJsApiTicket().then(function(re)&#123;</span><br><span class="line">	console.log(re)</span><br><span class="line">&#125;).catch(function(err)&#123;</span><br><span class="line">	console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取签名</span><br><span class="line">app.get(&#39;&#x2F;wxapi&#39;,function(req,res,next)&#123;</span><br><span class="line">	jssdk.getSignPackage(req.query.url).then(function(re)&#123;</span><br><span class="line">		re.url &#x3D; req.query.url</span><br><span class="line">		res.json(re)</span><br><span class="line">	&#125;).catch(function(err)&#123;</span><br><span class="line">		console.log(err)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上就是我对微信分享的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端的各种支付</title>
    <url>/2019/06/28/87-H5%E6%94%AF%E4%BB%98/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>最近一直都在弄关于支付的项目,终于是告一段落了,之前也是很想做一下关于支付的项目,终于是接触到了,在这里分享一下</p>
</blockquote>
<a id="more"></a>

<p>关于支付,暂时只是接触到了微信和支付宝,其他的银联,QQ钱包之类的,应该还要去了解各自的文档和API</p>
<p>先来聊聊 微信支付</p>
<h2 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h2><p>微信的支付场景有三种,但是支付渠道有两种,这里只简述关于H5前端的部分,原生APP那些的并没有包含</p>
<h3 id="三种支付场景和两种微信支付渠道"><a href="#三种支付场景和两种微信支付渠道" class="headerlink" title="三种支付场景和两种微信支付渠道"></a>三种支付场景和两种微信支付渠道</h3><ol>
<li><p>微信浏览器打开的网页 –&gt; 微信JSAPI支付</p>
</li>
<li><p>非微信浏览器打开的网页 –&gt; 微信H5支付</p>
</li>
<li><p>微信公众号内的网页 –&gt; 微信JSAPI支付</p>
</li>
</ol>
<p>如果我们移动端的网页是嵌在元素APP里面的,走的也是 微信H5支付,因为内核是谷歌内核,属于非微信浏览器</p>
<h4 id="支付之前需要哪些配置"><a href="#支付之前需要哪些配置" class="headerlink" title="支付之前需要哪些配置"></a>支付之前需要哪些配置</h4><p>需要配置的配置项很多,需要进入微信公众号平台进行配置,其中需要注意的有几点<br>Web端配置的服务器,需要写入ip白名单当中,并且需要通过备案号才可以,商家号也是需要事先注册好的</p>
<h4 id="微信H5支付"><a href="#微信H5支付" class="headerlink" title="微信H5支付"></a>微信H5支付</h4><p>我们看看微信H5是怎么实现的</p>
<p>微信H5支付实现起来较为简单,调用后台接口,后台会返回一串微信的URL,跳转URL就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 微信H5支付</span><br><span class="line">wxH5Pay()&#123;</span><br><span class="line">  let sendMessage &#x3D; &#123;</span><br><span class="line">    url: this.$api.unifiedPay,</span><br><span class="line">    PostData: &#123;</span><br><span class="line">      tn: getToken(),</span><br><span class="line">      channelId: this.payTypeName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  this.$store.dispatch(&#39;Post&#39;, sendMessage).then((res) &#x3D;&gt; &#123;</span><br><span class="line">    if(res.errorcode !&#x3D;&#x3D; &quot;0000&quot;)&#123;</span><br><span class="line">      alert(res.message)</span><br><span class="line">      this.$router.replace(&#123;</span><br><span class="line">        path: &#39;&#x2F;fail&#39;,</span><br><span class="line">        query: &#123;</span><br><span class="line">          errorcode: res.errorcode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.submitName &#x3D; &#39;确认提交&#39;</span><br><span class="line">    window.location.href &#x3D; res.entity.payParams.payUrl</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支付成功后由于没有回调函数,需要后端配置一个路径,不管成功还是失败,都跳转到中间页去验证订单信息是否成功,重点说一下微信的JSPAI支付</p>
<h4 id="微信JSPAI支付"><a href="#微信JSPAI支付" class="headerlink" title="微信JSPAI支付"></a>微信JSPAI支付</h4><p>微信的JSAPI支付较为的繁琐,用户进入页面之前,需要获取用户的openID,因为后台需要这些数据</p>
<p>所以进入页面时,需要先跳转一次连接,通知后台去获取openID,这时候后台会跳转一次连接到微信中,再跳转回我们自己的页面,并且携带openID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 微信获取openid</span><br><span class="line">getOpenId()&#123;</span><br><span class="line">	let sendMessage &#x3D; &#123;</span><br><span class="line">		url: this.$api.getOpenId,</span><br><span class="line">		PostData: &#123;</span><br><span class="line">			tn: getToken()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	let tnString &#x3D; encodeURIComponent(sendMessage.PostData.tn)</span><br><span class="line">	let url &#x3D; &#39;http:&#x2F;&#x2F;*************.com&#x2F;***&#x2F;wx&#x2F;getOpenId?tn&#x3D;&#39; + tnString + &#39;&amp;redirectUrl&#x3D;pay&#39;</span><br><span class="line">	window.location.href &#x3D; url</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>支付的时候请求后台接口,将后台需要的参数传递过去,就包括刚刚获取到的openID,来获取我们需要的参数,然后就可以支付了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function onBridgeReady() &#123;</span><br><span class="line">	WeixinJSBridge.invoke(</span><br><span class="line">		&#39;getBrandWCPayRequest&#39;, &#123;</span><br><span class="line">			&quot;appId&quot;: res.entity.payParams.appId, &#x2F;&#x2F;公众号名称，由商户传入     </span><br><span class="line">			&quot;timeStamp&quot;: res.entity.payParams.timeStamp, &#x2F;&#x2F;时间戳，自1970年以来的秒数     </span><br><span class="line">			&quot;nonceStr&quot;: res.entity.payParams.nonceStr, &#x2F;&#x2F;随机串     </span><br><span class="line">			&quot;package&quot;: res.entity.payParams.package,</span><br><span class="line">			&quot;signType&quot;: res.entity.payParams.signType, &#x2F;&#x2F;微信签名方式：     </span><br><span class="line">			&quot;paySign&quot;: res.entity.payParams.paySign &#x2F;&#x2F;微信签名 </span><br><span class="line">		&#125;,</span><br><span class="line">		function(res) &#123;</span><br><span class="line">			if (res.err_msg &#x3D;&#x3D; &quot;get_brand_wcpay_request:ok&quot;) &#123;</span><br><span class="line">				&#x2F;&#x2F; 使用以上方式判断前端返回,微信团队郑重提示：</span><br><span class="line">				&#x2F;&#x2F;res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。</span><br><span class="line">				_this.queryPayOrderCar()</span><br><span class="line">			&#125;else if(res.err_msg &#x3D;&#x3D; &quot;get_brand_wcpay_request:cancel&quot;)&#123;</span><br><span class="line">				_this.submitName &#x3D; &#39;确认提交&#39;</span><br><span class="line">			&#125;else if(res.err_msg &#x3D;&#x3D; &quot;get_brand_wcpay_request:fail&quot;)&#123;</span><br><span class="line">				_this.queryPayOrderCar()</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				_this.queryPayOrderCar()</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line">if (typeof WeixinJSBridge &#x3D;&#x3D; &quot;undefined&quot;) &#123;</span><br><span class="line">	if (document.addEventListener) &#123;</span><br><span class="line">		document.addEventListener(&#39;WeixinJSBridgeReady&#39;, onBridgeReady, false);</span><br><span class="line">	&#125; else if (document.attachEvent) &#123;</span><br><span class="line">		document.attachEvent(&#39;WeixinJSBridgeReady&#39;, onBridgeReady);</span><br><span class="line">		document.attachEvent(&#39;onWeixinJSBridgeReady&#39;, onBridgeReady);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	onBridgeReady();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是,支付完成后,我们最后需要去验证一下订单信息到底是否成功支付,微信官方也告诉我们res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。</p>
<p>微信小程序的支付方式和微信JSAPI是一样的,参考上面模板即可,到这里,微信支付告一段落了,看看支付宝的</p>
<h3 id="支付宝支付"><a href="#支付宝支付" class="headerlink" title="支付宝支付"></a>支付宝支付</h3><p>支付宝相比较于微信显得简单许多,但是文档不如微信的好阅读</p>
<p>支付之前请求后台接口,获取需要的参数,拼装成from表单后submit提交就可以了,也不用分什么支付宝浏览器还是普通的原生浏览器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aliPay()&#123;</span><br><span class="line">	let sendMessage &#x3D; &#123;</span><br><span class="line">		url: this.$api.unifiedPay,</span><br><span class="line">		PostData: &#123;</span><br><span class="line">			tn: getToken(),</span><br><span class="line">			channelId: this.payTypeName</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	this.$store.dispatch(&#39;Post&#39;, sendMessage).then((res) &#x3D;&gt; &#123;</span><br><span class="line">		if(res.errorcode !&#x3D;&#x3D; &quot;0000&quot;)&#123;</span><br><span class="line">			alert(res.message)</span><br><span class="line">			this.$router.replace(&#123;</span><br><span class="line">				path: &#39;&#x2F;fail&#39;,</span><br><span class="line">				query: &#123;</span><br><span class="line">					errorcode: res.errorcode</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		this.submitName &#x3D; &#39;确认提交&#39;</span><br><span class="line">		const div &#x3D; document.createElement(&#39;div&#39;)</span><br><span class="line">		&#x2F;* 此处form就是后台返回接收到的数据 *&#x2F;</span><br><span class="line">		div.innerHTML &#x3D; res.entity.payParams.payUrl</span><br><span class="line">		document.body.appendChild(div)</span><br><span class="line">		document.forms[0].submit()</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="项目的难点"><a href="#项目的难点" class="headerlink" title="项目的难点"></a>项目的难点</h3><ol>
<li>首先就是配置项了,一个项目,难的永远不是代码技术,微信的配置项烦不胜烦,调试的时候又不能在本地运行</li>
<li>获取openId时需要跳转页面,此时返回的话,url会停留在微信获取openId的页面,给用户不好的感觉</li>
<li>订单超时的问题,由于本地时间与服务器时间存在一定的误差,所以时间需要校准</li>
<li>用户重复下单,反复提交支付,支付成功后回到订单页继续支付</li>
</ol>
<p>返回问题的解决方案如下:</p>
<p>原理大致是这样的,首先获取state,查看是否可以进入页面,如果不可以,说明之前已经携带openId进入过此页了,所以直接返回到上一页</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">	&#x2F;&#x2F; 先获取状态,看看能不能进入</span><br><span class="line">	let state &#x3D; sessionStorage.getItem(&quot;backState&quot;)</span><br><span class="line">	if(state)&#123;</span><br><span class="line">		&#x2F;&#x2F; 不可以进入,清空sessionStorage并返回商户页面</span><br><span class="line">		sessionStorage.clear();</span><br><span class="line">		next(vm &#x3D;&gt; &#123;</span><br><span class="line">			vm.$router.go(-2)</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		let openId &#x3D; to.query.openId</span><br><span class="line">		if(!isEmpty(openId))&#123;</span><br><span class="line">			&#x2F;&#x2F; 有openId</span><br><span class="line">			sessionStorage.setItem(&quot;backState&quot;,&#39;no&#39;);</span><br><span class="line">		&#125;</span><br><span class="line">		next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>超时解决方案如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取服务器的时间</span><br><span class="line">var serverTime &#x3D; res.timeStamp;</span><br><span class="line">&#x2F;&#x2F; 当前时间的时间戳</span><br><span class="line">var timestamp &#x3D; new Date().getTime(); </span><br><span class="line">&#x2F;&#x2F; 计算时间差</span><br><span class="line">this.differenceTime &#x3D; timestamp - serverTime;</span><br><span class="line">&#x2F;&#x2F; 正  本地时间大于服务器时间</span><br><span class="line">		</span><br><span class="line">this.lastTime &#x3D; parseInt((obj.expireTime - (timestamp - this.differenceTime)) &#x2F; 1000) ;</span><br><span class="line"></span><br><span class="line">this.setInterval &#x3D; setInterval(()&#x3D;&gt;&#123;</span><br><span class="line">	&#x2F;&#x2F; this.lastTime--</span><br><span class="line">	var nowtime &#x3D; new Date().getTime();</span><br><span class="line">	this.lastTime &#x3D; parseInt((obj.expireTime - (nowtime - this.differenceTime)) &#x2F; 1000) ;</span><br><span class="line">&#125;,1000)</span><br></pre></td></tr></table></figure>

<p>以上就是我对支付的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>支付</category>
      </categories>
      <tags>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA验签</title>
    <url>/2019/06/28/88-RSA%E9%AA%8C%E7%AD%BE/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>上篇讲到了支付,这里讲一下支付中传递参数时候对后台参数进行验证</p>
</blockquote>
<a id="more"></a>

<p>规定的是使用RSA,来看看具体怎么使用的吧</p>
<p>首先导入 jsrsasign</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jsrsasign&#x2F;8.0.12&#x2F;jsrsasign-all-min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>假设objString 就是后台让我们要验证的东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> let objString &#x3D; ****</span><br><span class="line">&#x2F;&#x2F; 验证Java的签名</span><br><span class="line">&#x2F;&#x2F; 这里 prvkeypem 放公钥pem看起来有点怪, 但是这是可行的, 内部还是使用的上文经常出现的 KEYUTIL.getKey(pk) 来生成公钥实例的</span><br><span class="line">&#x2F;&#x2F; 初始化构建Signature实例</span><br><span class="line">var sign4Java &#x3D; new KJUR.crypto.Signature(&#123;alg:&quot;SHA1withRSA&quot;,prvkeypem:pk&#125;);</span><br><span class="line">sign4Java.updateString(objString);</span><br><span class="line">&#x2F;&#x2F; Java生成签名</span><br><span class="line">var signByJava &#x3D; sign;</span><br><span class="line">var b2 &#x3D; sign4Java.verify(b64utohex(signByJava));</span><br><span class="line">	</span><br><span class="line"> return b2</span><br></pre></td></tr></table></figure>

<p>那么这里的b2就是true or false,判断是否通过</p>
<p>参考文章 <a href="https://www.jianshu.com/p/b32fc387d8ad" target="_blank" rel="noopener">戳这里</a></p>
<p>以上就是我对支付的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>RSA</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>Node的一些事</title>
    <url>/2019/09/08/89-node%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>作为一个前端切图仔,Node知识是一定要会的,稍后在做详细的介绍,这里记录一下Node经常会错的点</p>
</blockquote>
<a id="more"></a>

<p>写了这么多篇的博客,我好像还没有去更为详细的介绍Node用来做mark的假数据应该怎么写,只是在其他的博客中零零散散的提到一点,今天也先不写,以后有时间再写,今天记录一下Node的一些容易忘记的东西</p>
<p>首先在使用 electron-vue的时候,node版本不能大于12.x 的版本,需要回退版本,但是node的中文官网只能下载最新的版本,这里记录一下可以下载其他版本的官网</p>
<p><a href="https://nodejs.org/download/release/v8.9.4/" target="_blank" rel="noopener">node下载地址</a></p>
<p><code>版本号需要改成自己想要的版本</code></p>
<p>安装node的时候,如果是低版本下安装高版本,Node会直接覆盖掉,如果是高版本要回退到低版本,直接安装是会报错的</p>
<p><img src="https://img.mukewang.com/58881e4b000150c305000379.jpg" alt="Node报错图"></p>
<p>这时候需要卸载Node,直接在.msi安装文件点击右键,再点击卸载就可以了</p>
<p>如果是MAC的电脑,可以去安装 n 来用作node的版本管理,window系统的就去安装nvm,因为要先卸载node,所以我也还没有试过</p>
<p>安装完之后,需要去配置环境变量</p>
<p>这里的环境配置主要配置的是npm安装的全局模块所在的路径,以及缓存cache的路径,之所以要配置,是因为以后在执行类似:npm install express [-g] 的安装语句时,会默认到C盘。所以我配置到D盘去</p>
<p>我安装在<code>D:\Program Files\nodejs</code></p>
<p>所以在在我安装的文件夹【D:\Program Files\nodejs】下创建两个文件夹【node_global】及【node_cache】</p>
<p>创建完两个空文件夹之后，打开cmd命令窗口，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\Program Files\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;D:\Program Files\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure>
<p>接下来设置环境变量，关闭cmd窗口，“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”</p>
<p>进入环境变量对话框，在【系统变量】下新建【NODE_PATH】,输入【D:\Program Files\nodejs\node_global\node_modules】<br>将【用户变量】下的【Path】修改为【D:\Program Files\nodejs\node_global】</p>
<p>至此node安装好了,但是由于国内的比较慢,所以我们一般用淘宝镜像来弄</p>
<p>安装 <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<p>此篇只作为记录一下,以免以后要去百度….</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>electron-vue 启动报错</title>
    <url>/2019/09/12/90-electron-vue%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>隔了很久重新打开electron-vue,有新加了需求,结果运行报错: process is not defined</p>
</blockquote>
<a id="more"></a>

<p>当时就把我整蒙逼了,太久没启动,项目都生锈了吗</p>
<p>上百度一查,原来不止是我,很多人都有这个问题,那我就放心了,在GitHub的electron-vue的issue中找到了解决办法</p>
<h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>简单粗暴，不知道会不会有什么影响，直接将<code>src/index.ejs</code>这段代码去掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (!process.browser) &#123; %&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;development&#39;) window.__static &#x3D; require(&#39;path&#39;).join(__dirname, &#39;&#x2F;static&#39;).replace(&#x2F;\\&#x2F;g, &#39;\\\\&#39;)</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>将 .electron-vue/webpack.web.config.js 和.electron-vue/webpack.renderer.config.js中的代码修改为 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">  filename: &#39;index.html&#39;,</span><br><span class="line">  template: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;index.ejs&#39;),</span><br><span class="line">  templateParameters(compilation, assets, options) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      compilation: compilation,</span><br><span class="line">      webpack: compilation.getStats().toJson(),</span><br><span class="line">      webpackConfig: compilation.options,</span><br><span class="line">      htmlWebpackPlugin: &#123;</span><br><span class="line">        files: assets,</span><br><span class="line">        options: options</span><br><span class="line">      &#125;,</span><br><span class="line">      process,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  minify: &#123;</span><br><span class="line">    collapseWhitespace: true,</span><br><span class="line">    removeAttributeQuotes: true,</span><br><span class="line">    removeComments: true</span><br><span class="line">  &#125;,</span><br><span class="line">  nodeModules: false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>后来搞清楚了原因,node 版本在12.0以上才会报这个错误,把node版本回退一下就好了,怎么回退就看我上一篇的博客吧</p>
<p>以上就是我对electron-vue 报错的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>electron-vue</category>
      </categories>
      <tags>
        <tag>electron-vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 2.0 打包配置不同环境</title>
    <url>/2019/09/14/92-vue%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>项目会部署到线上不同的环境,看看怎么配置</p>
</blockquote>
<a id="more"></a>

<ol>
<li><p>复制config&gt;prod.env.js，创建一个test.env.js，并修改环境为test。</p>
</li>
<li><p>复制build&gt;webpack.prod.conf.js，创建一个webpack.test.conf.js，并修改文件中出现的prod单词，替换为test</p>
</li>
<li><p>webpack.base.conf.js和utils.js 改为<code>process.env.NODE_ENV === &#39;production&#39; || &#39;test&#39;</code></p>
</li>
<li><p>vue-loader.conf.js 修改为 <code>const isProduction = process.env.NODE_ENV === &#39;production&#39; || process.env.NODE_ENV === &#39;test&#39;</code></p>
</li>
<li><p>package.json中改 <code>&quot;test&quot;: &quot;node build/test.build.js&quot;</code>,<code>&quot;all&quot;: &quot;npm run build &amp;&amp; npm run test&quot;</code></p>
</li>
<li><p>复制build.js文件,命名为test.build.js,改为 <code>process.env.NODE_ENV = &#39;test&#39;</code>,<code>const webpackConfig = require(&#39;./webpack.test.conf&#39;)</code></p>
</li>
</ol>
<blockquote>
<p>配置不同的打包文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let buildFolder;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 创建不同的打包地址</span><br><span class="line">if (processEnv &#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">  buildFolder &#x3D; &#39;distPro&#39;;  &#x2F;&#x2F; 生产</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (processEnv &#x3D;&#x3D; &#39;test&#39;) &#123;</span><br><span class="line">  buildFolder &#x3D; &#39;distTest&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build: &#123;</span><br><span class="line">  &#x2F;&#x2F; Template for index.html</span><br><span class="line">  index: path.resolve(__dirname, &#96;..&#x2F;$&#123;buildFolder&#125;&#x2F;index.html&#96;),</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Paths</span><br><span class="line">  assetsRoot: path.resolve(__dirname, &#96;..&#x2F;$&#123;buildFolder&#125;&#96;),</span><br><span class="line">  assetsSubDirectory: &#39;static&#39;,</span><br><span class="line">  assetsPublicPath: &#39;.&#x2F;&#39;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置不同的url</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let baseUrl&#x3D; &quot;&quot;;</span><br><span class="line">switch (process.env.NODE_ENV) &#123;</span><br><span class="line">  case &#39;development&#39;:</span><br><span class="line">    baseUrl &#x3D; &quot;&#x2F;mgr&#x2F;&quot; &#x2F;&#x2F;开发环境url</span><br><span class="line">    break</span><br><span class="line">  case &#39;test&#39;:</span><br><span class="line">    baseUrl &#x3D; &quot;&#x2F;dev&#x2F;mgr&#x2F;&quot; &#x2F;&#x2F;测试环境中的url</span><br><span class="line">    break</span><br><span class="line">  case &#39;production&#39;:</span><br><span class="line">    baseUrl &#x3D; &quot;&#x2F;mgr&#x2F;&quot; &#x2F;&#x2F;生产环境url</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var NewApiRootUrl &#x3D; baseUrl;</span><br></pre></td></tr></table></figure>


<h2 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h2><p>上面那种做法是比较偷懒的,相当于把test直接和prod绑在一起,也是可以分开的</p>
<ol>
<li>在config/index.js中新增一个对象类似这样的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    dev: &#123;&#125;,</span><br><span class="line">    build: &#123;&#125;,</span><br><span class="line">    test: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再test中配置需要的参数</p>
<ol start="2">
<li>在各个配置里面,把刚刚上面提到的那些 <code>|| &#39;test&#39;</code> 修改为相对于的方法,指向到config/index.js中的test方法,其实原理都是一样的</li>
</ol>
<p>以上就是我对vue-cli 2.0打包配置 的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>electron-vue 调用C++动态链接库（DLL）</title>
    <url>/2019/09/12/91-%E8%B0%83%E7%94%A8DLL%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>项目中需要调用到DLL,这里做一下记录,以免日后忘记</p>
</blockquote>
<a id="more"></a>

<p>废话不多说,DLL和ffi我也就不介绍了,反正也没人看,先说一下注意点,直接上步骤</p>
<ol>
<li>如果dll是32位的nodejs和electron都要使用对应的版本才可以使用,</li>
<li>nodejs版本建议不要太高,我用的是8.x的</li>
</ol>
<p>打开cmd控制台,使用管理员打开,一定要管理员</p>
<h3 id="下载electron-vue"><a href="#下载electron-vue" class="headerlink" title="下载electron-vue"></a>下载electron-vue</h3><p>拉取electron-vue没什么好说的,之前也都说过</p>
<p>vue init simulatedgreg/electron-vue project</p>
<p>cd project  cnpm install</p>
<p>在安装一下 <code>electron-rebuild</code></p>
<p>cnpm install –save-dev electron-rebuild</p>
<h3 id="安装ffi"><a href="#安装ffi" class="headerlink" title="安装ffi"></a>安装ffi</h3><p>安装ffi之前需要安装node-gyp</p>
<p>而node-gyp又需要下面几个环境</p>
<ol>
<li>python2.x 这里我用的是2.7版本,(3.x不支持); 安装完成以后需要将python设置为环境变量</li>
<li>.net framework 4.5.1</li>
<li>visual C++ Build Tools,或者 （vs2015以上（包含15))</li>
</ol>
<blockquote>
<p>可以执行cnpm install –global –production windows-build-tools 一键安装上面所需的依赖</p>
</blockquote>
<p>全部安装好了就是这个样子,会显示 ALL down,耐心等待一下,之后敲一下python,看看环境变量是否已经配置好了,如果没有的话,就要手动配置了</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/91-python.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="图片"></p>
<h4 id="安装node-gyp"><a href="#安装node-gyp" class="headerlink" title="安装node-gyp"></a>安装node-gyp</h4><p>接下来就可以安装 node-gyp</p>
<blockquote>
<p>cnpm install node-gyp -g</p>
</blockquote>
<h4 id="正式安装ffi了"><a href="#正式安装ffi了" class="headerlink" title="正式安装ffi了"></a>正式安装ffi了</h4><blockquote>
<p>cnpm install ffi –save</p>
</blockquote>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/91-2-ffiWaring.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="ffi错误警告"></p>
<p>出现这一些黄色警告,也不知道以后会不会有影响</p>
<p>在项目中导入一下ffi</p>
<blockquote>
<p>const ffi=require(“ffi”);</p>
</blockquote>
<p>咦..报错?? Uncaught Error: A dynamic link library (DLL) initialization routine failed.</p>
<p>事实上electron在使用c++模时还需要根据electron的版本等信息重新编译一下，这样在electron中才能执行，我们需要进入ffi模块执行重新编译的命令，并注入参数。</p>
<p>cd进入node_modules/ffi目录执行如下</p>
<blockquote>
<p>node-gyp rebuild -target=2.0.4  -arch=x64 -dist-url=<a href="https://npm.taobao.org/mirrors/atom/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/atom/</a><br>或<br>node-gyp rebuild -target=2.0.4  -arch=ia32 -dist-url=<a href="https://npm.taobao.org/mirrors/atom/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/atom/</a></p>
</blockquote>
<ul>
<li>arget：electron的版本号</li>
<li>arch ： 计算机的架构（x64或者ia32），如果node环境是32位，那么这里就是ia32，如果是node环境是64位，那么这里就是x64。</li>
<li>dist-url ：文件的下载地址，编译的时候回去这个地址上下载一些额外的文件，具体作用我不是很清楚。这里使用的是国内镜像，不是官方给出的地址，至于为什么，太慢了。</li>
</ul>
<p>结果!!! node-gyp rebuild 不成功???</p>
<p>各种找原因,最后发现是node-gyp版本问题5.0.3的不可以</p>
<p>于是下载稳定一点的 <code>cnpm install node-gyp@3.7.0 -g</code></p>
<p>继续rebuild一下,成功的时候会出现<code>已完成代码的生成</code> 这样的字眼</p>
<p>然后我们在项目<code>根目录</code>下需要执行如下命令</p>
<blockquote>
<p>.\node_modules.bin\electron-rebuild.cmd</p>
</blockquote>
<p>成功的时候会有个打钩的Rebuild Complete</p>
<p>这时候再运行一下,就可以调用ffi了</p>
<h3 id="调用ffi"><a href="#调用ffi" class="headerlink" title="调用ffi"></a>调用ffi</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ffi&#x3D;require(&quot;ffi&quot;);</span><br><span class="line">const User32 &#x3D;  ffi.Library(&#39;user32&#39;, &#123;</span><br><span class="line">  &#39;GetWindowLongPtrW&#39;: [&#39;int&#39;, [&#39;int&#39;, &#39;int&#39;]],</span><br><span class="line">  &#39;SetWindowLongPtrW&#39;: [&#39;int&#39;, [&#39;int&#39;, &#39;int&#39;, &#39;long&#39;]],</span><br><span class="line">  &#39;GetSystemMenu&#39;: [&#39;int&#39;, [&#39;int&#39;, &#39;bool&#39;]],</span><br><span class="line">  &#39;DestroyWindow&#39;: [&#39;bool&#39;, [&#39;int&#39;]]</span><br><span class="line">&#125;)</span><br><span class="line">console.log(User32.DestroyWindow);</span><br><span class="line"></span><br><span class="line">测试调用本地的ffi</span><br></pre></td></tr></table></figure>


<h3 id="其他遇到的报错问题"><a href="#其他遇到的报错问题" class="headerlink" title="其他遇到的报错问题"></a>其他遇到的报错问题</h3><p>Q: Uncaught Error: Could not locate the bindings file.</p>
<p>A: ffi没有编译,需要node-gyp rebuild 一下</p>
<p>Q: 安装ffi时报错 not found python</p>
<p>A: python 环境变量没有配置好</p>
<p>Q: Uncaught Error: Dynamic Linking Error: Win32 error 126</p>
<p>A: Dll引用的路径不对,检查路径是否书写正确,需要用绝对路径</p>
<p>Q: Uncaught Error: Dynamic Linking Error: Win32 error 193</p>
<p>A: dll 位数不对应，例如electron/nodejs是32位的dll是64位的</p>
<p>Q: Uncaught Error: Dynamic Linking Error: Win32 error 127</p>
<p>A: DLL中没有找到对应名称的函数，需要检查头文件定义的函数名是否与DLL调用时写的函数名是否相同。</p>
<blockquote>
<p>至此,运行调用Dll文件没有问题</p>
</blockquote>
<p>以上就是我对electron-vue 调用dll 的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>electron-vue</category>
      </categories>
      <tags>
        <tag>electron-vue</tag>
      </tags>
  </entry>
  <entry>
    <title>electron-vue 调用dll时打包问题</title>
    <url>/2019/09/15/93-electron%E6%89%93%E5%8C%85dll%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>本以为调用DLL成功就万事大吉了,没想到打包实在令人头疼,前前后后花了两天的时间</p>
</blockquote>
<a id="more"></a>

<p>首先,直接<code>npm run build</code>,打包…报错了…</p>
<p>what,我看百度他们都是打包之后白屏的啊,怎么到我这里直接报错</p>
<p>报错内容,大致是node-gyp rebuild 出错了</p>
<p>原因是我们在执行npm run build的时候，是通过electron-rebuild 来build的，这时会再次执行node-gyp rebuild，<br>这里没有添加任何参数，所以打包出来的应用可能还是会失败，最直接的方式就是在项目根目录下添加一个npm安装配置文件.npmrc，里面包含了一下npm的运行需要注入的参数。</p>
<p>.npmrc:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Electron 的版本。</span><br><span class="line">set npm config --target&#x3D;2.0.4</span><br><span class="line"># Electron 的系统架构, 值为 ia32 或者 x64。</span><br><span class="line">set npm config --arch&#x3D;ia32</span><br><span class="line"># 下载 Electron 的 headers。</span><br><span class="line">eset npm config --disturl&#x3D;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;atom&#x2F;</span><br><span class="line"># 告诉 node-pre-gyp 我们是在为 Electron 生成模块。</span><br><span class="line">set npm config --runtime&#x3D;electron</span><br></pre></td></tr></table></figure>

<p>一切准备就绪,继续 <code>npm run build</code></p>
<p>嗯?? 怎么还是报错…提示 not found python ?????</p>
<p>运行的时候环境配置不是弄的好好的吗,怎么打包的时候又不行了</p>
<p>再配一次吧</p>
<ol>
<li>查看命令行python是否可用，如果不可用，设置path.确定命令行可用。</li>
<li>命令行可用。可以通过下面命令设置</li>
</ol>
<p><code>npm config set python C:\Users\CS\.windows-build-tools\python27\python.exe</code></p>
<p>如果不行执行下面的</p>
<p><code>node-gyp configure --python v2.7.3 --verbose</code></p>
<p>现在再打包..应该就可以打包成功了…</p>
<p>就是白屏了…想打开控制台,发现打不开…继续配置</p>
<p>在主线程中添加下面这句话</p>
<p><code>mainWindow.webContents.openDevTools()</code></p>
<p>主线程和渲染进程我就不再说了,之前说过了</p>
<p>打开控制台后,发现错误126..就是DLL文件路径不对</p>
<p>打开json文件,配置一下extraResources,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;build&quot;: &#123;</span><br><span class="line">  &quot;extraResources&quot;:  [ &#x2F;&#x2F; 拷贝dll等静态文件到指定位置</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;from&quot;: &quot;.&#x2F;termb.dll&quot;,</span><br><span class="line">      &quot;to&quot;: &quot;..&#x2F;&quot;,  &#x2F;&#x2F; .&#x2F;是放在app同级,..&#x2F;就放在根目录底下</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;nsis&quot;: &#123;</span><br><span class="line">    &quot;oneClick&quot;: false, &#x2F;&#x2F; 一键安装</span><br><span class="line">    &quot;guid&quot;: &quot;xxxx&quot;, &#x2F;&#x2F;注册表名字，不推荐修改</span><br><span class="line">    &quot;perMachine&quot;: true, &#x2F;&#x2F; 是否开启安装时权限限制（此电脑或当前用户）</span><br><span class="line">    &quot;allowElevation&quot;: true, &#x2F;&#x2F; 允许请求提升。 如果为false，则用户必须使用提升的权限重新启动安装程序。</span><br><span class="line">    &quot;allowToChangeInstallationDirectory&quot;: true, &#x2F;&#x2F; 允许修改安装目录</span><br><span class="line">    &quot;installerIcon&quot;: &quot;.&#x2F;build&#x2F;icons&#x2F;aaa.ico&quot;, &#x2F;&#x2F; 安装图标</span><br><span class="line">    &quot;uninstallerIcon&quot;: &quot;.&#x2F;build&#x2F;icons&#x2F;bbb.ico&quot;, &#x2F;&#x2F;卸载图标</span><br><span class="line">    &quot;installerHeaderIcon&quot;: &quot;.&#x2F;build&#x2F;icons&#x2F;aaa.ico&quot;, &#x2F;&#x2F; 安装时头部图标</span><br><span class="line">    &quot;createDesktopShortcut&quot;: true, &#x2F;&#x2F; 创建桌面图标</span><br><span class="line">    &quot;createStartMenuShortcut&quot;: true, &#x2F;&#x2F; 创建开始菜单图标</span><br><span class="line">    &quot;shortcutName&quot;: &quot;xxxx&quot; &#x2F;&#x2F; 图标名称</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的termb.dll需要放在根目录下</p>
<p>调用的时候这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import SystemInformation from &#39;.&#x2F;LandingPage&#x2F;SystemInformation&#39;</span><br><span class="line">  const ffi&#x3D;require(&quot;ffi&quot;);</span><br><span class="line">  var path &#x3D; require(&#39;path&#39;);</span><br><span class="line">  var dllPath &#x3D; path.resolve(&#39;termb.dll&#39;);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;__dirname 这个是指向当前目录的</span><br><span class="line">  &#x2F;&#x2F;__static 这个是指向static的,</span><br><span class="line">  var testLib &#x3D; ffi.Library(dllPath, &#123;</span><br><span class="line">    CloseComm:[&#39;int&#39;,[]],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  var dllRet &#x3D; testLib.CloseComm();</span><br><span class="line">  &#x2F;&#x2F; 返回-1</span><br><span class="line">  console.log(&#39;ret &#x3D;&gt; &#39;+dllRet);</span><br></pre></td></tr></table></figure>

<p>路径的问题每个人可能都不一样,这只是我自己的方法,如果有其他更好的方法也可以使用</p>
<p>以上就是我对electron-vue 调用dll时打包问题的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>electron-vue</category>
      </categories>
      <tags>
        <tag>electron-vue</tag>
      </tags>
  </entry>
  <entry>
    <title>electron-vue 配置说明</title>
    <url>/2019/09/16/94-electron-vue%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>花了大约两周的时间,使用electron-vue了解如果调用DLL,现在说一下electron-vue中的配置文件都是干嘛用的</p>
</blockquote>
<a id="more"></a>

<p>贴一下electron-vue的<a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/" target="_blank" rel="noopener">官方文档</a></p>
<p>本文参考一只小蚂蚁的<a href="https://juejin.im/post/5d6517a7f265da03e5234401" target="_blank" rel="noopener">文章</a>,感谢大佬无私奉献</p>
<h3 id="build-js"><a href="#build-js" class="headerlink" title="build.js"></a>build.js</h3><p>打包的入口文件为build.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;</span><br><span class="line">&#x2F;&#x2F; 环境说明</span><br><span class="line">process.env.NODE_ENV &#x3D; &#39;production&#39;</span><br><span class="line">&#x2F;&#x2F; 一个对console.log字体修饰的库，dev的时候，会出现一个花式输出Electron-vue</span><br><span class="line">const &#123; say &#125; &#x3D; require(&#39;cfonts&#39;)</span><br><span class="line">&#x2F;&#x2F; 终端输出字符串样式，字体样式，字体颜色，背景颜色</span><br><span class="line">const chalk &#x3D; require(&#39;chalk&#39;)</span><br><span class="line">&#x2F;&#x2F; 一个使用globs删除文件和目录的模块， del模块支持多个文件删除[数组]，这是node的原生模块</span><br><span class="line">const del &#x3D; require(&#39;del&#39;)</span><br><span class="line">&#x2F;&#x2F; node原生模块，用来创建子进程</span><br><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;)</span><br><span class="line">&#x2F;&#x2F; webpack</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">&#x2F;&#x2F; 多个cli滚轮，比如同时安装多个模块，然后在终端会显示滚轮，类似于进度显示</span><br><span class="line">const Multispinner &#x3D; require(&#39;multispinner&#39;)</span><br><span class="line">&#x2F;&#x2F; 需要的配置文件</span><br><span class="line">const mainConfig &#x3D; require(&#39;.&#x2F;webpack.main.config&#39;)</span><br><span class="line">const rendererConfig &#x3D; require(&#39;.&#x2F;webpack.renderer.config&#39;)</span><br><span class="line">const webConfig &#x3D; require(&#39;.&#x2F;webpack.web.config&#39;)</span><br><span class="line">const doneLog &#x3D; chalk.bgGreen.white(&#39; DONE &#39;) + &#39; &#39;</span><br><span class="line">const errorLog &#x3D; chalk.bgRed.white(&#39; ERROR &#39;) + &#39; &#39;</span><br><span class="line">const okayLog &#x3D; chalk.bgBlue.white(&#39; OKAY &#39;) + &#39; &#39;</span><br><span class="line">const isCI &#x3D; process.env.CI || false</span><br><span class="line">&#x2F;&#x2F; 除了clean|web命令，是执行自己的操作，其他指令都是使用build()</span><br><span class="line">if (process.env.BUILD_TARGET &#x3D;&#x3D;&#x3D; &#39;clean&#39;) clean()</span><br><span class="line">else if (process.env.BUILD_TARGET &#x3D;&#x3D;&#x3D; &#39;web&#39;) web()</span><br><span class="line">else build()</span><br><span class="line">&#x2F;&#x2F; 同步删除build文件</span><br><span class="line">function clean () &#123;</span><br><span class="line">  del.sync([&#39;build&#x2F;*&#39;, &#39;!build&#x2F;icons&#39;, &#39;!build&#x2F;icons&#x2F;icon.*&#39;])</span><br><span class="line">  console.log(&#96;\n$&#123;doneLog&#125;\n&#96;)</span><br><span class="line">  process.exit()</span><br><span class="line">&#125;</span><br><span class="line">function build () &#123;</span><br><span class="line">  greeting()</span><br><span class="line">  del.sync([&#39;dist&#x2F;electron&#x2F;*&#39;, &#39;!.gitkeep&#39;])</span><br><span class="line">  const tasks &#x3D; [&#39;main&#39;, &#39;renderer&#39;]</span><br><span class="line">  const m &#x3D; new Multispinner(tasks, &#123;</span><br><span class="line">    preText: &#39;building&#39;,</span><br><span class="line">    postText: &#39;process&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">  let results &#x3D; &#39;&#39;</span><br><span class="line">  m.on(&#39;success&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    process.stdout.write(&#39;\x1B[2J\x1B[0f&#39;)</span><br><span class="line">    console.log(&#96;\n\n$&#123;results&#125;&#96;)</span><br><span class="line">    console.log(&#96;$&#123;okayLog&#125;take it away $&#123;chalk.yellow(&#39;&#96;electron-builder&#96;&#39;)&#125;\n&#96;)</span><br><span class="line">    process.exit()</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 打包主进程</span><br><span class="line">  pack(mainConfig).then(result &#x3D;&gt; &#123;</span><br><span class="line">    results +&#x3D; result + &#39;\n\n&#39;</span><br><span class="line">    m.success(&#39;main&#39;)</span><br><span class="line">  &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">    m.error(&#39;main&#39;)</span><br><span class="line">    console.log(&#96;\n  $&#123;errorLog&#125;failed to build main process&#96;)</span><br><span class="line">    console.error(&#96;\n$&#123;err&#125;\n&#96;)</span><br><span class="line">    process.exit(1)</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 打包渲染进程</span><br><span class="line">  pack(rendererConfig).then(result &#x3D;&gt; &#123;</span><br><span class="line">    results +&#x3D; result + &#39;\n\n&#39;</span><br><span class="line">    m.success(&#39;renderer&#39;)</span><br><span class="line">  &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">    m.error(&#39;renderer&#39;)</span><br><span class="line">    console.log(&#96;\n  $&#123;errorLog&#125;failed to build renderer process&#96;)</span><br><span class="line">    console.error(&#96;\n$&#123;err&#125;\n&#96;)</span><br><span class="line">    process.exit(1)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function pack (config) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    config.mode &#x3D; &#39;production&#39;</span><br><span class="line">    webpack(config, (err, stats) &#x3D;&gt; &#123;</span><br><span class="line">      if (err) reject(err.stack || err)</span><br><span class="line">      else if (stats.hasErrors()) &#123;</span><br><span class="line">        let err &#x3D; &#39;&#39;</span><br><span class="line">        stats.toString(&#123;</span><br><span class="line">          chunks: false,</span><br><span class="line">          colors: true</span><br><span class="line">        &#125;)</span><br><span class="line">        .split(&#x2F;\r?\n&#x2F;)</span><br><span class="line">        .forEach(line &#x3D;&gt; &#123;</span><br><span class="line">          err +&#x3D; &#96;    $&#123;line&#125;\n&#96;</span><br><span class="line">        &#125;)</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve(stats.toString(&#123;</span><br><span class="line">          chunks: false,</span><br><span class="line">          colors: true</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 先删除dist目录，除了.gitkeep文件</span><br><span class="line">function web () &#123;</span><br><span class="line">  del.sync([&#39;dist&#x2F;web&#x2F;*&#39;, &#39;!.gitkeep&#39;])</span><br><span class="line">  webConfig.mode &#x3D; &#39;production&#39;</span><br><span class="line">  webpack(webConfig, (err, stats) &#x3D;&gt; &#123;</span><br><span class="line">    if (err || stats.hasErrors()) console.log(err)</span><br><span class="line">    console.log(stats.toString(&#123;</span><br><span class="line">      chunks: false,</span><br><span class="line">      colors: true</span><br><span class="line">    &#125;))</span><br><span class="line">    process.exit()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 致意信息 映入眼帘</span><br><span class="line">function greeting () &#123;</span><br><span class="line">  const cols &#x3D; process.stdout.columns</span><br><span class="line">  let text &#x3D; &#39;&#39;</span><br><span class="line">  if (cols &gt; 85) text &#x3D; &#39;lets-build&#39;</span><br><span class="line">  else if (cols &gt; 60) text &#x3D; &#39;lets-|build&#39;</span><br><span class="line">  else text &#x3D; false</span><br><span class="line">  if (text &amp;&amp; !isCI) &#123;</span><br><span class="line">    say(text, &#123;</span><br><span class="line">      colors: [&#39;yellow&#39;],</span><br><span class="line">      font: &#39;simple3d&#39;,</span><br><span class="line">      space: false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else console.log(chalk.yellow.bold(&#39;\n  lets-build&#39;))</span><br><span class="line">  console.log()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="build-runner-js"><a href="#build-runner-js" class="headerlink" title="build.runner.js"></a>build.runner.js</h3><p>开发环境使用的配置文件是build.runner.js</p>
<p>build.runner.js 主进程 + 渲染进程 打包<br>Electron-vue修改了对开发环境的优化，包括了于开发环境的配置文件隔离，主进程和渲染进程配置文件隔离，编译过程提示等功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;</span><br><span class="line">const chalk &#x3D; require(&#39;chalk&#39;)</span><br><span class="line">const electron &#x3D; require(&#39;electron&#39;)</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const &#123; say &#125; &#x3D; require(&#39;cfonts&#39;)</span><br><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;)</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">const WebpackDevServer &#x3D; require(&#39;webpack-dev-server&#39;)</span><br><span class="line">const webpackHotMiddleware &#x3D; require(&#39;webpack-hot-middleware&#39;)</span><br><span class="line">const mainConfig &#x3D; require(&#39;.&#x2F;webpack.main.config&#39;)</span><br><span class="line">const rendererConfig &#x3D; require(&#39;.&#x2F;webpack.renderer.config&#39;)</span><br><span class="line">let electronProcess &#x3D; null</span><br><span class="line">let manualRestart &#x3D; false</span><br><span class="line">let hotMiddleware</span><br><span class="line">function logStats (proc, data) &#123;</span><br><span class="line">  let log &#x3D; &#39;&#39;</span><br><span class="line">  log +&#x3D; chalk.yellow.bold(&#96;┏ $&#123;proc&#125; Process $&#123;new Array((19 - proc.length) + 1).join(&#39;-&#39;)&#125;&#96;)</span><br><span class="line">  log +&#x3D; &#39;\n\n&#39;</span><br><span class="line">  if (typeof data &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">    data.toString(&#123;</span><br><span class="line">      colors: true,</span><br><span class="line">      chunks: false</span><br><span class="line">    &#125;).split(&#x2F;\r?\n&#x2F;).forEach(line &#x3D;&gt; &#123;</span><br><span class="line">      log +&#x3D; &#39;  &#39; + line + &#39;\n&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    log +&#x3D; &#96;  $&#123;data&#125;\n&#96;</span><br><span class="line">  &#125;</span><br><span class="line">  log +&#x3D; &#39;\n&#39; + chalk.yellow.bold(&#96;┗ $&#123;new Array(28 + 1).join(&#39;-&#39;)&#125;&#96;) + &#39;\n&#39;</span><br><span class="line">  console.log(log)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 启动渲染进程</span><br><span class="line">&#x2F;&#x2F; 整体作用：将dev-client.js和renderer&#x2F;main.js合并到webpack entry字段，输出到根目录下的&#x2F;dist&#x2F;electron&#x2F;main.js文件中</span><br><span class="line">function startRenderer () &#123;</span><br><span class="line">  &#x2F;&#x2F; 加载webpack配置</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    rendererConfig.entry.renderer &#x3D; [path.join(__dirname, &#39;dev-client&#39;)].concat(rendererConfig.entry.renderer)</span><br><span class="line">    rendererConfig.mode &#x3D; &#39;development&#39;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建webpack</span><br><span class="line">    const compiler &#x3D; webpack(rendererConfig)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建webpack热加载</span><br><span class="line">    &#x2F;&#x2F; webpackHotMiddleware的heartbeat的参数作用并不是检测文件的频率，而是保持服务器链接存活的心跳频率</span><br><span class="line">    hotMiddleware &#x3D; webpackHotMiddleware(compiler, &#123;</span><br><span class="line">      log: false,</span><br><span class="line">      heartbeat: 2500</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 编译状态监控</span><br><span class="line">    # 监听的是 compilation事件</span><br><span class="line">    compiler.hooks.compilation.tap(&#39;compilation&#39;, compilation &#x3D;&gt; &#123;</span><br><span class="line">      compilation.hooks.htmlWebpackPluginAfterEmit.tapAsync(&#39;html-webpack-plugin-after-emit&#39;, (data, cb) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 钩子函数，检测webpack的编译状态，把其中的html-webpack-plugin-after-emit状态，发布到webpackHotMiddleware中</span><br><span class="line">        hotMiddleware.publish(&#123; action: &#39;reload&#39; &#125;)</span><br><span class="line">        cb()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 输出打包编译过程</span><br><span class="line">    compiler.hooks.done.tap(&#39;done&#39;, stats &#x3D;&gt; &#123;</span><br><span class="line">      logStats(&#39;Renderer&#39;, stats)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 创建webpack-dev-server</span><br><span class="line">    const server &#x3D; new WebpackDevServer(</span><br><span class="line">      compiler,</span><br><span class="line">      &#123;</span><br><span class="line">        contentBase: path.join(__dirname, &#39;..&#x2F;&#39;),</span><br><span class="line">        quiet: true,</span><br><span class="line">        before (app, ctx) &#123;</span><br><span class="line">          &#x2F;&#x2F; 使用webpackHotMiddleware</span><br><span class="line">          app.use(hotMiddleware)</span><br><span class="line">          ctx.middleware.waitUntilValid(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    &#x2F;&#x2F; 监听窗口</span><br><span class="line">    server.listen(9080)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 启动主进程 - 过程与渲染进程是类似的</span><br><span class="line">&#x2F;&#x2F; 创建webpack，实时发布hotMiddleware，主代码热更新</span><br><span class="line">function startMain () &#123;</span><br><span class="line">  &#x2F;&#x2F; 导入index.dev.js，该文件主要安装electron-debug工具，同时也安装了vue-devtools工具</span><br><span class="line">  &#x2F;&#x2F; webpack.config.main.js与render相比，main不需要去去处理vue，图片， css，html等，只需要对js处理</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    mainConfig.entry.main &#x3D; [path.join(__dirname, &#39;..&#x2F;src&#x2F;main&#x2F;index.dev.js&#39;)].concat(mainConfig.entry.main)</span><br><span class="line">    mainConfig.mode &#x3D; &#39;development&#39;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建主进程的 webpack</span><br><span class="line">    const compiler &#x3D; webpack(mainConfig)</span><br><span class="line">    # 监听的是watch-run事件</span><br><span class="line">    compiler.hooks.watchRun.tapAsync(&#39;watch-run&#39;, (compilation, done) &#x3D;&gt; &#123;</span><br><span class="line">      logStats(&#39;Main&#39;, chalk.white.bold(&#39;compiling...&#39;))</span><br><span class="line">      hotMiddleware.publish(&#123; action: &#39;compiling&#39; &#125;)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 与render不同，没有使用WebpackDevServer的方式自动更新界面，而是通过webpack的watch模式，不断重新启动程序，类似于electron-forge start</span><br><span class="line">    compiler.watch(&#123;&#125;, (err, stats) &#x3D;&gt; &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      logStats(&#39;Main&#39;, stats)</span><br><span class="line">      if (electronProcess &amp;&amp; electronProcess.kill) &#123;</span><br><span class="line">        manualRestart &#x3D; true</span><br><span class="line">        process.kill(electronProcess.pid)</span><br><span class="line">        electronProcess &#x3D; null</span><br><span class="line">        &#x2F;&#x2F; 重新启动项目</span><br><span class="line">        startElectron()</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          manualRestart &#x3D; false</span><br><span class="line">        &#125;, 5000)</span><br><span class="line">      &#125;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 启动electron</span><br><span class="line">function startElectron () &#123;</span><br><span class="line">  var args &#x3D; [</span><br><span class="line">    &#39;--inspect&#x3D;5858&#39;,</span><br><span class="line">    path.join(__dirname, &#39;..&#x2F;dist&#x2F;electron&#x2F;main.js&#39;)</span><br><span class="line">  ]</span><br><span class="line">  &#x2F;&#x2F; detect yarn or npm and process commandline args accordingly</span><br><span class="line">  if (process.env.npm_execpath.endsWith(&#39;yarn.js&#39;)) &#123;</span><br><span class="line">    args &#x3D; args.concat(process.argv.slice(3))</span><br><span class="line">  &#125; else if (process.env.npm_execpath.endsWith(&#39;npm-cli.js&#39;)) &#123;</span><br><span class="line">    args &#x3D; args.concat(process.argv.slice(2))</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 创建主进程执行特别命令</span><br><span class="line">  electronProcess &#x3D; spawn(electron, args)</span><br><span class="line">  </span><br><span class="line">  electronProcess.stdout.on(&#39;data&#39;, data &#x3D;&gt; &#123;</span><br><span class="line">    electronLog(data, &#39;blue&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">  electronProcess.stderr.on(&#39;data&#39;, data &#x3D;&gt; &#123;</span><br><span class="line">    electronLog(data, &#39;red&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">  electronProcess.on(&#39;close&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    if (!manualRestart) process.exit()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function electronLog (data, color) &#123;</span><br><span class="line">  let log &#x3D; &#39;&#39;</span><br><span class="line">  data &#x3D; data.toString().split(&#x2F;\r?\n&#x2F;)</span><br><span class="line">  data.forEach(line &#x3D;&gt; &#123;</span><br><span class="line">    log +&#x3D; &#96;  $&#123;line&#125;\n&#96;</span><br><span class="line">  &#125;)</span><br><span class="line">  if (&#x2F;[0-9A-z]+&#x2F;.test(log)) &#123;</span><br><span class="line">    console.log(</span><br><span class="line">      chalk[color].bold(&#39;┏ Electron -------------------&#39;) +</span><br><span class="line">      &#39;\n\n&#39; +</span><br><span class="line">      log +</span><br><span class="line">      chalk[color].bold(&#39;┗ ----------------------------&#39;) +</span><br><span class="line">      &#39;\n&#39;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; electron-vue Log输出</span><br><span class="line">function greeting () &#123;</span><br><span class="line">  const cols &#x3D; process.stdout.columns</span><br><span class="line">  let text &#x3D; &#39;&#39;</span><br><span class="line">  if (cols &gt; 104) text &#x3D; &#39;electron-vue&#39;</span><br><span class="line">  else if (cols &gt; 76) text &#x3D; &#39;electron-|vue&#39;</span><br><span class="line">  else text &#x3D; false</span><br><span class="line">  if (text) &#123;</span><br><span class="line">    say(text, &#123;</span><br><span class="line">      colors: [&#39;yellow&#39;],</span><br><span class="line">      font: &#39;simple3d&#39;,</span><br><span class="line">      space: false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else console.log(chalk.yellow.bold(&#39;\n  electron-vue&#39;))</span><br><span class="line">  console.log(chalk.blue(&#39;  getting ready...&#39;) + &#39;\n&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 初始函数</span><br><span class="line">function init () &#123;</span><br><span class="line">  greeting()</span><br><span class="line">  &#x2F;&#x2F; 主进程和渲染进程都启动完毕</span><br><span class="line">  Promise.all([startRenderer(), startMain()])</span><br><span class="line">    .then(() &#x3D;&gt; &#123;</span><br><span class="line">      startElectron()</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(err &#x3D;&gt; &#123;</span><br><span class="line">      console.error(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">init()</span><br></pre></td></tr></table></figure>

<h3 id="dev-client-js"><a href="#dev-client-js" class="headerlink" title="dev.client.js"></a>dev.client.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const hotClient &#x3D; require(&#39;webpack-hot-middleware&#x2F;client?noInfo&#x3D;true&amp;reload&#x3D;true&#39;)</span><br><span class="line">&#x2F;&#x2F; 注册webpack-hot-middleware监听器</span><br><span class="line">hotClient.subscribe(event &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理Main进程发送的&quot;compiling&quot;的事件</span><br><span class="line">  &#x2F;&#x2F; 实际上在Render进程中还发送了&quot;reload&quot;的消息</span><br><span class="line">  if (event.action &#x3D;&#x3D;&#x3D; &#39;compiling&#39;) &#123;</span><br><span class="line">    document.body.innerHTML +&#x3D; &#96;</span><br><span class="line">      &lt;style&gt;</span><br><span class="line">        #dev-client &#123;</span><br><span class="line">          background: #4fc08d;</span><br><span class="line">          border-radius: 4px;</span><br><span class="line">          bottom: 20px;</span><br><span class="line">          box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12), 0 2px 4px -1px rgba(0, 0, 0, 0.3);</span><br><span class="line">          color: #fff;</span><br><span class="line">          font-family: &#39;Source Sans Pro&#39;, sans-serif;</span><br><span class="line">          left: 20px;</span><br><span class="line">          padding: 8px 12px;</span><br><span class="line">          position: absolute;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;&#x2F;style&gt;</span><br><span class="line">      &lt;div id&#x3D;&quot;dev-client&quot;&gt;</span><br><span class="line">        Compiling Main Process...</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>页面会显示Compiling Main Process…<br>render webpack打包过程中，hotMiddleware.publish将各种编译状态发送给了hotClient.subscribe。<br>整个webpack-hot-middleware编译过程中发送的编译消息，将会在界面展示一个提示框提示开发者，当然这里也可以自定义订阅事件。</p>
<h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><p>页面的渲染都是通过渲染进程完成的，通过webpack.renderer.config.js可以看到渲染进程的入口文件是src/renderer/main.js<br>在普通的electron文件，主进程main.js通过mainWindow.loadURL()标识出渲染进程的html文件，也可以在渲染进程中调用Node的API。<br>在webpack.renderer.config,js中，可以看到使用了一个plugins html-webpack-plugin，这个插件将src/index.ejs模板生成首页的html文件。</p>
]]></content>
      <categories>
        <category>electron-vue</category>
      </categories>
      <tags>
        <tag>electron-vue</tag>
      </tags>
  </entry>
  <entry>
    <title>npm上传自定义vue组件</title>
    <url>/2019/09/18/95-npm%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>很久之前就想把自己的组件抽离出来,作成一个单独的组件上传到npm中,今天来记录一下</p>
</blockquote>
<a id="more"></a>

<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>虽然是用vue-cli搭的项目,当我们上传组件的时候就不在原来的项目上做了,新建一个项目来弄</p>
<p><code>vue init webpack-simple ruler(项目名)</code></p>
<p>项目的基本结构如下</p>
<p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/95-rule.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="项目结构图"></p>
<h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><p>在App.vue中直接引入本地的组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ruler from &#39;.&#x2F;page&#x2F;ruler.vue&#39;</span><br></pre></td></tr></table></figure>

<p>本地调试有一个要注意的地方,<code>webpack-simple</code>的项目,在index.html默认引入一个<code>&lt;script src=&quot;/dist/build.js&quot;&gt;&lt;/script&gt;</code></p>
<p>这里的名字与你打包之后的js名字不一样的话,需要修改</p>
<h3 id="改造成vue插件"><a href="#改造成vue插件" class="headerlink" title="改造成vue插件"></a>改造成vue插件</h3><p>在组件的文件夹下创建一个index.js文件</p>
<p>这个文件作用是将组件导出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入组件</span><br><span class="line">import CsingRuler from &#39;.&#x2F;ruler.vue&#39;</span><br><span class="line"></span><br><span class="line">CsingRuler.install &#x3D; Vue &#x3D;&gt; Vue.component(CsingRuler.name, CsingRuler); &#x2F;&#x2F;这里的name是.vue文件里面定义的</span><br><span class="line"></span><br><span class="line">if (typeof window !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; window.Vue) &#123;</span><br><span class="line">  window.Vue.use(CsingRuler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default CsingRuler</span><br></pre></td></tr></table></figure>

<p>在与APP.vue同级下创建一个index.js的文件(一个包下可能有多个组件)</p>
<p>导入刚刚写好的index.js组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 写好的组件</span><br><span class="line">import CsingRuler from &#39;.&#x2F;page&#x2F;index.js&#39;;</span><br><span class="line"></span><br><span class="line">const components &#x3D; [</span><br><span class="line">  CsingRuler,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const install &#x3D; function(Vue, opts &#x3D; &#123;&#125;) &#123;</span><br><span class="line">  components.map(component &#x3D;&gt; &#123;</span><br><span class="line">    Vue.component(component.name, component); &#x2F;&#x2F;到时候项目使用组件名,就是这个component.name</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 支持使用标签的方式引入 *&#x2F;</span><br><span class="line">if (typeof window !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; window.Vue) &#123;</span><br><span class="line">  install(window.Vue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  install,</span><br><span class="line">  CsingRuler,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改package-json文件"><a href="#修改package-json文件" class="headerlink" title="修改package.json文件"></a>修改package.json文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;cs-ruler&quot;, &#x2F;&#x2F;模块名,不能重复</span><br><span class="line">  &quot;description&quot;: &quot;刻度尺组件&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.4&quot;, &#x2F;&#x2F;版本号,每次要更新</span><br><span class="line">  &quot;author&quot;: &quot;chensheng&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;, &#x2F;&#x2F; 开源协议</span><br><span class="line">  &quot;private&quot;: false, &#x2F;&#x2F; 因为组件包是公用的，所以private为false</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;cross-env NODE_ENV&#x3D;development webpack-dev-server --open --hot&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;cross-env NODE_ENV&#x3D;production webpack --progress --hide-modules&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;main&quot;: &quot;dist&#x2F;csingruler.js&quot;, &#x2F;&#x2F; 配置main结点，如果不配置，我们在其他项目中就不用import XX from &#39;包名&#39;来引用了，只能以包名作为起点来指定相对的路径</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;vue&quot;: &quot;^2.5.11&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;browserslist&quot;: [</span><br><span class="line">    &quot;&gt; 1%&quot;,</span><br><span class="line">    &quot;last 2 versions&quot;,</span><br><span class="line">    &quot;not ie &lt;&#x3D; 8&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.26.0&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^7.1.2&quot;,</span><br><span class="line">    &quot;babel-preset-env&quot;: &quot;^1.6.0&quot;,</span><br><span class="line">    &quot;babel-preset-stage-3&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">    &quot;better-scroll&quot;: &quot;^1.15.2&quot;,</span><br><span class="line">    &quot;cross-env&quot;: &quot;^5.0.5&quot;,</span><br><span class="line">    &quot;css-loader&quot;: &quot;^0.28.7&quot;,</span><br><span class="line">    &quot;file-loader&quot;: &quot;^1.1.4&quot;,</span><br><span class="line">    &quot;less&quot;: &quot;^3.9.0&quot;,</span><br><span class="line">    &quot;less-loader&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;vue-loader&quot;: &quot;^13.0.5&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.4.4&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^3.6.0&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 指定代码所在的仓库地址</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+https:&#x2F;&#x2F;github.com&#x2F;328921371&#x2F;ruler.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; bug在哪里提</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">  	&quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;328921371&#x2F;ruler&#x2F;issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 项目官网的地址</span><br><span class="line">  &quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;328921371&#x2F;ruler#readme&quot;,</span><br><span class="line">   &#x2F;&#x2F; 指定打包后,包中存在的文件夹</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;dist&quot;,</span><br><span class="line">    &quot;src&quot;</span><br><span class="line">  ],</span><br><span class="line">  &#x2F;&#x2F; 指定关键词</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;vue&quot;,</span><br><span class="line">    &quot;ruler&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改-gitignore文件"><a href="#修改-gitignore文件" class="headerlink" title="修改.gitignore文件"></a>修改.gitignore文件</h3><p>因为要用dist文件夹，所以在.gitignore文件中把dist/去掉。最后长这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">npm-debug.log</span><br><span class="line">yarn-error.log</span><br><span class="line"></span><br><span class="line"># Editor directories and files</span><br><span class="line">.idea</span><br><span class="line">*.suo</span><br><span class="line">*.ntvs*</span><br><span class="line">*.njsproj</span><br><span class="line">*.sln</span><br></pre></td></tr></table></figure>

<h3 id="修改webpack-config-js文件"><a href="#修改webpack-config-js文件" class="headerlink" title="修改webpack.config.js文件"></a>修改webpack.config.js文件</h3><p>主要还是改输出部分,打包成自己想要的js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;),</span><br><span class="line">  publicPath: &#39;&#x2F;dist&#x2F;&#39;,</span><br><span class="line">  filename: &#39;csingruler.js&#39;,</span><br><span class="line">  library: &#39;csingruler&#39;,</span><br><span class="line">  libraryTarget: &#39;umd&#39;,</span><br><span class="line">  umdNamedDefine: true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="本地打包"><a href="#本地打包" class="headerlink" title="本地打包"></a>本地打包</h3><p>npm run build</p>
<p>npm pack</p>
<p>然后在本地生成一个cs-ruler-1.0.1.tgz的包</p>
<h3 id="发布到npm上-注意镜像地址要指向npm的地址"><a href="#发布到npm上-注意镜像地址要指向npm的地址" class="headerlink" title="发布到npm上(注意镜像地址要指向npm的地址)"></a>发布到npm上(注意镜像地址要指向npm的地址)</h3><p><code>npm login</code></p>
<p>登录自己的npm账号,输入姓名,密码,邮箱</p>
<p>然后注意一下返回的字段</p>
<p><code>Logged in as 你的名字 on https://registry.npmjs.org/.</code></p>
<p>这样说明是登录成功的</p>
<p>如果是<code>Logged in as 你的名字 on https://registry.npm.taobao.org/.</code></p>
<p>说明你登录的是淘宝的镜像..后面提交会报403的错误</p>
<p>可以输入一下命令查看当前的登录源：<code>npm config get registry</code></p>
<p>淘宝源，需要切回到npmjs源，输入以下命令： <code>npm config set registry=http://registry.npmjs.org</code></p>
<p>最后再 npm publish 一下就可以了</p>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>这个<a href="https://www.npmjs.com/package/cs-ruler?activeTab=dependencies" target="_blank" rel="noopener">刻度尺组件</a>就是我打包上传的组件,有需要的可以安装使用</p>
<p>以上就是我对npm上传vue组件的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中directives的用法</title>
    <url>/2019/09/19/96-Vue%E4%B8%ADdirectives%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>在Vue-cli总结的时候我就聊到了directives的用法,今天把它用在实战里面</p>
</blockquote>
<a id="more"></a>

<p>在main.js中 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 权限指令,对按钮权限的控制 **&#x2F;</span><br><span class="line">Vue.directive(&#39;has&#39;, &#123;</span><br><span class="line">  bind: function(el, binding) &#123;</span><br><span class="line">    if (!Vue.prototype.$_has(binding.value)) &#123;</span><br><span class="line">			setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">				el.parentNode.removeChild(el)</span><br><span class="line">			&#125;,0)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 权限检查方法（且把该方法添加到vue原型中）</span><br><span class="line">Vue.prototype.$_has &#x3D; function(value) &#123;</span><br><span class="line">  let isExist &#x3D; false</span><br><span class="line">  &#x2F;&#x2F; 从浏览器缓存中获取权限数组（该数组在登入成功后拉取用户的权限信息时保存在浏览器的缓存中</span><br><span class="line">	</span><br><span class="line">	var buttonpermsStr &#x3D; JSON.parse(sessionStorage.getItem(&#39;ButtonList&#39;))</span><br><span class="line">	&#x2F;&#x2F; console.log(buttonpermsStr)</span><br><span class="line">  if (buttonpermsStr &#x3D;&#x3D;&#x3D; undefined || buttonpermsStr &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">  if (buttonpermsStr.indexOf(value) &gt;&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 若在按钮中定义的权限字段能在后端返回的权限数组中能找到，则该按钮可显示</span><br><span class="line">    isExist &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">  return isExist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用的时候在页面中写</p>
<p><code>&lt;Button v-has=&quot;&#39;这里写需要判断的值&#39;&quot; type=&quot;primary&quot; size=&quot;large&quot; @click=&quot;AddListButton&quot;&gt;新增&lt;/Button&gt;</code></p>
<p>以上就是我对Vue中directives用法的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS变量学习</title>
    <url>/2019/09/19/97-CSS%E5%8F%98%E9%87%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>在之前我们聊过scss/sass,今天我们来看看css中的变量</p>
</blockquote>
<a id="more"></a>

<p>文章参考阮一峰老师的 CSS 变量教程,站在巨人的肩膀上看世界…</p>
<h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p>声明变量的时候，变量名前面要加两根连词线（–）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 选择器里面声明了两个变量：--header-color和--Header-Color</span><br><span class="line">body &#123;</span><br><span class="line">  --header-color: #7F583F;</span><br><span class="line">  --Header-Color: #F7EFD2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量名大小写敏感，–header-color和–Header-Color是两个不同变量。</p>
<blockquote>
<p>为什么选择两根连词线（–）表示变量？因为$foo被 Sass 用掉了，@foo被 Less 用掉了。为了不产生冲突，官方的 CSS 变量就改用两根连词线了。</p>
</blockquote>
<h3 id="var-函数"><a href="#var-函数" class="headerlink" title="var() 函数"></a>var() 函数</h3><p>上面定义了变量,现在就要来读取,var()函数用于读取变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  color: var(--header-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>var()函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。</p>
<p><code>color: var(--header-color, #7F583F);</code></p>
<p>第二个参数不处理内部的逗号或空格，都视作参数的一部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var(--pad, 10px 15px 20px);</span><br></pre></td></tr></table></figure>

<p>var()函数还可以用在变量的声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  --primary-color: red;</span><br><span class="line">  --logo-text: var(--primary-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，变量值只能用作属性值，不能用作属性名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.foo &#123;</span><br><span class="line">  --side: margin-top;</span><br><span class="line">  &#x2F;* 无效 *&#x2F;</span><br><span class="line">  var(--side): 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量值的类型"><a href="#变量值的类型" class="headerlink" title="变量值的类型"></a>变量值的类型</h3><p>如果变量值是一个字符串，可以与其他字符串拼接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--bar: &#39;hello&#39;;</span><br><span class="line">--foo: var(--bar)&#39; world&#39;;</span><br></pre></td></tr></table></figure>

<p>如果变量值是数值，不能与数值单位直接连用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.foo &#123;</span><br><span class="line">  --gap: 20;</span><br><span class="line">  &#x2F;* 无效 *&#x2F;</span><br><span class="line">  margin-top: var(--gap)px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，数值与单位直接写在一起，这是无效的。必须使用calc()函数，将它们连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.foo &#123;</span><br><span class="line">  --gap: 20;</span><br><span class="line">  margin-top: calc(var(--gap) * 1px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果变量值带有单位，就不能写成字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 无效 *&#x2F;</span><br><span class="line">.foo &#123;</span><br><span class="line">  --foo: &#39;20px&#39;;</span><br><span class="line">  font-size: var(--foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 有效 *&#x2F;</span><br><span class="line">.foo &#123;</span><br><span class="line">  --foo: 20px;</span><br><span class="line">  font-size: var(--foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的”层叠”（cascade）规则是一致的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  :root &#123; --color: blue; &#125;</span><br><span class="line">  div &#123; --color: green; &#125;</span><br><span class="line">  #alert &#123; --color: red; &#125;</span><br><span class="line">  * &#123; color: var(--color); &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;蓝色&lt;&#x2F;p&gt;</span><br><span class="line">&lt;div&gt;绿色&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;alert&quot;&gt;红色&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>其他的都很好理解,优先级和以前的一样,唯一要注意的就是这个 <code>:root</code>,意思就是根元素,任何选择器都可以读取它们。</p>
<blockquote>
<p>这里需要注意的是,在.vue文件中 :root读取不到,暂时没有找到原因,推荐.vue中还是使用scss</p>
</blockquote>
<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>CSS 是动态的，页面的任何变化，都会导致采用的规则变化。</p>
<p>利用这个特点，可以在响应式布局的media命令里面声明变量，使得不同的屏幕宽度有不同的变量值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  --primary: #7F583F;</span><br><span class="line">  --secondary: #F7EFD2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">  color: var(--primary);</span><br><span class="line">  text-decoration-color: var(--secondary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 768px) &#123;</span><br><span class="line">  body &#123;</span><br><span class="line">    --primary:  #F7EFD2;</span><br><span class="line">    --secondary: #7F583F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h3><p>对于不支持 CSS 变量的浏览器，可以采用下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  color: #7F583F;</span><br><span class="line">  color: var(--primary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>@support</code>命令进行检测。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@supports ( (--a: 0)) &#123;</span><br><span class="line">  &#x2F;* supported *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@supports ( not (--a: 0)) &#123;</span><br><span class="line">  &#x2F;* not supported *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个<code>@supports</code>,可能还有小伙伴不太明白,我再举一个简单的例子</p>
<p><code>display: flex</code> 这个css3的弹性布局肯定都不陌生</p>
<p>但是有一些浏览器不兼容,我们应该怎么办?</p>
<p>在可以兼容的情况下这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@supports (display: flex) &#123;</span><br><span class="line">	div &#123; display: flex; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不能兼容的情况下就用浮动布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@supports not (display: flex) &#123;</span><br><span class="line">	div &#123; float: left; &#125; &#x2F;* 替换样式 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对多个CSS属性的检查可以通过‘or’和‘and’串联起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* and and or *&#x2F;</span><br><span class="line">@supports ((display: -webkit-flex) or</span><br><span class="line">          (display: -moz-flex) or</span><br><span class="line">          (display: flex)) and (-webkit-appearance: caret) &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* use styles here *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="JavaScript-操作"><a href="#JavaScript-操作" class="headerlink" title="JavaScript 操作"></a>JavaScript 操作</h3><p>JavaScript 也可以检测浏览器是否支持 CSS 变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isSupported &#x3D;</span><br><span class="line">  window.CSS &amp;&amp;</span><br><span class="line">  window.CSS.supports &amp;&amp;</span><br><span class="line">  window.CSS.supports(&#39;--a&#39;, 0);</span><br><span class="line"></span><br><span class="line">if (isSupported) &#123;</span><br><span class="line">  &#x2F;* supported *&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;* not supported *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 操作 CSS 变量的写法如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置变量</span><br><span class="line">document.body.style.setProperty(&#39;--primary&#39;, &#39;#7F583F&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读取变量</span><br><span class="line">document.body.style.getPropertyValue(&#39;--primary&#39;).trim();</span><br><span class="line">&#x2F;&#x2F; &#39;#7F583F&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除变量</span><br><span class="line">document.body.style.removeProperty(&#39;--primary&#39;);</span><br></pre></td></tr></table></figure>

<p>这意味着，JavaScript 可以将任意值存入样式表。下面是一个监听事件的例子，事件信息被存入 CSS 变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const docStyle &#x3D; document.documentElement.style;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;mousemove&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">  docStyle.setProperty(&#39;--mouse-x&#39;, e.clientX);</span><br><span class="line">  docStyle.setProperty(&#39;--mouse-y&#39;, e.clientY);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那些对 CSS 无用的信息，也可以放入 CSS 变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--foo: if(x &gt; 5) this.width &#x3D; 10;</span><br></pre></td></tr></table></figure>

<p>上面代码中，–foo的值在 CSS 里面是无效语句，但是可以被 JavaScript 读取。这意味着，可以把样式设置写在 CSS 变量中，让 JavaScript 读取。</p>
<p>所以，CSS 变量提供了 JavaScript 与 CSS 通信的一种途径。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>获取url参数记录</title>
    <url>/2019/09/25/98-%E8%8E%B7%E5%8F%96url%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>简单的获取url做个记录</p>
</blockquote>
<a id="more"></a>

<p>简单,但是又容易忘,又不想刻意的去背,在这里做个简单的记录吧</p>
<h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getUrlParam(name)&#123;</span><br><span class="line">  &#x2F;&#x2F;构造一个含有目标参数的正则表达式对象</span><br><span class="line">  var reg &#x3D; new RegExp(&quot;(^|&amp;)&quot; + name + &quot;&#x3D;([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">  &#x2F;&#x2F;匹配目标参数</span><br><span class="line">  var r &#x3D; window.location.search.substr(1).match(reg);</span><br><span class="line">  &#x2F;&#x2F;返回参数值</span><br><span class="line">  if (r!&#x3D;null) return unescape(r[2]); return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getQueryVariable(variable)&#123;</span><br><span class="line">  var query &#x3D; window.location.search.substring(1);</span><br><span class="line">  var vars &#x3D; query.split(&quot;&amp;&quot;);</span><br><span class="line">  for (var i&#x3D;0;i&lt;vars.length;i++) &#123;</span><br><span class="line">    var pair &#x3D; vars[i].split(&quot;&#x3D;&quot;);</span><br><span class="line">    if(pair[0] &#x3D;&#x3D; variable)&#123;return pair[1];&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有更多的方法就不介绍了,百度上面都有,上面这两个方法是我比较常用的</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>html带拼音的标签</title>
    <url>/2019/09/25/99-html%E5%B8%A6%E6%8B%BC%E9%9F%B3%E7%9A%84%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

<blockquote>
<p>偶然逛知乎的时候看到的一个平时都注意不到的标签ruby</p>
</blockquote>
<a id="more"></a>

<p>用户也很简单</p>
<p><code>&lt;ruby&gt;拼音&lt;rt&gt;pinyin&lt;/rt&gt;&lt;/ruby&gt;</code></p>
<p><img src="https://pic1.zhimg.com/80/v2-7392e83d29724f7313f3117a1aeaf834_hd.jpg" alt="图"></p>
<p>就是文字上分的拼音要自己打,可是这样没有音标</p>
<p>于是用搜狗输入法，输入带声调的字母(软键盘中选择拼音字母)</p>
<p><code>&lt;ruby&gt;拼音&lt;rt&gt;pīngyīng&lt;/rt&gt;&lt;/ruby&gt;</code></p>
<blockquote>
<p>ruby支持大多数新版浏览器</p>
</blockquote>
<p>需要注意的是,拼音的长度不固定,所以可能和文字对不齐,可以这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ruby&gt;拼&lt;rt&gt;pīng&lt;&#x2F;rt&gt;&lt;&#x2F;ruby&gt;</span><br><span class="line">&lt;ruby&gt;音&lt;rt&gt;yīng&lt;&#x2F;rt&gt;&lt;&#x2F;ruby&gt;</span><br></pre></td></tr></table></figure>

<p>功能很简单,可能项目中也不一定用得到,但是很有趣,做一个小小的记录</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
</search>
