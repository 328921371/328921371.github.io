<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈先生的小前端</title>
  
  
  <link href="https://www.chensheng.group/atom.xml" rel="self"/>
  
  <link href="https://www.chensheng.group/"/>
  <updated>2024-06-04T16:39:24.078Z</updated>
  <id>https://www.chensheng.group/</id>
  
  <author>
    <name>陈晟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sourceTree中使用SSH</title>
    <link href="https://www.chensheng.group/2024/06/03/165-sourceTree%E4%B8%AD%E4%BD%BF%E7%94%A8SSH/"/>
    <id>https://www.chensheng.group/2024/06/03/165-sourceTree%E4%B8%AD%E4%BD%BF%E7%94%A8SSH/</id>
    <published>2024-06-03T15:33:00.000Z</published>
    <updated>2024-06-04T16:39:24.078Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>在GitHub中配置SSH公钥</p></blockquote><span id="more"></span><p>之前其实有写过<a href="https://www.chensheng.group/2021/08/31/143-%E4%BD%BF%E7%94%A8SSH%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2/">SSH</a> , 但是并没有具体写出git以及sourceTree是怎么配置的，在这里补充一下</p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ol><li><strong>安装 SourceTree</strong>：从 [SourceTree 官方网站]下载并安装。</li><li><strong>配置 SSH 密钥</strong>：生成 SSH 密钥对，并将公钥添加到 GitHub 的 SSH 密钥设置中。</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-生成-SSH-密钥（如果尚未生成）"><a href="#1-生成-SSH-密钥（如果尚未生成）" class="headerlink" title="1. 生成 SSH 密钥（如果尚未生成）"></a>1. 生成 SSH 密钥（如果尚未生成）</h3><h4 id="Windows-和-macOS"><a href="#Windows-和-macOS" class="headerlink" title="Windows 和 macOS"></a>Windows 和 macOS</h4><ol><li><p>打开终端（macOS）或 Git Bash（Windows）。</p></li><li><p>运行以下命令生成 SSH 密钥：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>按提示完成密钥生成过程。</p></li><li><p>将生成的公钥内容添加到 GitHub 的 SSH 密钥设置中。公钥文件通常位于</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.ssh/id_ed25519.pub</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-将公钥添加到-GitHub"><a href="#2-将公钥添加到-GitHub" class="headerlink" title="2. 将公钥添加到 GitHub"></a>2. 将公钥添加到 GitHub</h3><ol><li>登录 GitHub。</li><li>点击右上角的头像，然后选择“Settings”。</li><li>在左侧菜单中选择“SSH and GPG keys”。</li><li>点击“New SSH key”按钮。</li><li>输入一个标题（例如“SourceTree Key”），然后将 <code>id_ed25519.pub</code> 文件中的内容粘贴到“Key”字段中。</li><li>点击“Add SSH key”。</li></ol><h3 id="3-添加-SSH-密钥到-SSH-代理"><a href="#3-添加-SSH-密钥到-SSH-代理" class="headerlink" title="3. 添加 SSH 密钥到 SSH 代理"></a>3. 添加 SSH 密钥到 SSH 代理</h3><h4 id="macOS-和-Windows（使用-OpenSSH）"><a href="#macOS-和-Windows（使用-OpenSSH）" class="headerlink" title="macOS 和 Windows（使用 OpenSSH）"></a>macOS 和 Windows（使用 OpenSSH）</h4><ol><li><p>启动 SSH 代理：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure></li><li><p>添加私钥到 SSH 代理：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-配置-SourceTree-使用-SSH"><a href="#4-配置-SourceTree-使用-SSH" class="headerlink" title="4. 配置 SourceTree 使用 SSH"></a>4. 配置 SourceTree 使用 SSH</h3><ol><li>打开 SourceTree。</li><li>进入“工具”菜单，选择“选项”。</li></ol><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul><li>在“Git”选项卡下，将 SSH 客户端设置为“OpenSSH”或“PuTTY&#x2F;Plink”（取决于你使用的 SSH 客户端）。</li></ul><h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><ul><li>在“Git”选项卡下，确保 SourceTree 使用系统的 SSH 客户端。</li></ul><h3 id="5-克隆-Git-仓库"><a href="#5-克隆-Git-仓库" class="headerlink" title="5. 克隆 Git 仓库"></a>5. 克隆 Git 仓库</h3><ol><li>点击 SourceTree 的“克隆&#x2F;新建”按钮。</li><li>在弹出的窗口中，输入 GitHub 仓库的 SSH URL（例如 <code>git@github.com:username/repository.git</code>）。</li><li>选择本地路径以存储克隆的仓库。</li><li>点击“克隆”按钮。</li></ol><h3 id="6-验证连接"><a href="#6-验证连接" class="headerlink" title="6. 验证连接"></a>6. 验证连接</h3><p>确保配置正确后，SourceTree 将通过 SSH 成功克隆仓库。如果遇到连接问题，请检查以下几点：</p><ol><li>SSH 密钥已正确添加到 GitHub。</li><li>SSH 代理正在运行，并且密钥已添加到代理中。</li><li>SourceTree 的 SSH 客户端配置正确。</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1-SSH-密钥未缓存"><a href="#1-SSH-密钥未缓存" class="headerlink" title="1. SSH 密钥未缓存"></a>1. SSH 密钥未缓存</h3><p>如果在克隆仓库时提示未缓存密钥指纹，请手动添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure><p>以上就是我对sourceTree使用SSH拉取git的理解，如有错误，欢迎大佬指出 </p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;在GitHub中配置SSH公钥&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GitHub" scheme="https://www.chensheng.group/categories/GitHub/"/>
    
    
    <category term="GitHub" scheme="https://www.chensheng.group/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>vue打包模块化配置</title>
    <link href="https://www.chensheng.group/2023/03/16/164-vue%E6%89%93%E5%8C%85%E6%A8%A1%E5%9D%97%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.chensheng.group/2023/03/16/164-vue%E6%89%93%E5%8C%85%E6%A8%A1%E5%9D%97%E5%8C%96%E9%85%8D%E7%BD%AE/</id>
    <published>2023-03-16T10:33:00.000Z</published>
    <updated>2024-06-02T16:07:19.379Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>同一个项目给不同的环境配置打包命令</p></blockquote><span id="more"></span><p>有时候项目中可能会遇到,某一些模块,这个项目需要,某一些模块另外一个项目需要,今天记录几个自己平常项目中比较常用的办法</p><p>假设现在有一个项目,A城市有一个单独的模块,B城市也有一个单独的模块,同时他们还有两个共同的页面,我们需要怎么区分呢</p><p>先看看最后有哪些文件</p><p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/156-1-vue%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E8%A1%8C.png" alt="文件图片"></p><h3 id="添加文件模块"><a href="#添加文件模块" class="headerlink" title="添加文件模块"></a>添加文件模块</h3><p>首先在views下创建四个文件夹 cityA,cityB,pageA,pageB分别代表了刚刚描述的模块</p><p>每个文件夹下新增 <code>index.js</code>, <code>index.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.js中的代码就是类似这样的,路径什么的都可以自己定义 --&gt;</span><br><span class="line">export const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/city/a&quot;,</span><br><span class="line">    name: &quot;cityA&quot;,</span><br><span class="line">    component: () =&gt; import(/* webpackChunkName: &quot;cityA&quot; */ &quot;./index.vue&quot;),</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &quot;定制化A页面&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.vue中的代码就是类似这样的,具体是自己的页面--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;我是A城市的定制化页面&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><div class="note info"><p>之所以每个文件对应一个index.js的路由,也是一个拆分模块的方法,这里只是提供一个思路,按照项目实际开发的来就好</p></div><blockquote><p>之所以这样,是为了解耦,解耦后就可以根据功能模块组合出各种功能不一的系统</p></blockquote><h3 id="添加配置项"><a href="#添加配置项" class="headerlink" title="添加配置项"></a>添加配置项</h3><p>在src下新增一个 config 文件夹, 添加三个文件 <code>cityA.js</code>,<code>cityB.js</code>,<code>index.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; routes as pageA &#125; from &quot;../views/pageA/index.js&quot;;</span><br><span class="line">import &#123; routes as pageB &#125; from &quot;../views/pageB/index.js&quot;;</span><br><span class="line">import &#123; routes as cityA &#125; from &quot;../views/cityA/index.js&quot;;</span><br><span class="line"></span><br><span class="line">export const routes = [...pageA, ...pageB, ...cityA];</span><br><span class="line">export const pageTitle = &quot;城市A的标题&quot;;</span><br><span class="line">export const logoUrl = &quot;城市A的logo&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; routes as pageA &#125; from &quot;../views/pageA/index.js&quot;;</span><br><span class="line">import &#123; routes as pageB &#125; from &quot;../views/pageB/index.js&quot;;</span><br><span class="line">import &#123; routes as cityA &#125; from &quot;../views/cityA/index.js&quot;;</span><br><span class="line"></span><br><span class="line">export const routes = [...pageA, ...pageB, ...cityA];</span><br><span class="line">export const pageTitle = &quot;城市A的标题&quot;;</span><br><span class="line">export const logoUrl = &quot;城市A的logo&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; routes as pageA &#125; from &quot;../views/pageA/index.js&quot;;</span><br><span class="line">import &#123; routes as pageB &#125; from &quot;../views/pageB/index.js&quot;;</span><br><span class="line">import &#123; routes as cityA &#125; from &quot;../views/cityA/index.js&quot;;</span><br><span class="line"></span><br><span class="line">export const routes = [...pageA, ...pageB, ...cityA];</span><br><span class="line">export const pageTitle = &quot;城市A的标题&quot;;</span><br><span class="line">export const logoUrl = &quot;城市A的logo&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export * from &#x27;./cityA&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>这个文件夹的目的,是为了让路由表统一拉取到对应的配置</p></blockquote><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><p>这里路由把config中的index.js的配置导入后,在对应的路由表中直接渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import VueRouter from &quot;vue-router&quot;;</span><br><span class="line">import Home from &quot;../views/Home.vue&quot;;</span><br><span class="line">import &#123; routes, pageTitle &#125; from &quot;../config&quot;;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line">const routesList = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/&quot;,</span><br><span class="line">    name: &quot;Home&quot;,</span><br><span class="line">    component: Home,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/about&quot;,</span><br><span class="line">    name: &quot;About&quot;,</span><br><span class="line">    component: () =&gt;</span><br><span class="line">      import(/* webpackChunkName: &quot;about&quot; */ &quot;../views/About.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">  ...routes,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: routesList,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.beforeEach(async (to, from, next) =&gt; &#123;</span><br><span class="line">  document.title = `$&#123;to.meta.title || &quot;&quot;&#125;$&#123;pageTitle || &quot;&quot;&#125;`;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>在根目录下新增一个script文件,新增server.js文件和build.js</p><p>各个语句的说明直接写在代码里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// shelljs是用来执行命令的</span><br><span class="line">const shell = require(&#x27;shelljs&#x27;);</span><br><span class="line">// inquirer是用来写交互式命令行的</span><br><span class="line">const inquirer = require(&#x27;inquirer&#x27;);</span><br><span class="line">// chalk是用来装扮命令行命令的（比如在命令行输入个红色的字）</span><br><span class="line">const chalk = require(&#x27;chalk&#x27;);</span><br><span class="line">// node自带的fs文件模块</span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">const writeFile = (path, content) =&gt; &#123;</span><br><span class="line">  return new Promise((reslove, reject) =&gt; &#123;</span><br><span class="line">    fs.writeFile(path,</span><br><span class="line">      content,&#x27;utf8&#x27;, () =&gt; &#123;</span><br><span class="line">      reslove(true);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const release = new Map([</span><br><span class="line">  [&#x27;cityA定制版&#x27;, &quot;export * from &#x27;./cityA&#x27;;&quot;],</span><br><span class="line">  [&#x27;city定制版&#x27;, &quot;export * from &#x27;./cityB&#x27;;&quot;],</span><br><span class="line">])</span><br><span class="line">const env = new Map([</span><br><span class="line">  [&#x27;生产环境&#x27;, &quot;NODE_ENV = production&quot;],</span><br><span class="line">  [&#x27;测试环境&#x27;, &quot;NODE_ENV = testing&quot;],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">const build = async () =&gt; &#123;</span><br><span class="line">  const res = await inquirer.prompt([</span><br><span class="line">    &#123;</span><br><span class="line">      type: &#x27;list&#x27;,</span><br><span class="line">      name: &#x27;release&#x27;,</span><br><span class="line">      message: &#x27;请选择你要运行的版本？&#x27;,</span><br><span class="line">      choices: [&#x27;cityA定制版&#x27;, &#x27;cityB定制版&#x27;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: &#x27;list&#x27;,</span><br><span class="line">      name: &#x27;env&#x27;,</span><br><span class="line">      message: &#x27;请选择你要运行的环境？&#x27;,</span><br><span class="line">      choices: [&#x27;生产环境&#x27;, &#x27;测试环境&#x27;]</span><br><span class="line">    &#125;,</span><br><span class="line">  ]);</span><br><span class="line">  await Promise.all([writeFile(`$&#123;process.cwd()&#125;/src/config/index.js`, release.get(res.release)),writeFile(`$&#123;process.cwd()&#125;/.env`, env.get(res.env))]);</span><br><span class="line">  console.log(chalk.green(`您要运行的是$&#123;res.env&#125;---$&#123;res.release&#125;,正在为您运行......`));</span><br><span class="line">  shell.exec(&#x27;vue-cli-service serve&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">build();</span><br><span class="line"></span><br></pre></td></tr></table></figure> <blockquote class="blockquote-center"><p>build.js的文件一样,只是最后运行的时候 是 ‘vue-cli-service build’ </p></blockquote><blockquote><p>这边相当于把你选择的配置项,修改在 config&#x2F;index.js 和 .env中,从而达到不同项目引入不同模块的目的</p></blockquote><h3 id="运行文件"><a href="#运行文件" class="headerlink" title="运行文件"></a>运行文件</h3><p>package.json 文件需要修改一下运行配置 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">&quot;dev&quot;: &quot;node script/server.js&quot;,</span><br><span class="line">&quot;build&quot;: &quot;node script/build.js&quot;,</span><br></pre></td></tr></table></figure><p>这样dev启动的时候默认走的就是我们server.js</p><div class="note primary"><p>这只是其中一种的思路,按照文件夹的形式进行模块化的区分,如果嫌弃麻烦,也可以把配置都写在一个js里面,导出这个js在vue的原型链里面,在代码里去做判断,都是可以的</p></div><p>以上就是我对模块化打包的理解，如有错误，欢迎大佬指出</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;同一个项目给不同的环境配置打包命令&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Vue" scheme="https://www.chensheng.group/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://www.chensheng.group/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>uni-app模块化打包配置</title>
    <link href="https://www.chensheng.group/2023/01/27/163-uni-app%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%93%E5%8C%85/"/>
    <id>https://www.chensheng.group/2023/01/27/163-uni-app%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%93%E5%8C%85/</id>
    <published>2023-01-27T15:17:33.000Z</published>
    <updated>2024-06-02T16:07:19.379Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>如何实现一套代码，部署多个微信小程序</p></blockquote><span id="more"></span><p>有些时候会遇到一个需求，同一个项目，但是有一些模块不同，打包到不同的小程序，这是我们就可以通过配置来解决</p><p>微信小程序的限制我们都知道，不可以动态的新增tabBar，而且appid的配置，都是在manifest.json 中进行配置的</p><p>所以我们只要通过js脚本来修改这两个文件就可以了</p><p>新增一个<code>manifest.js</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 读取 manifest.json ，修改后重新写入</span><br><span class="line">// 读取 pages.json ，修改后重新写入</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const manifestPath = &#x27;./manifest.json&#x27;</span><br><span class="line">const pagesPath = &#x27;./pages.json&#x27;</span><br><span class="line">let Manifest = fs.readFileSync(manifestPath, &#123; encoding: &#x27;utf-8&#x27; &#125;)</span><br><span class="line">let Pages = fs.readFileSync(pagesPath, &#123; encoding: &#x27;utf-8&#x27; &#125;)</span><br><span class="line"></span><br><span class="line">function replaceManifest(path, value) &#123;</span><br><span class="line">  const arr = path.split(&#x27;.&#x27;)</span><br><span class="line">  const len = arr.length</span><br><span class="line">  const lastItem = arr[len - 1]</span><br><span class="line"></span><br><span class="line">  let i = 0</span><br><span class="line">  let ManifestArr = Manifest.split(/\n/)</span><br><span class="line"></span><br><span class="line">  for (let index = 0; index &lt; ManifestArr.length; index++) &#123;</span><br><span class="line">    const item = ManifestArr[index]</span><br><span class="line">    if (new RegExp(`&quot;$&#123;arr[i]&#125;&quot;`).test(item)) ++i;</span><br><span class="line">    if (i === len) &#123;</span><br><span class="line">      const hasComma = /,/.test(item)</span><br><span class="line">      ManifestArr[index] = item.replace(new RegExp(`&quot;$&#123;lastItem&#125;&quot;[\\s\\S]*:[\\s\\S]*`), `&quot;$&#123;lastItem&#125;&quot;: $&#123;value&#125;$&#123;hasComma ? &#x27;,&#x27; : &#x27;&#x27;&#125;`)</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Manifest = ManifestArr.join(&#x27;\n&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function replacePages(path, value) &#123;</span><br><span class="line">  const arr = path.split(&#x27;.&#x27;)</span><br><span class="line">  const len = arr.length</span><br><span class="line">  const lastItem = arr[len - 1]</span><br><span class="line">  let i = 0</span><br><span class="line">  let PagesArr = Pages.split(/\n/)</span><br><span class="line">  for (let index = 0; index &lt; PagesArr.length; index++) &#123;</span><br><span class="line">    const item = PagesArr[index]</span><br><span class="line">    if (new RegExp(`&quot;$&#123;arr[i]&#125;&quot;`).test(item)) ++i;</span><br><span class="line">    if (i === len) &#123;</span><br><span class="line">      const hasComma = /,/.test(item)</span><br><span class="line">      PagesArr[index] = item.replace(new RegExp(`&quot;$&#123;lastItem&#125;&quot;[\\s\\S]*:[\\s\\S]*`), `&quot;$&#123;lastItem&#125;&quot;: $&#123;value&#125;$&#123;hasComma ? &#x27;&#x27; : &#x27;&#x27;&#125;`)</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Pages = PagesArr.join(&#x27;\n&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 配置appid</span><br><span class="line">const config = require(&#x27;./config.js&#x27;);</span><br><span class="line">replaceManifest(&#x27;appid&#x27;, config.config.appid)</span><br><span class="line">replaceManifest(&#x27;name&#x27;, config.config.name)</span><br><span class="line">replaceManifest(&#x27;mp-weixin.appid&#x27;, config.config.weixinAppid)</span><br><span class="line">// 配置tabBar</span><br><span class="line">replacePages(&#x27;tabBar.list&#x27;, JSON.stringify(config.config.list))</span><br><span class="line"></span><br><span class="line">console.log(config.config.name + &#x27;配置成功,可以开始打包......&#x27;)</span><br><span class="line"></span><br><span class="line">fs.writeFileSync(manifestPath, Manifest, &#123;</span><br><span class="line">  &quot;flag&quot;: &quot;w&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.writeFileSync(pagesPath, Pages, &#123;</span><br><span class="line">  &quot;flag&quot;: &quot;w&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自己需要的配置可以写在<code>config.js</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">var NODE_ENV = &#x27;项目A&#x27;</span><br><span class="line">// var NODE_ENV = &#x27;项目B&#x27;</span><br><span class="line"></span><br><span class="line">var config = &#123;&#125;</span><br><span class="line"></span><br><span class="line">switch (NODE_ENV) &#123;</span><br><span class="line">  case &#x27;项目A&#x27;:</span><br><span class="line">    config = &#123;</span><br><span class="line">      title: &#x27;项目A&#x27;, // 全局通用标题</span><br><span class="line">      appid: &#x27;&quot;__UNI__XXXX&quot;&#x27;, // 打包的appid</span><br><span class="line">      weixinAppid: &#x27;&quot;XXXXXX&quot;&#x27;,</span><br><span class="line">      name: &#x27;&quot;A&quot;&#x27;, // 应用名称</span><br><span class="line">      list: [</span><br><span class="line">      &#123;</span><br><span class="line">      &quot;pagePath&quot;: &quot;pages/index/index&quot;,</span><br><span class="line">      &quot;iconPath&quot;: &quot;static/tab/tab-member.png&quot;,</span><br><span class="line">      &quot;selectedIconPath&quot;: &quot;static/tab/tab-member-current.png&quot;,</span><br><span class="line">      &quot;text&quot;: &quot;我的&quot;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">      &quot;pagePath&quot;: &quot;pages/member/member&quot;,</span><br><span class="line">      &quot;iconPath&quot;: &quot;static/tab/tab-member.png&quot;,</span><br><span class="line">      &quot;selectedIconPath&quot;: &quot;static/tab/tab-member-current.png&quot;,</span><br><span class="line">      &quot;text&quot;: &quot;商户&quot;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">      &quot;pagePath&quot;: &quot;pages/activity/activity&quot;,</span><br><span class="line">      &quot;iconPath&quot;: &quot;static/tab/tab-member.png&quot;,</span><br><span class="line">      &quot;selectedIconPath&quot;: &quot;static/tab/tab-member-current.png&quot;,</span><br><span class="line">      &quot;text&quot;: &quot;活动&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  case &#x27;项目B&#x27;:</span><br><span class="line">    config = &#123;</span><br><span class="line">      title: &#x27;项目B&#x27;, // 全局通用标题</span><br><span class="line">      appid: &#x27;&quot;__UNI__XXXXXX&quot;&#x27;, // 打包的appid</span><br><span class="line">      weixinAppid: &#x27;&quot;xxxxxx&quot;&#x27;,</span><br><span class="line">      name: &#x27;&quot;B&quot;&#x27;, // 应用名称</span><br><span class="line">      list: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;pagePath&quot;: &quot;pages/index/index&quot;,</span><br><span class="line">          &quot;iconPath&quot;: &quot;static/tab/tab-member.png&quot;,</span><br><span class="line">          &quot;selectedIconPath&quot;: &quot;static/tab/tab-member-current.png&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;我的&quot;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          &quot;pagePath&quot;: &quot;pages/activity/activity&quot;,</span><br><span class="line">          &quot;iconPath&quot;: &quot;static/tab/tab-member.png&quot;,</span><br><span class="line">          &quot;selectedIconPath&quot;: &quot;static/tab/tab-member-current.png&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;活动&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  config</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>运行或者发布之前，执行一下manifest.js文件</p></blockquote><p>这上面，是使用hbuilder创建项目，可以这样弄，如果uni-app的项目是通过命令行来创建的，那就可以全自动化了，在命令中选择要启动的版本是哪个</p><p>命令行的配置和vue-cli模块化的配置是一样的，下次再一起学习</p><p>以上就是我对uni-app模块化打包的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;如何实现一套代码，部署多个微信小程序&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="uniApp" scheme="https://www.chensheng.group/categories/uniApp/"/>
    
    
    <category term="uniApp" scheme="https://www.chensheng.group/tags/uniApp/"/>
    
  </entry>
  
  <entry>
    <title>小程序登陆锁</title>
    <link href="https://www.chensheng.group/2022/12/06/162-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E9%99%86%E9%94%81/"/>
    <id>https://www.chensheng.group/2022/12/06/162-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E9%99%86%E9%94%81/</id>
    <published>2022-12-06T07:14:13.000Z</published>
    <updated>2024-06-02T16:07:19.379Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>超时登录我们肯定都遇到过,PC端的解决办法经常都是返回到登录页重新登录,那小程序里面呢,要怎么实现</p></blockquote><span id="more"></span><p>小程序用户在使用中,我们都知道,肯定不能退出到首页让用户重新登录,不然用户体验会很差,大致分为以下几种问题</p><blockquote><p>一般情况下,小程序token不会设置的那么短</p></blockquote><ol><li><p>调用接口后,后端返回超时登录,这时候需要重新登录获取token</p></li><li><p>获取token后,需要重新调用之前的接口,把新的token带上,重新获取数据,让用户无感登录</p></li><li><p>如果页面同时请求了多个异步接口,只能调用一次登录的接口,否则会因为重新调用接口后,每个接口附带的token都不同,导致之前的token都失效了</p></li></ol><p>带着问题,我们来看看如何解决</p><div class="note info"><p>我们先来想想解决问题的思路</p></div><ol><li>判断接口是否403超时登陆</li><li>超时登录的时候记录当前的接口请求,并重新调用登录接口</li><li>登录后重新调用刚刚记录的接口请求,并替换token</li><li>如果有多个接口,判断第一个接口调用了登录,其他接口进行等待,不继续调用登录接口</li></ol><p>这里有几个难点,如何知道登录完成了,再去调用之前的接口,如何确保其他接口可以在登录完成后才继续执行</p><p>直接看代码,注释和解释都在代码里</p><p>首先创建<code>request.js</code>文件和<code>login.js</code>文件</p><h3 id="request-js"><a href="#request-js" class="headerlink" title="request.js"></a>request.js</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">import &#123; refreshLogin&#125; from &quot;./login.js&quot;;</span><br><span class="line"></span><br><span class="line">let DELAYED = 1000; // 设置队列延时</span><br><span class="line">// 创建axios实例</span><br><span class="line">const service = axios.create(&#123;</span><br><span class="line">  baseURL: process.env.BASE_API, // api 的 base_url</span><br><span class="line">  timeout: 60000 // 请求超时时间</span><br><span class="line">&#125;)</span><br><span class="line">// request拦截器</span><br><span class="line">service.interceptors.request.use((config) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    try&#123;</span><br><span class="line">      config.data = JSON.parse(config.data)</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">      //TODO handle the exception</span><br><span class="line">    &#125;</span><br><span class="line">    if(config.data.token == undefined)&#123;</span><br><span class="line">      config.data.token = uni.getStorageSync(&#x27;LOGIN_TOKEN&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return config</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    Promise.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// response 拦截器</span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">(response) =&gt; &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      const res = response.data</span><br><span class="line">      // 先判断最外层</span><br><span class="line">      if (res.errno !== &#x27;10000&#x27;) &#123;</span><br><span class="line">        // 无效TOKEN,如过期等,则执行登出操作</span><br><span class="line">        if(res.errno == &#x27;90005&#x27;) &#123;&#125; else &#123;</span><br><span class="line">          // 统一报错处理</span><br><span class="line">          uni.hideToast();</span><br><span class="line">          uni.showToast(&#123;</span><br><span class="line">            title: res.errmsg,</span><br><span class="line">            duration: 5000,</span><br><span class="line">            icon: &#x27;none&#x27;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(response.data)</span><br><span class="line">      &#125; else if (res.data[0].sub_errno !== &#x27;10000&#x27;) &#123;</span><br><span class="line">        if(res.data[0].sub_errno == &#x27;403&#x27;) &#123;</span><br><span class="line">      // 这里需要重新登录</span><br><span class="line">          const app = getApp();</span><br><span class="line">          const LOGIN_SWITCH = app.globalData.LOGIN_SWITCH;// login锁，确保没有登录冲突</span><br><span class="line">          if(LOGIN_SWITCH)&#123; //如果已锁说明有在重新登录,只需要等待一下 继续请求</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              response.config.data = JSON.parse(response.config.data)</span><br><span class="line">              response.config.data.token = uni.getStorageSync(&#x27;LOGIN_TOKEN&#x27;)</span><br><span class="line">              resolve(service(response.config))</span><br><span class="line">            &#125;, DELAYED);</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">            //重新登录并继续请求</span><br><span class="line">            refreshLogin().then(()=&gt;&#123;</span><br><span class="line">              response.config.data = JSON.parse(response.config.data)</span><br><span class="line">              response.config.data.token = uni.getStorageSync(&#x27;LOGIN_TOKEN&#x27;)</span><br><span class="line">              resolve(service(response.config))</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">          return;</span><br><span class="line">        &#125;  else &#123;</span><br><span class="line">          uni.hideToast();</span><br><span class="line">          resolve(response.data)</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 正常数据返回</span><br><span class="line">        resolve(response.data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    let errorObj = &#123;</span><br><span class="line">    data: [],</span><br><span class="line">      errmsg: &#x27;数据返回失败！&#x27;,</span><br><span class="line">      errno: &#x27;3289&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error &amp;&amp; error.response) &#123;</span><br><span class="line">      switch (error.response.status) &#123;</span><br><span class="line">      case 400: errorObj.message = &#x27;(c1400)&#x27; ; break; // 请求错误</span><br><span class="line">      case 401: errorObj.message = &#x27;(c1401)&#x27;; break; // 未授权</span><br><span class="line">      case 403: errorObj.message = &#x27;(c1403)&#x27;; break; // 拒绝访问</span><br><span class="line">      case 404: errorObj.message = &#x27;(c1404)&#x27;; break; // 请求出错</span><br><span class="line">      case 408: errorObj.message = &#x27;(c1408)&#x27;; break; // 请求超时</span><br><span class="line">      case 500: errorObj.message = &#x27;(c1500)&#x27;; break; // 服务器错误</span><br><span class="line">      case 501: errorObj.message = &#x27;(c1501)&#x27;; break; // 服务未实现</span><br><span class="line">      case 502: errorObj.message = &#x27;(c1502)&#x27;; break; // 网络错误</span><br><span class="line">      case 503: errorObj.message = &#x27;(c1503)&#x27;; break; // 服务不可用</span><br><span class="line">      case 504: errorObj.message = &#x27;(c1504)&#x27;; break; // 网络超时</span><br><span class="line">      case 505: errorObj.message = &#x27;(c1505)&#x27;; break; // HTTP版本不受支持</span><br><span class="line">      default: errorObj.message = `连接出错($&#123;error.response.status&#125;)!` // 连接出错</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      errorObj.message = &#x27;(c3289)&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    uni.hideToast();</span><br><span class="line">    uni.showToast(&#123;</span><br><span class="line">      title: &#x27;网络繁忙,请稍后再试&#x27;,</span><br><span class="line">      duration: 2000,</span><br><span class="line">      icon: &#x27;none&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">    Promise.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">//用来适配uniapp的语法</span><br><span class="line">axios.defaults.adapter = function(config) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">var settle = require(&#x27;axios/lib/core/settle&#x27;);</span><br><span class="line">var buildURL = require(&#x27;axios/lib/helpers/buildURL&#x27;);</span><br><span class="line">uni.request(&#123;</span><br><span class="line">method: config.method.toUpperCase(),</span><br><span class="line">url: buildURL(config.url, config.params, config.paramsSerializer),</span><br><span class="line">// url: config.baseURL + buildURL(config.url, config.params, config.paramsSerializer),</span><br><span class="line">header: config.headers,</span><br><span class="line">data: config.data,</span><br><span class="line">dataType: config.dataType,</span><br><span class="line">responseType: config.responseType,</span><br><span class="line">sslVerify: config.sslVerify,</span><br><span class="line">complete: function complete(response) &#123;</span><br><span class="line">response = &#123;</span><br><span class="line">data: response.data,</span><br><span class="line">status: response.statusCode,</span><br><span class="line">errMsg: response.errMsg,</span><br><span class="line">header: response.header,</span><br><span class="line">config: config</span><br><span class="line">&#125;;</span><br><span class="line">settle(resolve, reject, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default service</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="login-js"><a href="#login-js" class="headerlink" title="login.js"></a>login.js</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#x27;./request.js&#x27;</span><br><span class="line">import utils from &#x27;./utils.js&#x27;</span><br><span class="line">import api from &#x27;./api.js&#x27;</span><br><span class="line">/**</span><br><span class="line"> * 重新登录======token不存在或过期</span><br><span class="line"> */</span><br><span class="line">export const refreshLogin = () =&gt; &#123;</span><br><span class="line">  const app = getApp();</span><br><span class="line">  app.globalData.LOGIN_SWITCH = true;</span><br><span class="line">  uni.removeStorageSync(&#x27;LOGIN_TOKEN&#x27;);</span><br><span class="line">  return new Promise(async (resolve, reject) =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      const code = await getWxCode();</span><br><span class="line">      let json = &#123;</span><br><span class="line">        action: &#x27;weixinLogin&#x27;,</span><br><span class="line">        wxcode: code</span><br><span class="line">      &#125;</span><br><span class="line">      axios.request(&#123;</span><br><span class="line">      url: api.url,</span><br><span class="line">      method: &quot;POST&quot;,</span><br><span class="line">      data: json,</span><br><span class="line">      timeout: 10000</span><br><span class="line">      &#125;).then((response)=&gt;&#123;</span><br><span class="line">        let token = response.data[0].token;</span><br><span class="line">        uni.setStorageSync(&#x27;LOGIN_TOKEN&#x27;, token);</span><br><span class="line">        app.globalData.LOGIN_SWITCH = false;</span><br><span class="line">        resolve(token);</span><br><span class="line">      &#125;).catch((err)=&gt;&#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取 小程序的code</span><br><span class="line"> */</span><br><span class="line">export const getWxCode = () =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    uni.login(&#123;</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        if (res.code) &#123;</span><br><span class="line">          resolve(res.code);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          utils.toast(&#x27;登录失败，请重新进入小程序&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>简单来说,就是当超时的时候,只要有重新登录,就上个锁,其他的接口一直轮询等待</p></blockquote><p>以上就是我对登陆锁的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;超时登录我们肯定都遇到过,PC端的解决办法经常都是返回到登录页重新登录,那小程序里面呢,要怎么实现&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="uniApp" scheme="https://www.chensheng.group/categories/uniApp/"/>
    
    
    <category term="uniApp" scheme="https://www.chensheng.group/tags/uniApp/"/>
    
  </entry>
  
  <entry>
    <title>uni-app配置axios</title>
    <link href="https://www.chensheng.group/2022/11/12/161-uni-app%E9%85%8D%E7%BD%AEaxios/"/>
    <id>https://www.chensheng.group/2022/11/12/161-uni-app%E9%85%8D%E7%BD%AEaxios/</id>
    <published>2022-11-12T05:14:23.000Z</published>
    <updated>2024-06-02T16:07:19.379Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>axios我们都使用过，怎么在uni-app中使用呢</p></blockquote><span id="more"></span><p>uni-app的官网提供了 <code>uni.request</code> 作为请求网络的API，但是我们如果习惯了使用axios，那就要在uni-app中引入了</p><p>首先，在项目中引入 axios的包是必不可少的 <code>npm install</code> 安装即可</p><p>然后在工具包中新建一个<code>request.js</code>的文件，用来封装我们的axios</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line"></span><br><span class="line">// 创建axios实例</span><br><span class="line">const service = axios.create(&#123;</span><br><span class="line">  baseURL: process.env.BASE_API, // api 的 base_url</span><br><span class="line">  timeout: 60000 // 请求超时时间</span><br><span class="line">&#125;)</span><br><span class="line">// request拦截器</span><br><span class="line">service.interceptors.request.use((config) =&gt; &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">      config.data = JSON.parse(config.data)</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">      //TODO handle the exception</span><br><span class="line">    &#125;</span><br><span class="line">    return config</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    Promise.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// response 拦截器</span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">(response) =&gt; &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      const res = response.data </span><br><span class="line">      // 正常数据返回</span><br><span class="line">      resolve(response.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    if (error &amp;&amp; error.response) &#123;</span><br><span class="line">      switch (error.response.status) &#123;</span><br><span class="line">      case 400: errorObj.message = &#x27;(c1400)&#x27; ; break; // 请求错误</span><br><span class="line">      case 401: errorObj.message = &#x27;(c1401)&#x27;; break; // 未授权</span><br><span class="line">      case 403: errorObj.message = &#x27;(c1403)&#x27;; break; // 拒绝访问</span><br><span class="line">      case 404: errorObj.message = &#x27;(c1404)&#x27;; break; // 请求出错</span><br><span class="line">      case 408: errorObj.message = &#x27;(c1408)&#x27;; break; // 请求超时</span><br><span class="line">      case 500: errorObj.message = &#x27;(c1500)&#x27;; break; // 服务器错误</span><br><span class="line">      case 501: errorObj.message = &#x27;(c1501)&#x27;; break; // 服务未实现</span><br><span class="line">      case 502: errorObj.message = &#x27;(c1502)&#x27;; break; // 网络错误</span><br><span class="line">      case 503: errorObj.message = &#x27;(c1503)&#x27;; break; // 服务不可用</span><br><span class="line">      case 504: errorObj.message = &#x27;(c1504)&#x27;; break; // 网络超时</span><br><span class="line">      case 505: errorObj.message = &#x27;(c1505)&#x27;; break; // HTTP版本不受支持</span><br><span class="line">      default: errorObj.message = `连接出错($&#123;error.response.status&#125;)!` // 连接出错</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      errorObj.message = &#x27;(c3289)&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    uni.hideToast();</span><br><span class="line">    uni.showToast(&#123;</span><br><span class="line">      title: &#x27;网络繁忙,请稍后再试&#x27;,</span><br><span class="line">      duration: 2000,</span><br><span class="line">      icon: &#x27;none&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">    Promise.reject(error)</span><br><span class="line">    return errorObj</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">//用来适配uniapp的语法</span><br><span class="line">axios.defaults.adapter = function(config) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">var settle = require(&#x27;axios/lib/core/settle&#x27;);</span><br><span class="line">var buildURL = require(&#x27;axios/lib/helpers/buildURL&#x27;);</span><br><span class="line">uni.request(&#123;</span><br><span class="line">method: config.method.toUpperCase(),</span><br><span class="line">url: buildURL(config.url, config.params, config.paramsSerializer),</span><br><span class="line">// url: config.baseURL + buildURL(config.url, config.params, config.paramsSerializer),</span><br><span class="line">header: config.headers,</span><br><span class="line">data: config.data,</span><br><span class="line">dataType: config.dataType,</span><br><span class="line">responseType: config.responseType,</span><br><span class="line">sslVerify: config.sslVerify,</span><br><span class="line">complete: function complete(response) &#123;</span><br><span class="line">response = &#123;</span><br><span class="line">data: response.data,</span><br><span class="line">status: response.statusCode,</span><br><span class="line">errMsg: response.errMsg,</span><br><span class="line">header: response.header,</span><br><span class="line">config: config</span><br><span class="line">&#125;;</span><br><span class="line">settle(resolve, reject, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default service</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>踩坑! ! ! 一开始以为和vue一样使用,直接引入axios后,就可以开始请求接口,接口一直报错,百度后找到了解决办法</p></blockquote><p>其实看上半部分，和vue中配置的很像，但是最重要的就是下面那个用来适配uniapp的语法的函数</p><p>然后把文件在<code>main.js</code>中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#x27;./common/request.js&#x27;</span><br><span class="line">Vue.prototype.$axios = axios;</span><br></pre></td></tr></table></figure><p>页面中就可以开始使用啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$axios.request(&#123;</span><br><span class="line">  url: https://xxx.com,</span><br><span class="line">  method: &#x27;POST&#x27;,</span><br><span class="line">  data: &#123;&#125;</span><br><span class="line">&#125;).then(response =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>以上就是我对uni-app配置axios的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;axios我们都使用过，怎么在uni-app中使用呢&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="uniApp" scheme="https://www.chensheng.group/categories/uniApp/"/>
    
    
    <category term="uniApp" scheme="https://www.chensheng.group/tags/uniApp/"/>
    
  </entry>
  
  <entry>
    <title>uni-app分包</title>
    <link href="https://www.chensheng.group/2022/10/01/160-uni-app%E5%88%86%E5%8C%85/"/>
    <id>https://www.chensheng.group/2022/10/01/160-uni-app%E5%88%86%E5%8C%85/</id>
    <published>2022-10-01T05:14:23.000Z</published>
    <updated>2024-06-02T16:07:19.378Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>不知不觉又是一个国庆了，记录一下uni-app分包的学习过程</p></blockquote><span id="more"></span><p>不知道大家是不是都有遇到过，当微信小程序准备发布的时候，结果提示超过了2M的限制，于是赶紧开始优化代码，实在是令人头痛，现在，我们就使用分包来解决这个事情</p><p>首先先来看看分包有哪些限制</p><h3 id="大小限制"><a href="#大小限制" class="headerlink" title="大小限制"></a>大小限制</h3><ul><li>微信小程序每个分包的大小是2M，总体积一共不能超过20M。</li><li>百度小程序每个分包的大小是2M，总体积一共不能超过8M。</li><li>支付宝小程序每个分包的大小是2M，总体积一共不能超过8M。</li><li>QQ小程序每个分包的大小是2M，总体积一共不能超过24M。</li><li>字节小程序每个分包的大小是2M，总体积一共不能超过16M（字节小程序基础库 1.88.0 及以上版本开始支持，字节小程序开发者工具请使用大于等于 2.0.6 且小于 3.0.0 的版本）</li></ul><p>这里我们以微信小程序为例</p><h3 id="打包原则"><a href="#打包原则" class="headerlink" title="打包原则"></a>打包原则</h3><ul><li>声明 subpackages 后，将按 subpackages 配置路径进行打包，subpackages 配置路径外的目录将被打包到主包中</li><li>主包也可以有自己的 pages，即最外层的 pages 字段。</li><li>subpackage 的根目录不能是另外一个 subpackage 内的子目录</li><li>tabBar 页面必须在主包内</li></ul><blockquote><p>pages里定义的是 主包的路径，subPackages里定义的是 分包的路径</p></blockquote><h3 id="引用原则"><a href="#引用原则" class="headerlink" title="引用原则"></a>引用原则</h3><p>packageA 无法 require packageB JS 文件，但可以 require 主包、packageA 内的 JS 文件<br>packageA 无法 import packageB 的 template，但可以 require 主包、packageA 内的 template<br>packageA 无法使用 packageB 的资源，但可以使用主包、packageA 内的资源</p><blockquote><p>简单的来说，分包只能使用或引用分包自身的内容</p></blockquote><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>先贴个图看看我的demo目录是什么样的 </p><p><img src="https://csblogimage.oss-cn-hangzhou.aliyuncs.com/160-%E5%88%86%E5%8C%85%E6%A8%A1%E6%9D%BF.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,size_16,text_Qnku6ZmI5YWI55Sf55qE5bCP5YmN56uv,color_FFFFFF,shadow_50,t_100,g_se,x_10,y_10" alt="uni-app分包结构"></p><p>大体上我们了四个文件夹(pages, pagesActivity,pangesIndex,pagesMember)，这个主要是看项目需要，这里只是一个demo</p><p>其中，pages就是作为我们的主包，里面的内容存放的是 tabBar 的页面，其他三个就是分包的内容，可以理解为子页面的存放</p><p>各种的子包文件中，可以创建一个static用于存放静态文件，毕竟每个子包的资源是不共享的</p><p>再看看pages.json是怎么写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;easycom&quot;: &#123;</span><br><span class="line">    &quot;^u-(.*)&quot;: &quot;@/uview-ui/components/u-$1/u-$1.vue&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;pages&quot;: [&#123;</span><br><span class="line">    &quot;path&quot;: &quot;pages/index/index&quot;,</span><br><span class="line">    &quot;style&quot;: &#123;</span><br><span class="line">      &quot;navigationBarTitleText&quot;: &quot;首页&quot;,</span><br><span class="line">      &quot;enablePullDownRefresh&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;path&quot;: &quot;pages/member/member&quot;,</span><br><span class="line">    &quot;style&quot;: &#123;</span><br><span class="line">      &quot;navigationBarTitleText&quot;: &quot;商户&quot;,</span><br><span class="line">      &quot;enablePullDownRefresh&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;path&quot;: &quot;pages/activity/activity&quot;,</span><br><span class="line">    &quot;style&quot;: &#123;</span><br><span class="line">      &quot;navigationBarTitleText&quot;: &quot;活动&quot;,</span><br><span class="line">      &quot;enablePullDownRefresh&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  // 分包加载配置 root-子包的根目录   pages-页面路径 name-分包别名 independent-是否为独立分包 最后两个属性用的比较少</span><br><span class="line">  &quot;subPackages&quot;: [&#123;</span><br><span class="line">    &quot;root&quot;: &quot;pagesIndex&quot;,</span><br><span class="line">    &quot;pages&quot;: [&#123;</span><br><span class="line">      &quot;path&quot;: &quot;indexChild/indexChild&quot;,</span><br><span class="line">      &quot;style&quot;: &#123;&#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;root&quot;: &quot;pagesMember&quot;,</span><br><span class="line">    &quot;pages&quot;: [&#123;</span><br><span class="line">      &quot;path&quot;: &quot;memberChild/memberChild&quot;,</span><br><span class="line">      &quot;style&quot;: &#123;&#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;root&quot;: &quot;pagesActivity&quot;,</span><br><span class="line">    &quot;pages&quot;: [&#123;</span><br><span class="line">      &quot;path&quot;: &quot;games/card/card&quot;,</span><br><span class="line">      &quot;style&quot;: &#123;&#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;],</span><br><span class="line">  // 分包预加载配置  对象中的key-页面路径 packages-预下载的root名  network-在什么指定网络环境下可以预加载，all是所有网络，wifi是wifi网络</span><br><span class="line">  &quot;preloadRule&quot;: &#123;</span><br><span class="line">    &quot;pages/index/index&quot;: &#123;</span><br><span class="line">      &quot;network&quot;: &quot;all&quot;,</span><br><span class="line">      &quot;packages&quot;: [&quot;pagesIndex&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;pages/member/member&quot;: &#123;</span><br><span class="line">      &quot;network&quot;: &quot;all&quot;,</span><br><span class="line">      &quot;packages&quot;: [&quot;pagesMember&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;pages/activity/activity&quot;: &#123;</span><br><span class="line">      &quot;network&quot;: &quot;all&quot;,</span><br><span class="line">      &quot;packages&quot;: [&quot;pagesActivity&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;globalStyle&quot;: &#123;</span><br><span class="line">    &quot;navigationBarTextStyle&quot;: &quot;black&quot;,</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;uni-app&quot;,</span><br><span class="line">    &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,</span><br><span class="line">    &quot;backgroundColor&quot;: &quot;#F8F8F8&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tabBar&quot;: &#123;</span><br><span class="line">    &quot;color&quot;: &quot;#666666&quot;,</span><br><span class="line">    &quot;selectedColor&quot;: &quot;#f01022&quot;,</span><br><span class="line">    &quot;borderStyle&quot;: &quot;white&quot;,</span><br><span class="line">    &quot;backgroundColor&quot;: &quot;#ffffff&quot;,</span><br><span class="line">    &quot;list&quot;: [&#123;&quot;pagePath&quot;:&quot;pages/index/index&quot;,&quot;iconPath&quot;:&quot;static/tab/tab-member.png&quot;,&quot;selectedIconPath&quot;:&quot;static/tab/tab-member-current.png&quot;,&quot;text&quot;:&quot;我的&quot;&#125;,&#123;&quot;pagePath&quot;:&quot;pages/member/member&quot;,&quot;iconPath&quot;:&quot;static/tab/tab-member.png&quot;,&quot;selectedIconPath&quot;:&quot;static/tab/tab-member-current.png&quot;,&quot;text&quot;:&quot;商户&quot;&#125;,&#123;&quot;pagePath&quot;:&quot;pages/activity/activity&quot;,&quot;iconPath&quot;:&quot;static/tab/tab-member.png&quot;,&quot;selectedIconPath&quot;:&quot;static/tab/tab-member-current.png&quot;,&quot;text&quot;:&quot;活动&quot;&#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到， subPackages 的配置就是用来配置分包文件的路由的，注释也都在代码里面</p><blockquote><p>到这里，分包就已经搭建完了，大家的项目结构如何和我的不同，也没有关系，有一些文件是其他的配置，不必在意</p></blockquote><p>如果分包完之后，主包还是大，只需要3步</p><ol><li><p>在manifest.json里源码视图的mp-weixin加上   “optimization”:{“subPackages”:true}</p></li><li><p>在编译器里勾选运行时压缩代码</p></li><li><p>上传代码时压缩css</p></li></ol><p>然后重新运行一下项目即可</p><p>以上就是我对uni-app分包的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;不知不觉又是一个国庆了，记录一下uni-app分包的学习过程&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="uniApp" scheme="https://www.chensheng.group/categories/uniApp/"/>
    
    
    <category term="uniApp" scheme="https://www.chensheng.group/tags/uniApp/"/>
    
  </entry>
  
  <entry>
    <title>js实用小技巧</title>
    <link href="https://www.chensheng.group/2022/08/06/159-js%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://www.chensheng.group/2022/08/06/159-js%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2022-08-06T12:10:00.000Z</published>
    <updated>2024-06-02T16:07:19.378Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>记录一下 JavaScript开发中非常有用的小技巧, 欢迎各位大佬补充</p></blockquote><span id="more"></span><h3 id="滚动到页面顶部"><a href="#滚动到页面顶部" class="headerlink" title="滚动到页面顶部"></a>滚动到页面顶部</h3><p>我们可以使用 window.scrollTo() 平滑滚动到页面顶部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const scrollToTop = () =&gt; &#123;</span><br><span class="line">  window.scrollTo(&#123; top: 0, left: 0, behavior: &quot;smooth&quot; &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="滚动到页面底部"><a href="#滚动到页面底部" class="headerlink" title="滚动到页面底部"></a>滚动到页面底部</h3><p>当然，如果知道页面的高度，也可以平滑滚动到页面底部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const scrollToBottom = () =&gt; &#123;</span><br><span class="line">  window.scrollTo(&#123;</span><br><span class="line">    top: document.documentElement.offsetHeight,</span><br><span class="line">    left: 0,</span><br><span class="line">    behavior: &quot;smooth&quot;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里记录一下,element平滑滚动到表单error位置</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">  let isError = document.getElementsByClassName(&#x27;is-error&#x27;)</span><br><span class="line">  // 滚动到指定节点</span><br><span class="line">  isError[0].scrollIntoView(&#123;</span><br><span class="line">    // 值有start,center,end，nearest，当前显示在视图区域中间</span><br><span class="line">    block: &#x27;center&#x27;,</span><br><span class="line">    // 值有auto,instant,smooth，缓动动画（当前是慢速的）</span><br><span class="line">    behavior: &#x27;smooth&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="滚动元素到可见区域"><a href="#滚动元素到可见区域" class="headerlink" title="滚动元素到可见区域"></a>滚动元素到可见区域</h3><p>有时我们需要将元素滚动到可见区域，我们应该怎么做？使用 scrollIntoView 就足够了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const smoothScroll = (element) =&gt; &#123;</span><br><span class="line">  element.scrollIntoView(&#123;</span><br><span class="line">    behavior: &quot;smooth&quot;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="全屏显示元素"><a href="#全屏显示元素" class="headerlink" title="全屏显示元素"></a>全屏显示元素</h3><p>你一定遇到过这样的场景，需要全屏播放视频，并在浏览器中全屏打开页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const goToFullScreen = (element) =&gt; &#123;</span><br><span class="line">  element = element || document.body;</span><br><span class="line">  if (element.requestFullscreen) &#123;</span><br><span class="line">    element.requestFullscreen();</span><br><span class="line">  &#125; else if (element.mozRequestFullScreen) &#123;</span><br><span class="line">    element.mozRequestFullScreen();</span><br><span class="line">  &#125; else if (element.msRequestFullscreen) &#123;</span><br><span class="line">    element.msRequestFullscreen();</span><br><span class="line">  &#125; else if (element.webkitRequestFullscreen) &#123;</span><br><span class="line">    element.webkitRequestFullScreen();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="退出浏览器全屏状态"><a href="#退出浏览器全屏状态" class="headerlink" title="退出浏览器全屏状态"></a>退出浏览器全屏状态</h3><p>是的，这个和第4点一起使用，你也会有退出浏览器全屏状态的场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const goExitFullscreen = () =&gt; &#123;</span><br><span class="line">  if (document.exitFullscreen) &#123;</span><br><span class="line">    document.exitFullscreen();</span><br><span class="line">  &#125; else if (document.msExitFullscreen) &#123;</span><br><span class="line">    document.msExitFullscreen();</span><br><span class="line">  &#125; else if (document.mozCancelFullScreen) &#123;</span><br><span class="line">    document.mozCancelFullScreen();</span><br><span class="line">  &#125; else if (document.webkitExitFullscreen) &#123;</span><br><span class="line">    document.webkitExitFullscreen();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="获取数据类型"><a href="#获取数据类型" class="headerlink" title="获取数据类型"></a>获取数据类型</h3><p>如何通过函数获取变量的数据类型？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const getType = (value) =&gt; &#123;</span><br><span class="line">  const match = Object.prototype.toString.call(value).match(/ (\w+)]/)</span><br><span class="line">  return match[1].toLocaleLowerCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getType() // undefined</span><br><span class="line">getType(&#123;&#125;&#125;) // object</span><br><span class="line">getType([]) // array</span><br><span class="line">getType(1) // number</span><br><span class="line">getType(&#x27;fatfish&#x27;) // string</span><br><span class="line">getType(true) // boolean</span><br><span class="line">getType(/fatfish/) // regexp</span><br></pre></td></tr></table></figure><h3 id="停止冒泡事件"><a href="#停止冒泡事件" class="headerlink" title="停止冒泡事件"></a>停止冒泡事件</h3><p>一种适用于所有平台的防止事件冒泡的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const stopPropagation = (event) =&gt; &#123;</span><br><span class="line">  event = event || window.event;</span><br><span class="line">  if (event.stopPropagation) &#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    event.cancelBubble = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="深拷贝一个对象如何复制深度嵌套的对象？"><a href="#深拷贝一个对象如何复制深度嵌套的对象？" class="headerlink" title="深拷贝一个对象如何复制深度嵌套的对象？"></a>深拷贝一个对象如何复制深度嵌套的对象？</h3><blockquote><p>适用于对象嵌套对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const deepCopy = (obj, hash = new WeakMap()) =&gt; &#123;</span><br><span class="line">  if (obj instanceof Date) &#123;</span><br><span class="line">    return new Date(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  if (obj instanceof RegExp) &#123;</span><br><span class="line">    return new RegExp(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  if (hash.has(obj)) &#123;</span><br><span class="line">    return hash.get(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  let allDesc = Object.getOwnPropertyDescriptors(obj);</span><br><span class="line">  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc);</span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  for (let key of Reflect.ownKeys(obj)) &#123;</span><br><span class="line">    if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123;</span><br><span class="line">      cloneObj[key] = deepCopy(obj[key], hash);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cloneObj[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cloneObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="确定设备类型"><a href="#确定设备类型" class="headerlink" title="确定设备类型"></a>确定设备类型</h3><p>我们经常必须这样做才能在手机上显示 A 逻辑，在 PC 上显示 B 逻辑。基本上，设备类型是通过识别浏览器的 userAgent 来确定的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const isMobile = () =&gt; &#123;</span><br><span class="line">  return !!navigator.userAgent.match(</span><br><span class="line">    /(iPhone|iPod|Android|ios|iOS|iPad|Backerry|WebOS|Symbian|Windows Phone|Phone)/i</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>###判断设备是安卓还是IOS </p><p>除了区分是移动端还是PC端，很多时候我们还需要区分当前设备是Android还是IOS。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const isAndroid = () =&gt; &#123;</span><br><span class="line">  return /android/i.test(navigator.userAgent.toLowerCase());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const isIOS = () =&gt; &#123;</span><br><span class="line">  let reg = /iPhone|iPad|iPod|iOS|Macintosh/i;</span><br><span class="line">  return reg.test(navigator.userAgent.toLowerCase());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="获取浏览器类型及其版本"><a href="#获取浏览器类型及其版本" class="headerlink" title="获取浏览器类型及其版本"></a>获取浏览器类型及其版本</h3><p>作为前端开发人员，您可能会遇到各种兼容性问题，这时候可能需要获取浏览器的类型和版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">const getExplorerInfo = () =&gt; &#123;</span><br><span class="line">  let t = navigator.userAgent.toLowerCase();</span><br><span class="line">  return 0 &lt;= t.indexOf(&quot;msie&quot;)</span><br><span class="line">    ? &#123;</span><br><span class="line">        //ie &lt; 11</span><br><span class="line">        type: &quot;IE&quot;,</span><br><span class="line">        version: Number(t.match(/msie ([\d]+)/)[1]),</span><br><span class="line">      &#125;</span><br><span class="line">    : !!t.match(/trident\/.+?rv:(([\d.]+))/)</span><br><span class="line">    ? &#123;</span><br><span class="line">        // ie 11</span><br><span class="line">        type: &quot;IE&quot;,</span><br><span class="line">        version: 11,</span><br><span class="line">      &#125;</span><br><span class="line">    : 0 &lt;= t.indexOf(&quot;edge&quot;)</span><br><span class="line">    ? &#123;</span><br><span class="line">        type: &quot;Edge&quot;,</span><br><span class="line">        version: Number(t.match(/edge\/([\d]+)/)[1]),</span><br><span class="line">      &#125;</span><br><span class="line">    : 0 &lt;= t.indexOf(&quot;firefox&quot;)</span><br><span class="line">    ? &#123;</span><br><span class="line">        type: &quot;Firefox&quot;,</span><br><span class="line">        version: Number(t.match(/firefox\/([\d]+)/)[1]),</span><br><span class="line">      &#125;</span><br><span class="line">    : 0 &lt;= t.indexOf(&quot;chrome&quot;)</span><br><span class="line">    ? &#123;</span><br><span class="line">        type: &quot;Chrome&quot;,</span><br><span class="line">        version: Number(t.match(/chrome\/([\d]+)/)[1]),</span><br><span class="line">      &#125;</span><br><span class="line">    : 0 &lt;= t.indexOf(&quot;opera&quot;)</span><br><span class="line">    ? &#123;</span><br><span class="line">        type: &quot;Opera&quot;,</span><br><span class="line">        version: Number(t.match(/opera.([\d]+)/)[1]),</span><br><span class="line">      &#125;</span><br><span class="line">    : 0 &lt;= t.indexOf(&quot;Safari&quot;)</span><br><span class="line">    ? &#123;</span><br><span class="line">        type: &quot;Safari&quot;,</span><br><span class="line">        version: Number(t.match(/version\/([\d]+)/)[1]),</span><br><span class="line">      &#125;</span><br><span class="line">    : &#123;</span><br><span class="line">        type: t,</span><br><span class="line">        version: -1,</span><br><span class="line">      &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="设置cookies"><a href="#设置cookies" class="headerlink" title="设置cookies"></a>设置cookies</h3><p>cookie 可能是我见过的最糟糕的 API，它很难使用，以至于我们不得不重新封装它以最大限度地提高开发效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const setCookie = (key, value, expire) =&gt; &#123;</span><br><span class="line">  const d = new Date();</span><br><span class="line">  d.setDate(d.getDate() + expire);</span><br><span class="line">  document.cookie = `$&#123;key&#125;=$&#123;value&#125;;expires=$&#123;d.toUTCString()&#125;`;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>获取 cookie除了写入 cookie 之外，我们还将参与其读取操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const getCookie = (key) =&gt; &#123;</span><br><span class="line">  const cookieStr = unescape(document.cookie);</span><br><span class="line">  const arr = cookieStr.split(&quot;; &quot;);</span><br><span class="line">  let cookieValue = &quot;&quot;;</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    const temp = arr[i].split(&quot;=&quot;);</span><br><span class="line">    if (temp[0] === key) &#123;</span><br><span class="line">      cookieValue = temp[1];</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cookieValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="删除cookies"><a href="#删除cookies" class="headerlink" title="删除cookies"></a>删除cookies</h3><p>删除cookie 的想法是什么？其实，只要把它的过期时间设置为这一刻，它就会立即过期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const delCookie = (key) =&gt; &#123;</span><br><span class="line">  document.cookie = `$&#123;encodeURIComponent(key)&#125;=;expires=$&#123;new Date()&#125;`;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h3><p>不知道大家有没有遇到过需要生成随机字符串的场景。我遇到过很多次，每次都要google一遍，直到学会这个工具功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const randomString = (len) =&gt; &#123;</span><br><span class="line">  let chars = &quot;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz123456789&quot;;</span><br><span class="line">  let strLen = chars.length;</span><br><span class="line">  let randomStr = &quot;&quot;;</span><br><span class="line">  for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    randomStr += chars.charAt(Math.floor(Math.random() * strLen));</span><br><span class="line">  &#125;</span><br><span class="line">  return randomStr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">randomString(10) // pfkMfjEJ6x</span><br><span class="line">randomString(20) // ce6tEx1km4idRNMtym2S</span><br></pre></td></tr></table></figure><h3 id="字符串首字母大写"><a href="#字符串首字母大写" class="headerlink" title="字符串首字母大写"></a>字符串首字母大写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const fistLetterUpper = (str) =&gt; &#123;</span><br><span class="line">  return str.charAt(0).toUpperCase() + str.slice(1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fistLetterUpper(&#x27;fatfish&#x27;) // Fatfish</span><br></pre></td></tr></table></figure><h3 id="生成指定范围内的随机数"><a href="#生成指定范围内的随机数" class="headerlink" title="生成指定范围内的随机数"></a>生成指定范围内的随机数</h3><p>也许出于测试目的，我经常需要生成一定范围内的随机数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const randomNum = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line"></span><br><span class="line">randomNum(1, 10) // 6</span><br><span class="line">randomNum(10, 20) // 11</span><br></pre></td></tr></table></figure><h3 id="打乱数组的顺序"><a href="#打乱数组的顺序" class="headerlink" title="打乱数组的顺序"></a>打乱数组的顺序</h3><p>如何打乱数组的原始顺序？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const shuffleArray = (array) =&gt; &#123;</span><br><span class="line">  return array.sort(() =&gt; 0.5 - Math.random())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [ 1, -1, 10, 5 ]</span><br><span class="line"></span><br><span class="line">shuffleArray(arr) // [5, -1, 10, 1]</span><br><span class="line">shuffleArray(arr) // [1, 10, -1, 5]</span><br></pre></td></tr></table></figure><h3 id="从数组中获取随机值"><a href="#从数组中获取随机值" class="headerlink" title="从数组中获取随机值"></a>从数组中获取随机值</h3><p>之前做过一个抽奖项目，需要让数组中的奖品随机出现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const getRandomValue = array =&gt; array[Math.floor(Math.random() * array.length)]; </span><br><span class="line">const prizes = [  &#x27;$100&#x27;, &#x27; &#x27;, &#x27; &#x27; ]</span><br><span class="line"></span><br><span class="line">getRandomValue(prizes) //  </span><br><span class="line">getRandomValue(prizes) //  </span><br><span class="line">getRandomValue(prizes) //  </span><br></pre></td></tr></table></figure><h3 id="格式化货币"><a href="#格式化货币" class="headerlink" title="格式化货币"></a>格式化货币</h3><p>格式化货币的方式有很多，比如这两种方式。</p><p>第一种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const formatMoney = (money) =&gt; &#123;</span><br><span class="line">  return money.replace(new RegExp(`(?!^)(?=(\\d&#123;3&#125;)+$&#123;money.includes(&#x27;.&#x27;) ? &#x27;\\.&#x27; : &#x27;$&#x27;&#125;)`, &#x27;g&#x27;), &#x27;,&#x27;)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">formatMoney(&#x27;123456789&#x27;) // &#x27;123,456,789&#x27;</span><br><span class="line">formatMoney(&#x27;123456789.123&#x27;) // &#x27;123,456,789.123&#x27;</span><br><span class="line">formatMoney(&#x27;123&#x27;) // &#x27;123&#x27;</span><br></pre></td></tr></table></figure><p>第二种方式</p><p>正则表达式让我们很头疼，不是吗？所以我们需要找到一种更简单的方式来格式化货币。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const formatMoney = (money) =&gt; &#123;</span><br><span class="line">  return money.toLocaleString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">formatMoney(123456789) // &#x27;123,456,789&#x27;</span><br><span class="line">formatMoney(123456789.123) // &#x27;123,456,789.123&#x27;</span><br><span class="line">formatMoney(123) // &#x27;123&#x27;</span><br></pre></td></tr></table></figure><p>从各个地方摘录过来的,后续会继续补充,侵删~</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;记录一下 JavaScript开发中非常有用的小技巧, 欢迎各位大佬补充&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>单行JS小工具</title>
    <link href="https://www.chensheng.group/2022/06/24/158-%E5%8D%95%E8%A1%8Cjs/"/>
    <id>https://www.chensheng.group/2022/06/24/158-%E5%8D%95%E8%A1%8Cjs/</id>
    <published>2022-06-24T14:18:00.000Z</published>
    <updated>2024-06-02T16:07:19.378Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>气死同事的单行代码,实际开发中可读性极差,但是可以学习</p></blockquote><span id="more"></span><h3 id="获取浏览器Cookie的值"><a href="#获取浏览器Cookie的值" class="headerlink" title="获取浏览器Cookie的值"></a>获取浏览器Cookie的值</h3><p>通过document.cookie 来查找cookie值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const cookie = name =&gt; `; $&#123;document.cookie&#125;`.split(`; $&#123;name&#125;=`).pop().split(&#x27;;&#x27;).shift();</span><br><span class="line">    </span><br><span class="line">cookie(&#x27;_ga&#x27;);</span><br><span class="line">// Result: &quot;GA1.2.1929736587.1601974046&quot;</span><br></pre></td></tr></table></figure><h3 id="颜色RGB转十六进制"><a href="#颜色RGB转十六进制" class="headerlink" title="颜色RGB转十六进制"></a>颜色RGB转十六进制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const rgbToHex = (r, g, b) =&gt; &quot;#&quot; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);</span><br><span class="line">    </span><br><span class="line">rgbToHex(0, 51, 255); </span><br><span class="line">// Result: #0033ff</span><br></pre></td></tr></table></figure><h3 id="复制到剪贴板"><a href="#复制到剪贴板" class="headerlink" title="复制到剪贴板"></a>复制到剪贴板</h3><p>借助navigator.clipboard.writeText可以很容易的将文本复制到剪贴板</p><p>规范要求在写入剪贴板之前使用 Permissions API 获取“剪贴板写入”权限。但是，不同浏览器的具体要求不同，因为这是一个新的API。有关详细信息，请查看compatibility table and Clipboard availability in Clipboard。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const copyToClipboard = (text) =&gt; navigator.clipboard.writeText(text);</span><br><span class="line">    </span><br><span class="line">copyToClipboard(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure><h3 id="检查日期是否合法"><a href="#检查日期是否合法" class="headerlink" title="检查日期是否合法"></a>检查日期是否合法</h3><p>使用以下代码段检查给定日期是否有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const isDateValid = (...val) =&gt; !Number.isNaN(new Date(...val).valueOf());</span><br><span class="line">    </span><br><span class="line">isDateValid(&quot;December 17, 1995 03:24:00&quot;);</span><br><span class="line">// Result: true</span><br></pre></td></tr></table></figure><h3 id="查找日期位于一年中的第几天"><a href="#查找日期位于一年中的第几天" class="headerlink" title="查找日期位于一年中的第几天"></a>查找日期位于一年中的第几天</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const dayOfYear = (date) =&gt;</span><br><span class="line">      Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);</span><br><span class="line">    </span><br><span class="line">dayOfYear(new Date());</span><br><span class="line">// Result: 272</span><br></pre></td></tr></table></figure><h3 id="英文字符串首字母大写"><a href="#英文字符串首字母大写" class="headerlink" title="英文字符串首字母大写"></a>英文字符串首字母大写</h3><p>JavaScript没有内置的首字母大写函数，因此我们可以使用以下代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const capitalize = str =&gt; str.charAt(0).toUpperCase() + str.slice(1)</span><br><span class="line">    </span><br><span class="line">capitalize(&quot;follow for more&quot;)</span><br><span class="line">// Result: Follow for more</span><br></pre></td></tr></table></figure><h3 id="计算2个日期之间相差多少天"><a href="#计算2个日期之间相差多少天" class="headerlink" title="计算2个日期之间相差多少天"></a>计算2个日期之间相差多少天</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const dayDif = (date1, date2) =&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)</span><br><span class="line">    </span><br><span class="line">dayDif(new Date(&quot;2020-10-21&quot;), new Date(&quot;2021-10-22&quot;))</span><br><span class="line">// Result: 366</span><br></pre></td></tr></table></figure><h3 id="清除全部Cookie"><a href="#清除全部Cookie" class="headerlink" title="清除全部Cookie"></a>清除全部Cookie</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过使用document.cookie访问cookie并将其清除，可以轻松清除网页中存储的所有cookie</span><br><span class="line"></span><br><span class="line">const clearCookies = document.cookie.split(&#x27;;&#x27;).forEach(cookie =&gt; document.cookie = cookie.replace(/^ +/, &#x27;&#x27;).replace(/=.*/, `=;expires=$&#123;new Date(0).toUTCString()&#125;;path=/`));</span><br></pre></td></tr></table></figure><h3 id="生成随机十六进制颜色"><a href="#生成随机十六进制颜色" class="headerlink" title="生成随机十六进制颜色"></a>生成随机十六进制颜色</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以使用 Math.random 和 padEnd 属性生成随机的十六进制颜色。</span><br><span class="line"></span><br><span class="line">const randomHex = () =&gt; `#$&#123;Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &quot;0&quot;)&#125;`;</span><br><span class="line">    </span><br><span class="line"> console.log(randomHex());</span><br><span class="line">// Result: #92b008</span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>可以使用 JavaScript 中的Set轻松删除重复项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const removeDuplicates = (arr) =&gt; [...new Set(arr)];</span><br><span class="line">    </span><br><span class="line">console.log(removeDuplicates([1, 2, 3, 3, 4, 4, 5, 5, 6]));</span><br><span class="line">// Result: [ 1, 2, 3, 4, 5, 6 ]</span><br></pre></td></tr></table></figure><h3 id="从-URL-获取查询参数"><a href="#从-URL-获取查询参数" class="headerlink" title="从 URL 获取查询参数"></a>从 URL 获取查询参数</h3><p>可以通过传递 window.location 或原始 URL goole.com?search&#x3D;easy&amp;page&#x3D;3 轻松地从 url 检索查询参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const getParameters = (URL) =&gt; &#123;</span><br><span class="line">  URL = jsON.parse(</span><br><span class="line">    &#x27;&#123;&quot;&#x27; +</span><br><span class="line">      decodeURI(URL.split(&quot;?&quot;)[1])</span><br><span class="line">        .replace(/&quot;/g, &#x27;\\&quot;&#x27;)</span><br><span class="line">        .replace(/&amp;/g, &#x27;&quot;,&quot;&#x27;)</span><br><span class="line">        .replace(/=/g, &#x27;&quot;:&quot;&#x27;) +</span><br><span class="line">      &#x27;&quot;&#125;&#x27;</span><br><span class="line">  );</span><br><span class="line">  return jsON.stringify(URL);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getParameters(window.location);</span><br><span class="line">// Result: &#123; search : &quot;easy&quot;, page : 3 &#125;</span><br></pre></td></tr></table></figure><p>或者更为简单的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.fromEntries(new URLSearchParams(window.location.search))</span><br><span class="line">// Result: &#123; search : &quot;easy&quot;, page : 3 &#125;</span><br></pre></td></tr></table></figure><h3 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h3><p>我们可以从给定日期以 hour::minutes::seconds 格式记录时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const timeFromDate = date =&gt; date.toTimeString().slice(0, 8);</span><br><span class="line">    </span><br><span class="line">console.log(timeFromDate(new Date(2021, 0, 10, 17, 30, 0))); </span><br><span class="line">// Result: &quot;17:30:00&quot;</span><br></pre></td></tr></table></figure><h3 id="校验数字是奇数还是偶数"><a href="#校验数字是奇数还是偶数" class="headerlink" title="校验数字是奇数还是偶数"></a>校验数字是奇数还是偶数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const isEven = num =&gt; num % 2 === 0;</span><br><span class="line">    </span><br><span class="line">console.log(isEven(2)); </span><br><span class="line">// Result: True</span><br></pre></td></tr></table></figure><h3 id="求数字的平均值"><a href="#求数字的平均值" class="headerlink" title="求数字的平均值"></a>求数字的平均值</h3><p>使用reduce方法找到多个数字之间的平均值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const average = (...args) =&gt; args.reduce((a, b) =&gt; a + b) / args.length;</span><br><span class="line">    </span><br><span class="line">average(1, 2, 3, 4);</span><br><span class="line">// Result: 2.5</span><br></pre></td></tr></table></figure><h3 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以使用 window.scrollTo(0, 0) 方法自动滚动到顶部。将 x 和 y 都设置为 0。</span><br><span class="line"></span><br><span class="line">const goToTop = () =&gt; window.scrollTo(0, 0);</span><br><span class="line">    </span><br><span class="line">goToTop();</span><br></pre></td></tr></table></figure><h3 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h3><p>可以使用 split、reverse 和 join 方法轻松反转字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const reverse = str =&gt; str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    </span><br><span class="line">reverse(&#x27;hello world&#x27;);     </span><br><span class="line">// Result: &#x27;dlrow olleh&#x27;</span><br></pre></td></tr></table></figure><h3 id="校验数组是否为空"><a href="#校验数组是否为空" class="headerlink" title="校验数组是否为空"></a>校验数组是否为空</h3><p>一行代码检查数组是否为空,将返回true或false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const isNotEmpty = arr =&gt; Array.isArray(arr) &amp;&amp; arr.length &gt; 0;</span><br><span class="line">    </span><br><span class="line">isNotEmpty([1, 2, 3]);</span><br><span class="line">// Result: true</span><br></pre></td></tr></table></figure><h3 id="获取用户选择的文本"><a href="#获取用户选择的文本" class="headerlink" title="获取用户选择的文本"></a>获取用户选择的文本</h3><p>使用内置的getSelection 属性获取用户选择的文本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const getSelectedText = () =&gt; window.getSelection().toString();</span><br><span class="line">    </span><br><span class="line">getSelectedText();</span><br></pre></td></tr></table></figure><h3 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h3><p>可以使用sort 和 random 方法打乱数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const shuffleArray = (arr) =&gt; arr.sort(() =&gt; 0.5 - Math.random());</span><br><span class="line">    </span><br><span class="line">console.log(shuffleArray([1, 2, 3, 4]));</span><br><span class="line">// Result: [ 1, 4, 3, 2 ]</span><br></pre></td></tr></table></figure><h3 id="检查用户的设备是否处于暗模式"><a href="#检查用户的设备是否处于暗模式" class="headerlink" title="检查用户的设备是否处于暗模式"></a>检查用户的设备是否处于暗模式</h3><p>使用以下代码检查用户的设备是否处于暗模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const isDarkMode = window.matchMedia &amp;&amp; window.matchMedia(&#x27;(prefers-color-scheme: dark)&#x27;).matches</span><br><span class="line">    </span><br><span class="line">console.log(isDarkMode) </span><br><span class="line">// Result: True or False</span><br></pre></td></tr></table></figure><p>摘录某个大佬的文章,谢谢大佬无私分享</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;气死同事的单行代码,实际开发中可读性极差,但是可以学习&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>滑动拼图验证</title>
    <link href="https://www.chensheng.group/2022/04/15/157-%E6%BB%91%E5%8A%A8%E6%8B%BC%E5%9B%BE%E9%AA%8C%E8%AF%81/"/>
    <id>https://www.chensheng.group/2022/04/15/157-%E6%BB%91%E5%8A%A8%E6%8B%BC%E5%9B%BE%E9%AA%8C%E8%AF%81/</id>
    <published>2022-04-15T14:18:00.000Z</published>
    <updated>2024-06-02T16:07:19.378Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>纯前端滑动拼图验证</p></blockquote><span id="more"></span><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p><code>npm install vue-puzzle-vcode --save</code></p><h3 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Vcode</span><br><span class="line">      :show=&quot;isShow&quot;</span><br><span class="line">      :imgs=&quot;[imgs]&quot;</span><br><span class="line">      @success=&quot;onSuccess&quot;</span><br><span class="line">      @close=&quot;onClose&quot;</span><br><span class="line">      @fail=&quot;onFail&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;button @click=&quot;onSubmit&quot;&gt;登录&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Vcode from &quot;vue-puzzle-vcode&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isShow: false, // 验证码模态框是否出现</span><br><span class="line">      imgs: require(&#x27;@/assets/logo.png&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    onSubmit()&#123;</span><br><span class="line">      this.isShow = true;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 用户通过了验证</span><br><span class="line">    onSuccess(msg)&#123;</span><br><span class="line">      console.log(msg)</span><br><span class="line">      this.isShow = false; // 通过验证后，需要手动隐藏模态框</span><br><span class="line">    &#125;,</span><br><span class="line">    // 验证失败</span><br><span class="line">    onFail(msg)&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    // 用户点击遮罩层，应该关闭模态框</span><br><span class="line">    onClose()&#123;</span><br><span class="line">      // this.isShow = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    Vcode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h3><table><thead><tr><th>字段</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>show</td><td>Boolean</td><td>false</td><td>是否显示验证码弹框</td></tr><tr><td>canvasWidth</td><td>Number</td><td>310</td><td>主图区域的宽度</td></tr><tr><td>canvasHeight</td><td>Number</td><td>160</td><td>主图区域的高度</td></tr><tr><td>imgs</td><td>Array</td><td>null</td><td>自定义图片，见下方例子</td></tr><tr><td>successText</td><td>String</td><td>“验证通过！”</td><td>验证成功时的提示文字</td></tr><tr><td>failText</td><td>String</td><td>“验证失败，请重试”</td><td>验证失败时的提示文字</td></tr><tr><td>sliderText</td><td>String</td><td>“拖动滑块完成拼图”</td><td>下方滑动条里的文字</td></tr></tbody></table><h3 id="事件说明"><a href="#事件说明" class="headerlink" title="事件说明"></a>事件说明</h3><p>事件名 |返回值|说明</p><ul><li><pre><code>  |-      |-      |</code></pre></li></ul><p>success |偏差值|验证通过时会触发，返回值是用户移动的距离跟目标距离的偏差值px|<br>fail|偏差值|验证失败时会触发，返回值同上|<br>close  |null|用户点击遮罩层的回调|</p><p><a href="https://www.npmjs.com/package/vue-puzzle-vcode">原文链接</a></p><p>感谢大佬无私分享</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;纯前端滑动拼图验证&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Vue" scheme="https://www.chensheng.group/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://www.chensheng.group/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>冷门但好用的伪类选择器</title>
    <link href="https://www.chensheng.group/2022/02/23/156-%E4%BC%AA%E7%B1%BB%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.chensheng.group/2022/02/23/156-%E4%BC%AA%E7%B1%BB%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-23T12:18:00.000Z</published>
    <updated>2024-06-02T16:07:19.378Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>伪类选择器我们常用的就是after或者beffore，今天看点不一样</p></blockquote><span id="more"></span><h3 id="first-line-选择首行文本"><a href="#first-line-选择首行文本" class="headerlink" title="::first-line | 选择首行文本"></a>::first-line | 选择首行文本</h3><p>这个伪元素选择器选择换行之前文本的首行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p:first-line &#123;</span><br><span class="line">  color: lightcoral;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="first-letter-选择首字母"><a href="#first-letter-选择首字母" class="headerlink" title="::first-letter | 选择首字母"></a>::first-letter | 选择首字母</h3><p>这个伪元素选择器应用于元素中文本的首字母。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.innerDiv p:first-letter &#123;</span><br><span class="line">  color: lightcoral;</span><br><span class="line">  font-size: 40px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="selection-选择高亮（被选中）的区域"><a href="#selection-选择高亮（被选中）的区域" class="headerlink" title="::selection | 选择高亮（被选中）的区域"></a>::selection | 选择高亮（被选中）的区域</h3><p>应用于任何被用户选中的高亮区域。通过::selection伪元素选择器，我们可以将样式应用于高亮区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div::selection &#123;</span><br><span class="line">  background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="root-根元素"><a href="#root-根元素" class="headerlink" title=":root | 根元素"></a>:root | 根元素</h3><p>:root伪类选中文档的根元素。在 HTML 中，为 HTML 元素。在 RSS 中，则为 RSS 元素.这个伪类选择器应用于根元素，多用于存储全局 CSS 自定义属性。</p><blockquote><p>在CSS变量学习的时候，我们就用过这个</p></blockquote><h3 id="empty-仅当元素为空时触发"><a href="#empty-仅当元素为空时触发" class="headerlink" title=":empty | 仅当元素为空时触发"></a>:empty | 仅当元素为空时触发</h3><p>这个伪类选择器将选中没有任何子项的元素。该元素必须为空。如果一个元素没有空格、可见的内容、后代元素，则为空元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div:empty &#123;</span><br><span class="line">  border: 2px solid orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><div class="note info"><p>这个规则将应用于空的div元素。这个规则将应用于第一个和第二个div，因为他们是真为空，而第三个div包含空格。</p></div><h3 id="only-child-选择仅有的子元素"><a href="#only-child-选择仅有的子元素" class="headerlink" title=":only-child | 选择仅有的子元素"></a>:only-child | 选择仅有的子元素</h3><p>匹配父元素中没有任何兄弟元素的子元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.innerDiv p:only-child &#123;</span><br><span class="line">  color: orangered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="first-of-type-选择第一个指定类型的子元素"><a href="#first-of-type-选择第一个指定类型的子元素" class="headerlink" title=":first-of-type | 选择第一个指定类型的子元素"></a>:first-of-type | 选择第一个指定类型的子元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.innerDiv p:first-of-type &#123;</span><br><span class="line">  color: orangered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将应用于.innerDiv下的第一个p元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;innerDiv&quot;&gt;</span><br><span class="line">  &lt;div&gt;Div1&lt;/div&gt;</span><br><span class="line">  &lt;p&gt;These are the necessary steps&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;hiya&lt;/p&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Do &lt;em&gt;not&lt;/em&gt; push the brake at the same time as the accelerator.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;div&gt;Div2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这个p（“These are the necessary step”）将被选中。</p></blockquote><h3 id="last-of-type-选择最后一个指定类型的子元素"><a href="#last-of-type-选择最后一个指定类型的子元素" class="headerlink" title=":last-of-type | 选择最后一个指定类型的子元素"></a>:last-of-type | 选择最后一个指定类型的子元素</h3><p>像:first-of-type一样，但是会应用于最后一个同类型的子元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.innerDiv p:last-of-type &#123;</span><br><span class="line">    color: orangered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将应用于innerDiv下的最后一个p段落元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;innerDiv&quot;&gt;</span><br><span class="line">  &lt;p&gt;These are the necessary steps&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;hiya&lt;/p&gt;</span><br><span class="line">  &lt;div&gt;Div1&lt;/div&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Do the same.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;div&gt;Div2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>因此，这个p元素（“Do the same”）将被选中。</p></blockquote><h3 id="nth-of-type-选择特定类型的子元素"><a href="#nth-of-type-选择特定类型的子元素" class="headerlink" title=":nth-of-type() | 选择特定类型的子元素"></a>:nth-of-type() | 选择特定类型的子元素</h3><p>这个选择器将从指定的父元素的孩子列表中选择某种类型的子元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.innerDiv p:nth-of-type(1) &#123;</span><br><span class="line">  color: orangered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nth-last-of-type-选择列表末尾中指定类型的子元素"><a href="#nth-last-of-type-选择列表末尾中指定类型的子元素" class="headerlink" title=":nth-last-of-type() | 选择列表末尾中指定类型的子元素"></a>:nth-last-of-type() | 选择列表末尾中指定类型的子元素</h3><p>这将选择最后一个指定类型的子元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.innerDiv p:nth-last-of-type() &#123;</span><br><span class="line">  color: orangered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这将选择innerDiv列表元素中包含的最后一个段落类型子元素。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;innerDiv&quot;&gt;</span><br><span class="line">  &lt;p&gt;These are the necessary steps&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;hiya&lt;/p&gt;</span><br><span class="line">  &lt;div&gt;Div1&lt;/div&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Do the same.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;div&gt;Div2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>innerDiv中最后一个段落子元素p（“Do the same”）将会被选中。</p></blockquote><h3 id="link-选择一个未访问过的超链接"><a href="#link-选择一个未访问过的超链接" class="headerlink" title=":link | 选择一个未访问过的超链接"></a>:link | 选择一个未访问过的超链接</h3><p>这个选择器应用于未被访问过的链接。常用于带有 href 属性的a锚元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a:link &#123;</span><br><span class="line">  color: orangered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;/login&quot;&gt;Login&lt;a&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这将选中未被点击过带有href的指定界面的a锚点元素，选中的元素中的文字将会显示为橙色。</p></blockquote><h3 id="checked-选择一个选中的复选框"><a href="#checked-选择一个选中的复选框" class="headerlink" title=":checked | 选择一个选中的复选框"></a>:checked | 选择一个选中的复选框</h3><p>这个应用于已经被选中的复选框。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input:checked &#123;</span><br><span class="line">  border: 2px solid lightcoral;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个规则应用到所有被选中的复选框。</p><h3 id="valid-选择一个通过验证的元素"><a href="#valid-选择一个通过验证的元素" class="headerlink" title=":valid | 选择一个通过验证的元素"></a>:valid | 选择一个通过验证的元素</h3><p>这主要用于可视化表单元素，以让用户判断是否验证通过。验证通过时，默认元素带有valid属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input:valid &#123;</span><br><span class="line">  boder-color: lightsalmon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="invalid-选择一个未通过验证的元素"><a href="#invalid-选择一个未通过验证的元素" class="headerlink" title=":invalid | 选择一个未通过验证的元素"></a>:invalid | 选择一个未通过验证的元素</h3><p>像:valid一样，但是会应用到未通过验证的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input[type=&quot;text&quot;]:invalid &#123;</span><br><span class="line">  border-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lang-选择指定语言的元素"><a href="#lang-选择指定语言的元素" class="headerlink" title=":lang() | 选择指定语言的元素"></a>:lang() | 选择指定语言的元素</h3><p>应用于指定了语言的元素。可以通过以下两种方式使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p:lang(fr) &#123;</span><br><span class="line">  background: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">p[lang|=&quot;fr&quot;] &#123;</span><br><span class="line">  background: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;p lang=&quot;fr&quot;&gt;Paragraph 1&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="not-对于选择取反（这是一个运算符）"><a href="#not-对于选择取反（这是一个运算符）" class="headerlink" title=":not() | 对于选择取反（这是一个运算符）"></a>:not() | 对于选择取反（这是一个运算符）</h3><p>否定伪类选择器选中相反的。让我们看一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.innerDiv :not(p) &#123;</span><br><span class="line">  color: lightcoral;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;innerDiv&quot;&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;</span><br><span class="line">  &lt;div&gt;Div 1&lt;/div&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 3&lt;/p&gt;</span><br><span class="line">  &lt;div&gt;Div 2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Div 1和Div 2会被选中，因为他们不是p元素。</p></blockquote><p>本文章摘录知乎，网址已经忘记了，感谢大佬的无私奉献</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;伪类选择器我们常用的就是after或者beffore，今天看点不一样&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="CSS" scheme="https://www.chensheng.group/categories/CSS/"/>
    
    
    <category term="CSS" scheme="https://www.chensheng.group/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>移动端点击延迟问题</title>
    <link href="https://www.chensheng.group/2021/11/02/155-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/"/>
    <id>https://www.chensheng.group/2021/11/02/155-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/</id>
    <published>2021-11-02T13:39:00.000Z</published>
    <updated>2024-06-02T16:07:19.378Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>本来是放在js面试题里面的,但是内容太多了,所以还是再分出来单独讲</p></blockquote><span id="more"></span><blockquote><p>移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</p></blockquote><p>怎么处理呢?</p><ul><li><p>通过 meta 标签禁用网页的缩放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>通过 meta 标签将网页的 viewport 设置为 ideal viewport。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这个方案相比上一个的好处在于，它没有完全禁用缩放，而只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面。</p></blockquote><ul><li>CSS touch-action</li></ul><p>touch-action这个CSS属性。这个属性指定了相应元素上能够触发的用户代理（也就是浏览器）的默认行为。</p><p>如果将该属性值设置为touch-action: none，那么表示在该元素上的操作不会触发用户代理的任何默认行为，就无需进行300ms的延迟判断。</p><ul><li>调用一些 js 库，比如 FastClick</li></ul><h3 id="点击穿透问题"><a href="#点击穿透问题" class="headerlink" title="点击穿透问题"></a>点击穿透问题</h3><p>说完移动端点击300ms延迟的问题，还不得不提一下移动端点击穿透的问题。可能有人会想，既然click点击有300ms的延迟，那对于触摸屏，我们直接监听touchstart事件不就好了吗？</p><p>使用touchstart去代替click事件有两个不好的地方。</p><p>第一：touchstart是手指触摸屏幕就触发，有时候用户只是想滑动屏幕，却触发了touchstart事件，这不是我们想要的结果；<br>第二：使用touchstart事件在某些场景下可能会出现点击穿透的现象。</p><h3 id="什么是点击穿透？"><a href="#什么是点击穿透？" class="headerlink" title="什么是点击穿透？"></a>什么是点击穿透？</h3><p>假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。</p><p>这是因为在移动端浏览器，事件执行的顺序是touchstart &gt; touchend &gt; click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。</p><blockquote><p>浏览器事件触发的顺序 touchstart –&gt; mouseover(有的浏览器没有实现) –&gt; mousemove(一次) –&gt;mousedown –&gt; mouseup –&gt; click –&gt;touchend</p></blockquote><p>说完了,告辞…</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;本来是放在js面试题里面的,但是内容太多了,所以还是再分出来单独讲&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue高频考题</title>
    <link href="https://www.chensheng.group/2021/11/02/154-vue%E6%95%B4%E7%90%86/"/>
    <id>https://www.chensheng.group/2021/11/02/154-vue%E6%95%B4%E7%90%86/</id>
    <published>2021-11-02T12:48:00.000Z</published>
    <updated>2024-06-02T16:07:19.378Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>整理了一下常见的vue的问题</p></blockquote><span id="more"></span><p>vue的问题整理的不太多,一些基础的并没有整理出来</p><h3 id="什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h3><p>阮老师说的就很详细 <a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">戳我戳我</a></p><h3 id="Vue-的各个生命阶段是什么"><a href="#Vue-的各个生命阶段是什么" class="headerlink" title="Vue 的各个生命阶段是什么?"></a>Vue 的各个生命阶段是什么?</h3><p><a href="https://www.chensheng.group/2019/09/13/45-vue-cli%E6%80%BB%E7%BB%93/">戳我跳转搜索生命周期</a></p><h3 id="Vue-组件间的参数传递方式"><a href="#Vue-组件间的参数传递方式" class="headerlink" title="Vue 组件间的参数传递方式"></a>Vue 组件间的参数传递方式</h3><p>普通的组件传值可以去我其他的博客搜一下,这里重点说一下 多个子组件嵌套</p><p>使用 provider&#x2F;inject，在父组件中通过 provider 提供变量，在子组件中通过inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</p><h3 id="computed-和-watch-的差异"><a href="#computed-和-watch-的差异" class="headerlink" title="computed 和 watch 的差异"></a>computed 和 watch 的差异</h3><ol><li><p>computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。</p></li><li><p>computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。</p></li><li><p>从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。</p></li></ol><h3 id="v-model的实现原理以及如何自定义v-model"><a href="#v-model的实现原理以及如何自定义v-model" class="headerlink" title="v-model的实现原理以及如何自定义v-model"></a>v-model的实现原理以及如何自定义v-model</h3><p><a href="https://www.chensheng.group/2019/10/09/104-Vue%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/">戳我跳转</a></p><h3 id="vue响应式数据原理？"><a href="#vue响应式数据原理？" class="headerlink" title="vue响应式数据原理？"></a>vue响应式数据原理？</h3><p><a href="https://www.chensheng.group/2020/05/31/127-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/">戳我跳转</a></p><h3 id="什么是-Virtual-DOM？如何比较两个-DOM-树的差异？"><a href="#什么是-Virtual-DOM？如何比较两个-DOM-树的差异？" class="headerlink" title="什么是 Virtual DOM？如何比较两个 DOM 树的差异？"></a>什么是 Virtual DOM？如何比较两个 DOM 树的差异？</h3><p><a href="https://www.chensheng.group/2021/02/11/138-vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-diff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/">戳我跳转</a></p><h3 id="vue-中-key-值的作用？"><a href="#vue-中-key-值的作用？" class="headerlink" title="vue 中 key 值的作用？"></a>vue 中 key 值的作用？</h3><p>vue 中 key 值的作用可以分为两种情况来考虑。</p><p>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而<br>不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类<br>型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不<br>会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个<br>情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</p><p>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地<br>复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，<br>而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元<br>素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</p><h3 id="没有整理的题目"><a href="#没有整理的题目" class="headerlink" title="没有整理的题目"></a>没有整理的题目</h3><ul><li>Vue中如何检测数组变化</li><li>为何Vue采用异步处理</li><li>nextTick的实现原理</li><li>Vue中v-html会导致哪些问题</li><li>组件中的data为什么是一个函数</li><li>Vue中常见性能优化</li><li>keep-alive的了解</li><li>如何实现hash路由和history路由</li></ul><p>(未完待续…)</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;整理了一下常见的vue的问题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Vue" scheme="https://www.chensheng.group/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://www.chensheng.group/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>js高频考题</title>
    <link href="https://www.chensheng.group/2021/11/02/153-js%E6%95%B4%E7%90%86/"/>
    <id>https://www.chensheng.group/2021/11/02/153-js%E6%95%B4%E7%90%86/</id>
    <published>2021-11-02T12:46:00.000Z</published>
    <updated>2024-06-02T16:07:19.378Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>整理了一下常见的js的问题</p></blockquote><span id="more"></span><h2 id="1-10"><a href="#1-10" class="headerlink" title="1~10"></a>1~10</h2><h3 id="JavaScript-有几种类型的值-你能简单说一下他们的区别吗"><a href="#JavaScript-有几种类型的值-你能简单说一下他们的区别吗" class="headerlink" title="JavaScript 有几种类型的值? 你能简单说一下他们的区别吗?"></a>JavaScript 有几种类型的值? 你能简单说一下他们的区别吗?</h3><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。</p><h3 id="JavaScript-原型，原型链-有什么特点"><a href="#JavaScript-原型，原型链-有什么特点" class="headerlink" title="JavaScript 原型，原型链? 有什么特点?"></a>JavaScript 原型，原型链? 有什么特点?</h3><p><a href="https://www.chensheng.group/2016/09/20/04-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/">戳我跳转</a></p><h3 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h3><ul><li>p.<strong>proto</strong></li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h3 id="在-js-中不同进制数字的表示方式"><a href="#在-js-中不同进制数字的表示方式" class="headerlink" title="在 js 中不同进制数字的表示方式"></a>在 js 中不同进制数字的表示方式</h3><ul><li>以 0X、0x 开头的表示为十六进制。</li><li>以 0、0O、0o 开头的表示为八进制。</li><li>以 0B、0b 开头的表示为二进制格式。</li></ul><h3 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h3><p>NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><p>typeof NaN; &#x2F;&#x2F; “number”</p><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x &#x3D;&#x3D;&#x3D; x 不成立）的值。而 NaN !&#x3D; NaN 为 true。</p><h3 id="javascript-创建对象的几种方式？"><a href="#javascript-创建对象的几种方式？" class="headerlink" title="javascript 创建对象的几种方式？"></a>javascript 创建对象的几种方式？</h3><p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。</p><ul><li>工厂模式</li></ul><p>工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><ul><li>构造函数模式</li></ul><p>只要一个函数是通过 new来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。</p><blockquote><p>构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型</p></blockquote><ul><li>原型模式</li></ul><p>因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用</p><h3 id="JavaScript-继承的几种实现方式"><a href="#JavaScript-继承的几种实现方式" class="headerlink" title="JavaScript 继承的几种实现方式"></a>JavaScript 继承的几种实现方式</h3><p><a href="https://www.chensheng.group/2016/09/15/03-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/">戳我跳转</a></p><h3 id="谈谈-This-对象的理解。什么是闭包-说一下闭包。"><a href="#谈谈-This-对象的理解。什么是闭包-说一下闭包。" class="headerlink" title="谈谈 This 对象的理解。什么是闭包,说一下闭包。"></a>谈谈 This 对象的理解。什么是闭包,说一下闭包。</h3><p><a href="https://www.chensheng.group/2016/09/24/05-This%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%E4%B8%8E%E9%97%AD%E5%8C%85/">戳我跳转</a></p><h3 id="“1”-“2”-“3”-map-parseInt-答案是多少"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少?"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少?</h3><p>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (string, radix)</p><p>其中radix 表示要解析的数字的基数。(该值介于 2 ~ 36 之间)</p><blockquote><p>如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</p></blockquote><p>由于map传参默认有三个(currentValue, index, arr)</p><p>所以传入到parseInt中去之后,就变成了下面这样了,后面的0,1,2 对应的就是index索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#x27;1&#x27;, 0);</span><br><span class="line">parseInt(&#x27;2&#x27;, 1);</span><br><span class="line">parseInt(&#x27;3&#x27;, 2);</span><br></pre></td></tr></table></figure><blockquote><p>当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p></blockquote><p>所以答案是 [1, NaN, NaN]</p><h3 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h3><ol><li>使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li><li>可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li><li>如果需要判断的是某个内置的引用类型的话，可以使用Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li></ol><h2 id="11-20"><a href="#11-20" class="headerlink" title="11~20"></a>11~20</h2><h3 id="new-操作符具体干了什么呢？如何实现？"><a href="#new-操作符具体干了什么呢？如何实现？" class="headerlink" title="new 操作符具体干了什么呢？如何实现？"></a>new 操作符具体干了什么呢？如何实现？</h3><p><a href="https://www.chensheng.group/2019/10/10/106-JS%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E5%88%86%E4%BA%AB/">戳我跳转</a></p><h3 id="一行代码学习js"><a href="#一行代码学习js" class="headerlink" title="一行代码学习js"></a>一行代码学习js</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;) </span><br></pre></td></tr></table></figure><p>解释一下上面这段代码的意思</p><ol><li>选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。</li><li>循环遍历 DOM 元素</li><li>给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加outline 并不会影响元素的大小和页面的布局。</li><li>生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</li></ol><h3 id="如何创建一个-Ajax"><a href="#如何创建一个-Ajax" class="headerlink" title="如何创建一个 Ajax"></a>如何创建一个 Ajax</h3><ol><li>创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li><li>创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li><li>设置响应 HTTP 请求状态变化的函数</li><li>发送 HTTP 请求</li><li>获取异步调用返回的数据</li><li>使用 JavaScript 和 DOM 实现局部刷新</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">const SERVER_URL = &quot;/server&quot;;</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">// 创建 Http 请求 </span><br><span class="line">xhr.open(&quot;GET&quot;, SERVER_URL, true);</span><br><span class="line">// 设置状态监听函数 </span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (this.readyState !== 4) return;</span><br><span class="line">  // 当请求成功时</span><br><span class="line">  if (this.status === 200) &#123;</span><br><span class="line">    handle(this.response);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.error(this.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 设置请求失败时的监听函数 </span><br><span class="line">xhr.onerror = function() &#123;</span><br><span class="line">  console.error(this.statusText);</span><br><span class="line">&#125;;</span><br><span class="line">// 设置请求头信息 </span><br><span class="line">xhr.responseType = &quot;json&quot;;</span><br><span class="line">xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">// 发送 Http 请求 </span><br><span class="line">xhr.send(null);</span><br><span class="line">// promise 封装实现：</span><br><span class="line">function getJSON(url) &#123;</span><br><span class="line">  // 创建一个 promise 对象</span><br><span class="line">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    // 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">    // 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) return;</span><br><span class="line">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置错误监听函数</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置响应的数据类型</span><br><span class="line">    xhr.responseType = &quot;json&quot;;</span><br><span class="line">    // 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    // 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JS事件循环机制"><a href="#JS事件循环机制" class="headerlink" title="JS事件循环机制"></a>JS事件循环机制</h3><p><a href="https://www.chensheng.group/2020/07/04/133-JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">戳我跳转</a></p><h3 id="什么是浏览器的同源政策？如何解决跨域问题？"><a href="#什么是浏览器的同源政策？如何解决跨域问题？" class="headerlink" title="什么是浏览器的同源政策？如何解决跨域问题？"></a>什么是浏览器的同源政策？如何解决跨域问题？</h3><p><a href="https://www.chensheng.group/2018/01/19/49-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">戳我跳转</a></p><p><a href="https://www.chensheng.group/2018/10/10/63-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%B7%B1%E5%85%A5/">戳我跳转</a></p><h3 id="简单介绍几种模块规范"><a href="#简单介绍几种模块规范" class="headerlink" title="简单介绍几种模块规范"></a>简单介绍几种模块规范</h3><ul><li>CommonJS 方案</li></ul><p>它通过 require 来引入模块，通过 module.exports 定义模块的输出接口</p><ul><li>AMD 方案</li></ul><p>采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p><ul><li>CMD 方案</li></ul><p>这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</p><ul><li>ES6 模块化</li></ul><p>使用 import 和 export 的形式来导入导出模块。</p><h3 id="AMD-和-CMD-规范的区别？"><a href="#AMD-和-CMD-规范的区别？" class="headerlink" title="AMD 和 CMD 规范的区别？"></a>AMD 和 CMD 规范的区别？</h3><ul><li>在模块定义时对依赖的处理不同</li></ul><p>AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。<br>CMD 推崇 就近依赖，只有在用到某个模块的时候再去 require。</p><ul><li>对依赖模块的执行时机处理不同。</li></ul><p>首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机</p><p>AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致<br>CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p><h3 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><ul><li><p>创建新节点</p><ul><li>createDocumentFragment(node);</li><li>createElement(node);</li><li>createTextNode(text);</li></ul></li><li><p>添加、移除、替换、插入</p><ul><li>appendChild(node)</li><li>removeChild(node)</li><li>replaceChild(new,old)</li><li>insertBefore(new,old)</li></ul></li><li><p>查找</p><ul><li>getElementById();</li><li>getElementsByName();</li><li>getElementsByTagName();</li><li>getElementsByClassName();</li><li>querySelector();</li><li>querySelectorAll();</li></ul></li><li><p>属性操作</p><ul><li>getAttribute(key);</li><li>setAttribute(key,value);</li><li>hasAttribute(key);</li><li>removeAttribute(key);</li></ul></li></ul><h3 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title=".call() 和 .apply() 的区别？"></a>.call() 和 .apply() 的区别？</h3><p><a href="https://www.chensheng.group/2016/09/15/03-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/">戳我跳转</a></p><h3 id="的长度？"><a href="#的长度？" class="headerlink" title="[,,,] 的长度？"></a>[,,,] 的长度？</h3><p>尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</p><p>如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数量。</p><h2 id="21-30"><a href="#21-30" class="headerlink" title="21~30"></a>21~30</h2><h3 id="JavaScript-中的作用域与变量声明提升？"><a href="#JavaScript-中的作用域与变量声明提升？" class="headerlink" title=". JavaScript 中的作用域与变量声明提升？"></a>. JavaScript 中的作用域与变量声明提升？</h3><p><a href="https://www.chensheng.group/2018/12/04/69-ES6%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/">戳我跳转</a></p><h3 id="深入理解垃圾回收原理"><a href="#深入理解垃圾回收原理" class="headerlink" title="深入理解垃圾回收原理"></a>深入理解垃圾回收原理</h3><p><a href="https://www.chensheng.group/2021/08/30/142-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86/">戳我跳转</a></p><h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p><a href="https://www.chensheng.group/2019/10/10/106-JS%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E5%88%86%E4%BA%AB/">戳我跳转</a></p><h3 id="移动端为什么会有点击延迟，怎么解决"><a href="#移动端为什么会有点击延迟，怎么解决" class="headerlink" title="移动端为什么会有点击延迟，怎么解决"></a>移动端为什么会有点击延迟，怎么解决</h3><p><a href="https://www.chensheng.group/2021/11/02/155-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/">戳我跳转</a></p><h3 id="使用-JS-实现获取文件扩展名？"><a href="#使用-JS-实现获取文件扩展名？" class="headerlink" title="使用 JS 实现获取文件扩展名？"></a>使用 JS 实现获取文件扩展名？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// String.lastIndexOf() 方法返回指定值（本例中的&#x27;.&#x27;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span><br><span class="line"></span><br><span class="line">// 对于 &#x27;filename&#x27; 和 &#x27;.hiddenfile&#x27; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span><br><span class="line"></span><br><span class="line">// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</span><br><span class="line"></span><br><span class="line">function getFileExtension(filename) &#123;</span><br><span class="line">  return filename.slice(((filename.lastIndexOf(&quot;.&quot;) - 1) &gt;&gt;&gt; 0) + 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="介绍一下-js-的节流与防抖"><a href="#介绍一下-js-的节流与防抖" class="headerlink" title="介绍一下 js 的节流与防抖"></a>介绍一下 js 的节流与防抖</h3><p><a href="https://www.chensheng.group/2021/09/03/147-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">戳我跳转</a></p><h3 id="Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？"></a>Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</h3><p><a href="https://www.chensheng.group/2019/01/10/77-ES6%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/">戳我跳转</a></p><h3 id="js-的事件循环是什么？"><a href="#js-的事件循环是什么？" class="headerlink" title="js 的事件循环是什么？"></a>js 的事件循环是什么？</h3><p><a href="https://www.chensheng.group/2020/07/04/133-JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">戳我跳转</a></p><h3 id="js-中的深浅拷贝实现？"><a href="#js-中的深浅拷贝实现？" class="headerlink" title="js 中的深浅拷贝实现？"></a>js 中的深浅拷贝实现？</h3><p>浅拷贝的实现;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function shallowCopy(object) &#123;</span><br><span class="line">  // 只拷贝对象</span><br><span class="line">  if (!object || typeof object !== &quot;object&quot;) return;</span><br><span class="line">    // 根据 object 的类型判断是新建一个数组还是对象</span><br><span class="line">    let newObject = Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line">    // 遍历 object，并且判断是 object 的属性才拷贝</span><br><span class="line">    for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深拷贝的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(object) &#123;</span><br><span class="line">  if (!object || typeof object !== &quot;object&quot;) return;</span><br><span class="line">  let newObject = Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] =</span><br><span class="line">      typeof object[key] === &quot;object&quot; ? deepCopy(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h3><p><a href="https://www.chensheng.group/2021/11/01/149-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/">戳我戳我</a></p><h2 id="31-40"><a href="#31-40" class="headerlink" title="31~40"></a>31~40</h2><h3 id="为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？"></a>为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？</h3><p><a href="https://www.chensheng.group/2018/12/12/73-ES6%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/">戳我跳转</a></p><h3 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h3><p><a href="https://www.chensheng.group/2021/11/02/151-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">戳我跳转</a></p><h3 id="offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？"></a>offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？</h3><p>clientWidth&#x2F;clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。<br>clientTop 返回的是上边框的宽度。clientLeft 返回的左边框的宽度。</p><p>offsetWidth&#x2F;offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。<br>offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。</p><p>scrollWidth&#x2F;scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。<br>scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。scrollLeft 属性返回的是元素滚动条到元素左边的距离。</p><h3 id="什么是-Promise-对象"><a href="#什么是-Promise-对象" class="headerlink" title="什么是 Promise 对象?"></a>什么是 Promise 对象?</h3><p><a href="https://www.chensheng.group/2019/02/19/82-ES6%20Promise/">戳我戳我</a></p><h3 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h3><p><a href="https://www.chensheng.group/2021/11/01/150-%E6%89%8B%E5%86%99promise/">戳我戳我</a></p><h3 id="js-设计模式"><a href="#js-设计模式" class="headerlink" title="js 设计模式"></a>js 设计模式</h3><ul><li>单例模式</li></ul><p>单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。</p><ul><li>策略模式</li></ul><p>策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。</p><ul><li>代理模式</li></ul><p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</p><ul><li>中介者模式</li></ul><p>中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</p><ul><li>适配器模式</li></ul><p>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。</p><ul><li>观察者模式</li></ul><p>发布订阅模式其实属于广义上的观察者模式, 在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</p><ul><li>发布订阅模式</li></ul><p>而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦</p><p>更详细的可以看看我朋友的博客<a href="https://www.chenkl.vip/%E5%B8%B8%E8%A7%81%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">戳我跳转</a></p><h3 id="开发中常用的几种-Content-Type-？"><a href="#开发中常用的几种-Content-Type-？" class="headerlink" title="开发中常用的几种 Content-Type ？"></a>开发中常用的几种 Content-Type ？</h3><ul><li>application&#x2F;x-www-form-urlencoded</li></ul><p>浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以<br>application&#x2F;x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，<br>数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，key 和 val 都进行了 URL转码。</p><ul><li>multipart&#x2F;form-data</li></ul><p>该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p><ul><li>application&#x2F;json</li></ul><p>告诉服务器消息主体是序列化后的 JSON 字符串。</p><ul><li>text&#x2F;xml</li></ul><p>该种方式主要用来提交 XML 格式的数据。</p><h3 id="如何封装一个-javascript-的类型判断函数？"><a href="#如何封装一个-javascript-的类型判断函数？" class="headerlink" title="如何封装一个 javascript 的类型判断函数？"></a>如何封装一个 javascript 的类型判断函数？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getType(value) &#123;</span><br><span class="line">  // 判断数据是 null 的情况</span><br><span class="line">  if (value === null) &#123;</span><br><span class="line">    return value + &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断数据是引用类型的情况</span><br><span class="line">  if (typeof value === &quot;object&quot;) &#123;</span><br><span class="line">    let valueClass = Object.prototype.toString.call(value),</span><br><span class="line">      type = valueClass.split(&quot; &quot;)[1].split(&quot;&quot;);</span><br><span class="line">    type.pop();</span><br><span class="line">    return type.join(&quot;&quot;).toLowerCase();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 判断数据是基本数据类型的情况和函数的情况</span><br><span class="line">    return typeof value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(未完待续…)</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;整理了一下常见的js的问题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>uni-app使用echart</title>
    <link href="https://www.chensheng.group/2021/11/02/152-uni-app%E4%BD%BF%E7%94%A8echart/"/>
    <id>https://www.chensheng.group/2021/11/02/152-uni-app%E4%BD%BF%E7%94%A8echart/</id>
    <published>2021-11-02T12:31:00.000Z</published>
    <updated>2024-06-02T16:07:19.377Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>echart我们在web端都使用过很多次了,看看在uni-app的项目中要怎么使用echart</p></blockquote><span id="more"></span><p>uni-app推荐使用uchart,但是个人认为没有echart的功能多,所以还是想要用echart来实现</p><p>一开始的时候,我以为和web端一样,正常的引入进来就可以使用了,打开浏览器调试一下,完美,真机运行发现,一片空白</p><p>百度之后发现,运行的平台不一样,渲染层也不同,所以针对不同的运行环境,需要不同的方法</p><p>上代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;view class=&quot;trend-box&quot; style=&quot;height: 415rpx;&quot;&gt;</span><br><span class="line">      &lt;!-- #ifdef  MP-WEIXIN --&gt;</span><br><span class="line">      &lt;uniEcCanvas class=&quot;uni-ec-canvas&quot; :force-use-old-canvas=&quot;true&quot; canvas-id=&quot;multi-charts-bar&quot; :ec=&quot;dealEc&quot;&gt;&lt;/uniEcCanvas&gt;</span><br><span class="line">      &lt;!-- #endif --&gt;</span><br><span class="line">      &lt;!-- #ifdef H5||APP-PLUS --&gt;</span><br><span class="line">      &lt;h5echart style=&quot;height: 100%&quot; :option=&quot;dealEc.option&quot;&gt;&lt;/h5echart&gt;</span><br><span class="line">      &lt;!-- #endif --&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt; </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import uniEcCanvas from &#x27;@/components/uni-ec-canvas/uni-ec-canvas&#x27;</span><br><span class="line">  import h5echart from &#x27;@/components/h5-echart/echarts.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">components: &#123;</span><br><span class="line">uniEcCanvas,</span><br><span class="line">      h5echart</span><br><span class="line">&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>用法和echart一样的,需要注意的是,一个入参传入option,一个传入整个数据</p></blockquote><h3 id="ec-canvas"><a href="#ec-canvas" class="headerlink" title="ec-canvas"></a>ec-canvas</h3><p>这个组件是为了适配小程序的</p><p>首先，下载 GitHub 上的 <a href="https://github.com/ecomfe/echarts-for-weixin%5D">ecomfe&#x2F;echarts-for-weixin</a> 项目。</p><p>ec-canvas 目录下有一个 echarts.js，可以改成自己需要的。</p><h3 id="h5-echart"><a href="#h5-echart" class="headerlink" title="h5-echart"></a>h5-echart</h3><p>因为APP上没有办法操作dom,所以需要设置 script 节点的 lang 为 renderjs,在视图层操作dom</p><p>大致的用法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script module=&quot;echarts&quot; lang=&quot;renderjs&quot;&gt;</span><br><span class="line">    let myChart</span><br><span class="line">    export default &#123;</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            if (typeof window.echarts === &#x27;function&#x27;) &#123;</span><br><span class="line">                myChart = echarts.init(document.getElementById(&#x27;echarts&#x27;))</span><br><span class="line">                // 观测更新的数据在 view 层可以直接访问到</span><br><span class="line">                myChart.setOption(this.option)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 动态引入较大类库避免影响页面展示</span><br><span class="line">                const script = document.createElement(&#x27;script&#x27;)</span><br><span class="line">                // view 层的页面运行在 www 根目录，其相对路径相对于 www 计算</span><br><span class="line">                script.src = &#x27;static/echarts.js&#x27;</span><br><span class="line">                //script标签的onload事件都是在外部js文件被加载完成并执行完成后才被触发的</span><br><span class="line">                script.onload = ()=&gt;&#123;</span><br><span class="line">                    myChart = echarts.init(document.getElementById(&#x27;echarts&#x27;),)</span><br><span class="line">                    myChart.setOption(this.option)</span><br><span class="line">                &#125;</span><br><span class="line">                document.head.appendChild(script)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这两个插件上百度搜都有,没有找到的,可以去我的网盘上下载</p><p>链接: <a href="https://pan.baidu.com/s/12jNg3Qs53Gl1PcNFGyFUlA">https://pan.baidu.com/s/12jNg3Qs53Gl1PcNFGyFUlA</a> </p><p>是我对uni-app使用echart的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;echart我们在web端都使用过很多次了,看看在uni-app的项目中要怎么使用echart&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="uni-app" scheme="https://www.chensheng.group/categories/uni-app/"/>
    
    
    <category term="uni-app" scheme="https://www.chensheng.group/tags/uni-app/"/>
    
  </entry>
  
  <entry>
    <title>前端网络安全</title>
    <link href="https://www.chensheng.group/2021/11/02/151-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>https://www.chensheng.group/2021/11/02/151-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2021-11-02T11:58:00.000Z</published>
    <updated>2024-06-02T16:07:19.377Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>项目都是用的vue的框架,输入框之类的都已经帮我们做了大部分的安全处理,但是还是要了解一下</p></blockquote><span id="more"></span><p><a href="https://www.jianshu.com/p/233874b6de0d">原文链接</a></p><p>网络安全是前端工程师需要考虑的问题，大多数我们会面对以下几点</p><ul><li>什么是 XSS 攻击？如何防范 XSS 攻击？</li><li>内容安全策略csp</li><li>什么是 CSRF 攻击？如何防范 CSRF 攻击？</li><li>什么是点击劫持？如何防范点击劫持？</li><li>SQL 注入攻击？</li></ul><h3 id="1-XSS"><a href="#1-XSS" class="headerlink" title="1. XSS"></a>1. XSS</h3><p>XSS，Cross-site script，跨站脚本攻击。是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</p><p>它可以分为两类：反射型和持久型。</p><ul><li>反射型XSS攻击场景：用户点击嵌入恶意脚本的链接，攻击者可以获取用户的cookie信息或密码等重要信息，进行恶性操作。</li></ul><blockquote><p>解决：开启cookie的HttpOnly属性，禁止JavaScript脚本读取cookie信息。</p></blockquote><ul><li>持久型XSS攻击场景：攻击者提交含有恶意脚本的请求（通常使用<code>&lt;script&gt;</code>标签），此脚本被保存在数据库中。用户再次浏览页面，包含恶意脚本的页面会自动执行脚本，从而达到攻击效果。这种攻击常见于论坛，博客等应用中。</li></ul><blockquote><p>解决：前端提交请求时，转义&lt;为&amp;lt，转义&gt;为&amp;gt；或者后台存储数据时进行特殊字符转义。</p></blockquote><h3 id="2-CSRF"><a href="#2-CSRF" class="headerlink" title="2.CSRF"></a>2.CSRF</h3><p>CSRF，Cross-site request forgery，跨站请求伪造。这种方式是利用浏览器的cookie或服务器的session策略，盗取用户信息，模拟用户向第三方网站发送恶意请求。</p><blockquote><p>再次强调一下cookie的机制：浏览器向一个域名发起http请求时（GET请求）会带上浏览器保存的关于那个域名的cookies，而不管你从哪个网站发请求。</p></blockquote><p>解决方法: </p><ol><li>同源检测</li></ol><p>既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。可以通过origin header或者referer header判断请求源.</p><ol start="2"><li>CSRF token验证</li></ol><p>提交请求中携带token，并且每次请求的token值都是合法的随机数</p><ol start="3"><li>开启cookie SameSite 强校验</li></ol><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪。</p><h3 id="3-网络请求劫持"><a href="#3-网络请求劫持" class="headerlink" title="3. 网络请求劫持"></a>3. 网络请求劫持</h3><p>请求劫持是指网站资源在请求过程中因为人为原因而没有加载到正确的资源。</p><ul><li>DNS劫持</li></ul><p>在浏览器输入URL，浏览器完成连接准备之后，第一件事情就是DNS查询。如果本地没有缓存，那么需要向DNS服务商请求该域名的IP地址。这个过程中如果发生恶意劫持，都导致正确的网址不能得到正确解析，且用户可能访问了一个非法服务器获取到恶意资源。</p><blockquote><p>解决方案：DNS over HTTP（用 HTTP 协议来传输 DNS ）</p></blockquote><ul><li>HTTP劫持</li></ul><p>在用户浏览器和目标服务器之间建立的网络数据传输通道中的任何环节，比如，网关，防火墙等，发生的恶意劫持。从而在用户浏览器上展示了广告或其他内容（常见插入iframe）。最可能的劫持方就是ISP（internet service provider互联网服务商）。</p><blockquote><p>解决方案: 改为https</p></blockquote><h3 id="4-SQL注入"><a href="#4-SQL注入" class="headerlink" title="4.SQL注入"></a>4.SQL注入</h3><p>攻击者在HTTP请求中注入恶意SQL命令，例如，drop table users，服务器用请求参数构造数据库SQL命令时，恶意SQL被执行。</p><blockquote><p>解决：后台处理，例如，使用预编译语句PreparedStatement进行预处理。</p></blockquote><p>感谢大佬们的无私分享</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;项目都是用的vue的框架,输入框之类的都已经帮我们做了大部分的安全处理,但是还是要了解一下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>手写Promise</title>
    <link href="https://www.chensheng.group/2021/11/01/150-%E6%89%8B%E5%86%99promise/"/>
    <id>https://www.chensheng.group/2021/11/01/150-%E6%89%8B%E5%86%99promise/</id>
    <published>2021-11-01T13:27:00.000Z</published>
    <updated>2024-06-02T16:07:19.377Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>Promise我们都很熟悉了,也都会使用了,如果自己实现一个promise,要怎么做</p></blockquote><span id="more"></span><p>不做解释了,代码里面都有注释,直接上代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = &quot;pending&quot;;</span><br><span class="line">const RESOLVED = &quot;resolved&quot;;</span><br><span class="line">const REJECTED = &quot;rejected&quot;;</span><br><span class="line"></span><br><span class="line">function MyPromise(fn) &#123;</span><br><span class="line">  // 保存初始化状态</span><br><span class="line">  var self = this;</span><br><span class="line">  // 初始化状态</span><br><span class="line">  this.state = PENDING;</span><br><span class="line">  // 用于保存 resolve 或者 rejected 传入的值</span><br><span class="line">  this.value = null;</span><br><span class="line">  // 用于保存 resolve 的回调函数</span><br><span class="line">  this.resolvedCallbacks = [];</span><br><span class="line">  // 用于保存 reject 的回调函数</span><br><span class="line">  this.rejectedCallbacks = [];</span><br><span class="line">  // 状态转变为 resolved 方法</span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br><span class="line">    if (value instanceof MyPromise) &#123;</span><br><span class="line">      return value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 只有状态为 pending 时才能转变，</span><br><span class="line">      if (self.state === PENDING) &#123;</span><br><span class="line">        // 修改状态</span><br><span class="line">        self.state = RESOLVED;</span><br><span class="line">        // 设置传入的值</span><br><span class="line">        self.value = value;</span><br><span class="line">        // 执行回调函数</span><br><span class="line">        self.resolvedCallbacks.forEach(callback =&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  // 状态转变为 rejected 方法</span><br><span class="line">  function reject(value) &#123;</span><br><span class="line">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 只有状态为 pending 时才能转变</span><br><span class="line">      if (self.state === PENDING) &#123;</span><br><span class="line">        // 修改状态</span><br><span class="line">        self.state = REJECTED;</span><br><span class="line">        // 设置传入的值</span><br><span class="line">        self.value = value;</span><br><span class="line">        // 执行回调函数</span><br><span class="line">        self.rejectedCallbacks.forEach(callback =&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  // 将两个方法传入函数执行</span><br><span class="line">  try &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    // 遇到错误时，捕获错误，执行 reject 函数</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line">  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br><span class="line">  onResolved =</span><br><span class="line">    typeof onResolved === &quot;function&quot; ?</span><br><span class="line">    onResolved :</span><br><span class="line">    function(value) &#123;</span><br><span class="line">      return value;</span><br><span class="line">    &#125;;</span><br><span class="line">  onRejected =</span><br><span class="line">    typeof onRejected === &quot;function&quot; ?</span><br><span class="line">    onRejected :</span><br><span class="line">    function(error) &#123;</span><br><span class="line">      throw error;</span><br><span class="line">    &#125;;</span><br><span class="line">  // 如果是等待状态，则将函数加入对应列表中</span><br><span class="line">  if (this.state === PENDING) &#123;</span><br><span class="line">    this.resolvedCallbacks.push(onResolved);</span><br><span class="line">    this.rejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果状态已经凝固，则直接执行对应状态的函数</span><br><span class="line">  if (this.state === RESOLVED) &#123;</span><br><span class="line">    onResolved(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.state === REJECTED) &#123;</span><br><span class="line">    onRejected(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码忘记是从哪里copy来的,感谢大佬们的分享</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;Promise我们都很熟悉了,也都会使用了,如果自己实现一个promise,要怎么做&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="https://www.chensheng.group/2021/11/01/149-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://www.chensheng.group/2021/11/01/149-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</id>
    <published>2021-11-01T13:20:00.000Z</published>
    <updated>2024-06-02T16:07:19.377Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>一起学习一下函数柯里化,感谢百度上各位大佬们的无私奉献</p></blockquote><span id="more"></span><h3 id="什么是柯里化"><a href="#什么是柯里化" class="headerlink" title="什么是柯里化"></a>什么是柯里化</h3><p>柯里化，是函数式编程的一个重要概念。它既能减少代码冗余，也能增加可读性。另外，附带着还能用来装逼。</p><p>先给出柯里化的定义：在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><p>理论上的东西总是抽象的,直接看最简单的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 普通的add函数</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Currying后</span><br><span class="line">function curryingAdd(x) &#123;</span><br><span class="line">  return function (y) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 2)           // 3</span><br><span class="line">curryingAdd(1)(2)   // 3</span><br></pre></td></tr></table></figure><blockquote><p>实际上就是把add函数的x，y两个参数变成了先用一个函数接收x然后返回一个函数去处理y参数。现在思路应该就比较清晰了，就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p></blockquote><p>例如有一个简单的加法函数，他能够将自身的三个参数加起来并返回计算结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么add函数的柯里化函数_add则可以如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function _add(a) &#123;</span><br><span class="line">    return function(b) &#123;</span><br><span class="line">        return function(c) &#123;</span><br><span class="line">            return a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的运算方式是等价的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(1, 2, 3);</span><br><span class="line">_add(1)(2)(3);</span><br></pre></td></tr></table></figure><p>靠眼力封装的柯里化函数自由度偏低，柯里化通用式具备更加强大的能力。因此我们需要知道如何去封装这样一个柯里化的通用式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 简单实现，参数只能从右到左传递</span><br><span class="line">function curry(fn, args) &#123;</span><br><span class="line">  // 获取函数需要的参数长度</span><br><span class="line">  let length = fn.length;</span><br><span class="line">  args = args || [];</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let subArgs = args.slice(0);</span><br><span class="line">    // 拼接得到现有的所有参数</span><br><span class="line">    for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">      subArgs.push(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断参数的长度是否已经满足函数所需参数的长度</span><br><span class="line">    if (subArgs.length &gt;= length) &#123;</span><br><span class="line">    // 如果满足，执行函数</span><br><span class="line">      return fn.apply(this, subArgs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 如果不满足，递归返回科里化的函数，等待参数的传入</span><br><span class="line">      // 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span><br><span class="line">      return curry.call(this, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用es6的语法,就更简单了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null,fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是我对函数柯里化的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;一起学习一下函数柯里化,感谢百度上各位大佬们的无私奉献&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>微信开发学习</title>
    <link href="https://www.chensheng.group/2021/10/07/148-%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    <id>https://www.chensheng.group/2021/10/07/148-%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/</id>
    <published>2021-10-07T05:28:00.000Z</published>
    <updated>2024-06-02T16:07:19.377Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>简单的介绍一下微信开发的一些注意事项</p></blockquote><span id="more"></span><p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html#1">官网地址</a></p><h3 id="什么是OpenID-UnionID"><a href="#什么是OpenID-UnionID" class="headerlink" title="什么是OpenID,UnionID"></a>什么是OpenID,UnionID</h3><p>做微信开发,绕不过两个名词 OpenID,UnionID</p><ul><li>OpenID</li></ul><p>获取OpenID是我们在做微信开发必须要做的一件事情,OpenID就理解成用户的唯一标识</p><ul><li>UnionID</li></ul><p>如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下<br>绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，<br>只有一个UnionID，可以在用户管理-获取用户基本信息（UnionID机制）</p><h3 id="什么是Access-token"><a href="#什么是Access-token" class="headerlink" title="什么是Access token"></a>什么是Access token</h3><p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。</p><p>公众号和小程序均可以使用AppID和AppSecret调用本接口来获取access_token。AppID和AppSecret可在“微信公众平台-开发-基本配置”页中获得。</p><p>调用接口时，请登录“微信公众平台-开发-基本配置”提前将服务器IP地址添加到IP白名单中，点击查看设置方法，否则将无法调用成功。</p><h3 id="网页授权-公众号"><a href="#网页授权-公众号" class="headerlink" title="网页授权(公众号)"></a>网页授权(公众号)</h3><p>接下来看看如何授权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let link = window.location.href;</span><br><span class="line">let appid = &#x27;appid&#x27;;</span><br><span class="line">let uri = encodeURIComponent(link);</span><br><span class="line">let authURL = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=$&#123;appid&#125;&amp;redirect_uri=$&#123;uri&#125;&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=123#wechat_redirect`;</span><br><span class="line">window.location.href = authURL;</span><br></pre></td></tr></table></figure><p>通过代码可以看出,公众号使用跳转的方式进行网页授权,获取到用户的code,后端通过code,获取用户的openid</p><blockquote><p>关于网页授权的两种scope的区别说明</p></blockquote><ol><li><p>以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）</p></li><li><p>以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</p></li><li><p>用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p></li></ol><blockquote><p>关于特殊场景下的静默授权</p></blockquote><p>为什么我们的项目,使用的是snsapi_userinfo,也没有弹出授权?</p><ol><li><p>上面已经提到，对于以snsapi_base为scope的网页授权，就静默授权的，用户无感知；</p></li><li><p>对于已关注公众号的用户，如果用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是scope为snsapi_userinfo，也是静默授权，用户无感知。</p></li></ol><p>对于公众号授权步骤,分为四步</p><ol><li><p>引导用户进入授权页面同意授权，获取code</p></li><li><p>通过code换取网页授权access_token（与基础支持中的access_token不同）</p></li><li><p>如果需要，开发者可以刷新网页授权access_token，避免过期</p></li><li><p>通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）</p></li></ol><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>这里强调一下开发中可能会遇到的问题</p><ul><li>回调的链接问题</li></ul><ol><li><p>若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。</p></li><li><p>由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问</p></li><li><p>跳转回调redirect_uri，应当使用https链接来确保授权code的安全性。</p></li><li><p>回调的链接不支持 hash模式,需要做特殊处理</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let href = &#x27;&#x27;;</span><br><span class="line">const w = location.href.indexOf(&#x27;?&#x27;);</span><br><span class="line">const j = location.href.indexOf(&#x27;#&#x27;);</span><br><span class="line"></span><br><span class="line">// 处理微信回调url, 重新获取code</span><br><span class="line">if (w !== -1 &amp;&amp; j &gt; w) &#123;</span><br><span class="line">  href = location.href.substr(0, w) + location.href.substr(j, location.href.length) + location.search.replace(/\?/, &quot;&amp;&quot;);</span><br><span class="line">  location.href = href;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取access_token问题</li></ul><ol><li><p>通过code获取access_token,微信公众号配置IP白名单,才可以进行请求</p></li><li><p>由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起。</p></li></ol><h4 id="拉取用户信息-需scope为-snsapi-userinfo"><a href="#拉取用户信息-需scope为-snsapi-userinfo" class="headerlink" title="拉取用户信息(需scope为 snsapi_userinfo)"></a>拉取用户信息(需scope为 snsapi_userinfo)</h4><p>如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了。</p><p>到这里,公众号完成了基本的网页授权</p><h3 id="公众号使用微信JS-SDK"><a href="#公众号使用微信JS-SDK" class="headerlink" title="公众号使用微信JS-SDK"></a>公众号使用微信JS-SDK</h3><p>JSSDK使用步骤</p><h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。</p><p>备注：登录后可在“开发者中心”查看对应的接口权限。</p><h4 id="引入JS文件"><a href="#引入JS文件" class="headerlink" title="引入JS文件"></a>引入JS文件</h4><ol><li><p>在需要调用JS接口的页面引入如下JS文件，（支持https）：<a href="http://res.wx.qq.com/open/js/jweixin-1.6.0.js">http://res.wx.qq.com/open/js/jweixin-1.6.0.js</a></p></li><li><p>也可以直接导入npm包<br>首先安装 weixin-js-sdk, 之后引入进来 import wx from ‘weixin-js-sdk’</p></li><li><p>也可以使用微信浏览器自带的方法(WeixinJSBridge)</p></li></ol><h4 id="通过config接口注入权限验证配置"><a href="#通过config接口注入权限验证配置" class="headerlink" title="通过config接口注入权限验证配置"></a>通过config接口注入权限验证配置</h4><p>所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">  debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">  appId: &#x27;&#x27;, // 必填，公众号的唯一标识</span><br><span class="line">  timestamp: , // 必填，生成签名的时间戳</span><br><span class="line">  nonceStr: &#x27;&#x27;, // 必填，生成签名的随机串</span><br><span class="line">  signature: &#x27;&#x27;,// 必填，签名</span><br><span class="line">  jsApiList: [] // 必填，需要使用的JS接口列表</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="通过ready接口处理成功验证"><a href="#通过ready接口处理成功验证" class="headerlink" title="通过ready接口处理成功验证"></a>通过ready接口处理成功验证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.ready(function()&#123;</span><br><span class="line">  // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="通过error接口处理失败验证"><a href="#通过error接口处理失败验证" class="headerlink" title="通过error接口处理失败验证"></a>通过error接口处理失败验证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.error(function(res)&#123;</span><br><span class="line">  // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>到这里,微信公众号的JS-SDK就可以正常使用了,分享功能,音频接口,指纹识别,微信支付等可以在其他的博客看到使用的详细方法,更多的可以看看官方文档</p><h3 id="小程序授权-微信小程序"><a href="#小程序授权-微信小程序" class="headerlink" title="小程序授权(微信小程序)"></a>小程序授权(微信小程序)</h3><p>在说到小程序之前,先说一下它和公众号的区别</p><p>网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作.</p><p>而小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。</p><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><p>各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的：</p><p>在 iOS、iPadOS 和 Mac OS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，环境有 iOS 14、iPad OS 14、Mac OS 11.4 等；<br>在 Android 上，小程序逻辑层的 javascript 代码运行在 V8 中，视图层是由基于 Mobile Chrome 内核的自研 XWeb 引擎来渲染的；<br>在 Windows 上，小程序逻辑层 javascript 和视图层 javascript 都是用 Chrome 内核；<br>在 开发工具上，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium Webview 来渲染的。</p><table><thead><tr><th>运行环境</th><th>逻辑层</th><th>渲染层</th></tr></thead><tbody><tr><td>iOS</td><td>JavaScriptCore</td><td>WKWebView</td></tr><tr><td>安卓</td><td>V8</td><td>chromium定制内核</td></tr><tr><td>小程序开发者工具</td><td>NWJS</td><td>Chrome WebView</td></tr></tbody></table><p>由于视图渲染的方式不一致,还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现</p><p>除了样式的差异,在js上也有一定的区别</p><h5 id="Promise-时序差异"><a href="#Promise-时序差异" class="headerlink" title="Promise 时序差异"></a>Promise 时序差异</h5><p>由于实现原因与 iOS JavaScriptCore 限制，iOS 环境下的 Promise 是一个使用 setTimeout 模拟的 Polyfill。这意味着 Promise 触发的任务为普通任务，而非微任务，进而导致 在 iOS 下的 Promise 时序会和标准存在差异。</p><blockquote><p>具体的宏任务和微任务的差别,这里不细讲了,博客的其他文章中有</p></blockquote><h4 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h4><p>回归正传,看看小程序的授权流程,上图</p><p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg" alt="登录流程时序"></p><p>微信小程序的登录比较简单,简单来说只有几步</p><ol><li>调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。</li><li>调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 、用户在微信开放平台帐号下的唯一标识UnionID 和 会话密钥 session_key。</li></ol><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>部分接口需要经过用户授权同意才能调用。我们把这些接口按使用范围分成多个scope，用户选择对scope来进行授权，当授权给一个 scope 之后，其对应的所有接口都可以直接使用。</p><table><thead><tr><th>scope</th><th>对应接口</th><th>描述</th></tr></thead><tbody><tr><td>scope.userInfo</td><td>wx.getUserInfo</td><td>用户信息</td></tr><tr><td>scope.userLocation</td><td>wx.getLocation, wx.chooseLocation</td><td>地理位置</td></tr><tr><td>scope.userLocationBackground</td><td>wx.startLocationUpdateBackground</td><td>后台定位</td></tr><tr><td>scope.werun</td><td>wx.getWeRunData</td><td>微信运动步数</td></tr><tr><td>scope.record</td><td>wx.startRecord</td><td>录音功能</td></tr><tr><td>scope.writePhotosAlbum</td><td>wx.saveImageToPhotosAlbum, wx.saveVideoToPhotosAlbum</td><td>保存到相册</td></tr><tr><td>scope.camera</td><td>camera 组件</td><td>保存到相册</td></tr></tbody></table><p>此类接口调用时：</p><ul><li>如果用户未接受，会弹窗询问用户，用户点击同意后方可调用接口；</li><li>如果用户已授权，可以直接调用接口；</li><li>如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口 fail 回调。请开发者兼容用户拒绝授权的场景。</li></ul><p>开发者可以使用 wx.getSetting 获取用户当前的授权状态。然后判断用户是否拒绝授权,弹窗二次提醒用户是否授权,开发者可以调用 wx.openSetting 打开设置界面，引导用户开启授权。</p><p><a href="https://developers.weixin.qq.com/community/develop/doc/000cea2305cc5047af5733de751008">openSetting接口调整</a><br><a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserProfile.html#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">getUserInfo接口调整</a><br><a href="https://developers.weixin.qq.com/community/develop/doc/000aee91a98d206bc6dbe722b51801">getLocation接口调整</a></p><blockquote><p>需要注意的是, getUserProfile获取用户昵称头像等,需要用户手动触发,每次调用都会弹窗</p></blockquote><h4 id="获取手机号"><a href="#获取手机号" class="headerlink" title="获取手机号"></a>获取手机号</h4><p>因为需要用户主动触发才能发起获取手机号接口，所以该功能不由 API 来调用，需用 button 组件的点击来触发。</p><p>需要将 button 组件 open-type 的值设置为 getPhoneNumber，当用户点击并同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据， 然后在第三方服务端结合 session_key 以及 app_id 进行解密获取手机号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;button open-type=&quot;getPhoneNumber&quot; bindgetphonenumber=&quot;getPhoneNumber&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">getPhoneNumber (e) &#123;</span><br><span class="line">  console.log(e.detail.errMsg)</span><br><span class="line">  console.log(e.detail.iv)</span><br><span class="line">  console.log(e.detail.encryptedData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取到的加密数据给到后端,获取手机号</span><br></pre></td></tr></table></figure><blockquote><p>在回调中调用 wx.login 登录，可能会刷新登录态。此时服务器使用 code 换取的 sessionKey 不是加密时使用的 sessionKey，导致解密失败。建议开发者提前进行 login；或者在回调中先使用 checkSession 进行登录态检查，避免 login 刷新登录态。</p></blockquote><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><p>上传图片,下载,地图等功能,需要服务器配置安全域名</p><blockquote><p>地图有的时候需要用到<code>https://apis.map.qq.com</code>,也要配置域名</p></blockquote><p>如果项目中有用到web-view组件,H5的链接需要配置业务域名,配置时校验文件需要放在域名的根目录</p><h4 id="服务器域名配置"><a href="#服务器域名配置" class="headerlink" title="服务器域名配置"></a>服务器域名配置</h4><p>服务器域名请在 「小程序后台-开发-开发设置-服务器域名」 中进行配置，配置时需要注意：</p><ul><li>域名只支持 https (wx.request、wx.uploadFile、wx.downloadFile) 和 wss (wx.connectSocket) 协议；</li><li>域名不能使用 IP 地址（小程序的局域网 IP 除外）或 localhost；</li><li>域名必须经过 ICP 备案；</li><li>出于安全考虑，api.weixin.qq.com 不能被配置为服务器域名，相关API也不能在小程序内调用。 开发者应将 AppSecret 保存到后台服务器中，通过服务器使用 getAccessToken 接口获取 access_token，并调用相关 API；</li><li>不支持配置父域名，使用子域名。</li></ul><h4 id="HTTPS-证书"><a href="#HTTPS-证书" class="headerlink" title="HTTPS 证书"></a>HTTPS 证书</h4><p>小程序必须使用 HTTPS&#x2F;WSS 发起网络请求。请求时系统会对服务器域名使用的 HTTPS 证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议开发者按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。</p><p>对证书要求如下：</p><ul><li>HTTPS 证书必须有效；<ul><li>证书必须被系统信任，即根证书被已系统内置</li><li>部署 SSL 证书的网站域名必须与证书颁发的域名一致</li><li>证书必须在有效期内</li><li>证书的信任链必需完整（需要服务器配置）</li></ul></li><li>iOS 不支持自签名证书;</li><li>iOS 下证书必须满足苹果 App Transport Security (ATS) 的要求;</li><li>TLS 必须支持 1.2 及以上版本。部分旧 Android 机型还未支持 TLS 1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;</li><li>部分 CA 可能不被操作系统信任，请开发者在选择证书时注意小程序和各系统的相关通告。<ul><li>Chrome 56&#x2F;57 内核对 WoSign、StartCom 证书限制周知</li></ul></li></ul><p>(…未完待续)</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;简单的介绍一下微信开发的一些注意事项&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="https://www.chensheng.group/2021/09/03/147-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://www.chensheng.group/2021/09/03/147-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2021-09-03T06:53:00.000Z</published>
    <updated>2024-06-02T16:07:19.377Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>节流与防抖就像重绘和回流一样重要,都是为了提高性能,一直以为博客里面已经写了,结果发现没有,现在补一下</p></blockquote><span id="more"></span><h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h3><p>函数防抖：在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</p><p>分解一下需求：</p><ul><li>持续触发不执行</li><li>不触发的一段时间之后再执行</li></ul><p>我们什么场景下会用到呢</p><p>举个例子,我们想要让搜索的输入框输入后,开始查询,调用后端的接口,但是直接监听input的change事件,每按一下键盘,就去调用接口了,但是这个时候,用户其实并没有输入完他的关键字,这个时候,就需要用到函数防抖了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 函数防抖的实现</span><br><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">  var timer = null;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context = this,</span><br><span class="line">    args = arguments;</span><br><span class="line">    // 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置定时器，使事件间隔指定事件后执行</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h3><p>函数节流：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</p><p>分解一下需求：</p><ul><li>持续触发并不会执行多次</li><li>到一定时间再去执行</li></ul><p>假设,刚刚的那个需求变了,产品发现有一些用户疯狂的敲键盘输入,但是我们的搜索列表就是为空,所以希望每隔一定的时候就要去调用接口,所以当我们监听input的change事件的时候,需要使用到函数节流了,持续触发不会执行,但是到了一定的时间就会开始执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 函数节流的实现;</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  var preTime = Date.now();</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context = this,</span><br><span class="line">    args = arguments,</span><br><span class="line">    nowTime = Date.now();</span><br><span class="line">    // 如果两次时间间隔超过了指定时间，则执行函数。</span><br><span class="line">    if (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = Date.now();</span><br><span class="line">      return fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p></blockquote><blockquote><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p></blockquote><p>以上就是我对防抖和节流的一些理解,如果文章由于我学识浅薄,导致您发现有严重谬误的地方,请一定在评论中指出,我会在第一时间修正我的博文,以避免误人子弟。</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;节流与防抖就像重绘和回流一样重要,都是为了提高性能,一直以为博客里面已经写了,结果发现没有,现在补一下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/categories/javaScript/"/>
    
    
    <category term="javaScript" scheme="https://www.chensheng.group/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>css高频考题</title>
    <link href="https://www.chensheng.group/2021/09/01/146-css%E6%95%B4%E7%90%86/"/>
    <id>https://www.chensheng.group/2021/09/01/146-css%E6%95%B4%E7%90%86/</id>
    <published>2021-09-01T06:42:00.000Z</published>
    <updated>2024-06-02T16:07:19.377Z</updated>
    
    <content type="html"><![CDATA[<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' /><blockquote><p>整理了一下常见的css的问题</p></blockquote><span id="more"></span><h3 id="介绍一下标准的-CSS-的盒子模型"><a href="#介绍一下标准的-CSS-的盒子模型" class="headerlink" title="介绍一下标准的 CSS 的盒子模型"></a>介绍一下标准的 CSS 的盒子模型</h3><ul><li>有两种盒子模型：IE 盒模型（border-box）、W3C 标准盒模型（content-box）</li><li>盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分</li></ul><p>IE 盒模型和 W3C 标准盒模型的区别：</p><ul><li>W3C 标准盒模型：属性 width，height 只包含内容 content，不包含 border 和 padding</li><li>IE 盒模型：属性 width，height 包含 content、border 和 padding，指的是 content + padding + border。</li></ul><blockquote><p>如果将 box-sizing 设为 border-box 则用的是 IE 盒模型。</p></blockquote><h3 id="CSS-选择符有哪些"><a href="#CSS-选择符有哪些" class="headerlink" title="CSS 选择符有哪些?"></a>CSS 选择符有哪些?</h3><ol><li>id 选择器（#myid）</li><li>类选择器（.myclassname）</li><li>标签选择器（div,h1,p）</li><li>后代选择器（h1 p）</li><li>相邻后代选择器（子）选择器（ul&gt;li）</li><li>兄弟选择器（li~a）</li><li>相邻兄弟选择器（li+a）</li><li>属性选择器（a[rel&#x3D;”external”]）</li><li>伪类选择器（a:hover,li:nth-child）</li><li>伪元素选择器（::before、::after）</li><li>通配符选择器（*）</li></ol><h3 id="CSS-中哪些属性可以继承"><a href="#CSS-中哪些属性可以继承" class="headerlink" title="CSS 中哪些属性可以继承"></a>CSS 中哪些属性可以继承</h3><ul><li><p>字体系列属性<br>font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</p></li><li><p>文本系列属性<br>text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color</p></li><li><p>表格布局属性<br>caption-sideborder-collapseempty-cells</p></li><li><p>列表属性<br>list-style-type、list-style-image、list-style-position、list-style</p></li><li><p>光标属性<br>cursor</p></li><li><p>元素可见性<br>visibility</p></li></ul><h3 id="CSS3-新增伪类有那些"><a href="#CSS3-新增伪类有那些" class="headerlink" title="CSS3 新增伪类有那些?"></a>CSS3 新增伪类有那些?</h3><ul><li>elem:nth-child(n)选中父元素下的第 n 个子元素，并且这个子元素的标签名为 elem，n可以接受具体的数值，也可以接受函数。</li><li>elem:nth-last-child(n)作用同上，不过是从后开始查找。</li><li>elem:last-child 选中最后一个子元素。</li><li>elem:only-child 如果 elem 是父元素下唯一的子元素，则选中之。</li><li>elem:nth-of-type(n)选中父元素下第 n 个 elem 类型元素，n 可以接受具体的数值，也可以接受函数。</li><li>elem:first-of-type 选中父元素下第一个 elem 类型元素。</li><li>elem:last-of-type 选中父元素下最后一个 elem 类型元素。</li><li>elem:only-of-type 如果父元素下的子元素只有一个 elem 类型元素，则选中该元素。</li><li>elem:empty 选中不包含子元素和内容的 elem 类型元素。</li><li>elem:target 选择当前活动的 elem 元素。</li><li>:not(elem)选择非 elem 元素的每个元素。</li><li>:enabled 控制表单控件的禁用状态。</li><li>:disabled 控制表单控件的禁用状态。</li><li>:checked 单选框或复选框被选中。</li></ul><h3 id="CSS3-有哪些新特性？"><a href="#CSS3-有哪些新特性？" class="headerlink" title="CSS3 有哪些新特性？"></a>CSS3 有哪些新特性？</h3><ul><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadow\Reflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>过渡 （transform）缩放，定位，倾斜，动画，多背景</li></ul><h3 id="解释一下-CSS3-的-Flexbox（弹性盒布局模型）"><a href="#解释一下-CSS3-的-Flexbox（弹性盒布局模型）" class="headerlink" title="解释一下 CSS3 的 Flexbox（弹性盒布局模型）"></a>解释一下 CSS3 的 Flexbox（弹性盒布局模型）</h3><p><a href="https://www.chensheng.group/2018/08/08/62-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E6%B7%B1%E5%85%A5/">弹性布局深入</a></p><h3 id="width-auto-和-width-100-的区别"><a href="#width-auto-和-width-100-的区别" class="headerlink" title="width:auto 和 width:100%的区别"></a>width:auto 和 width:100%的区别</h3><ul><li><p>width:100%会使元素 box 的宽度等于父元素的 contentbox 的宽度。</p></li><li><p>width:auto 会使元素撑满整个父元素，margin、border、padding、content 区域会自动分配水平空间。</p></li></ul><h3 id="BFC规范的理解-css中常见的兼容性问题-margin-重叠问题的理解-怎么让-Chrome-支持小于-12px-的文字"><a href="#BFC规范的理解-css中常见的兼容性问题-margin-重叠问题的理解-怎么让-Chrome-支持小于-12px-的文字" class="headerlink" title="BFC规范的理解?css中常见的兼容性问题?margin 重叠问题的理解?怎么让 Chrome 支持小于 12px 的文字?"></a>BFC规范的理解?css中常见的兼容性问题?margin 重叠问题的理解?怎么让 Chrome 支持小于 12px 的文字?</h3><p><a href="https://www.chensheng.group/2018/02/24/55-%E5%85%B3%E4%BA%8ECSS%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/">那些你不知道的CSS</a></p><h3 id="CSS-优化、提高性能的方法有哪些"><a href="#CSS-优化、提高性能的方法有哪些" class="headerlink" title="CSS 优化、提高性能的方法有哪些?"></a>CSS 优化、提高性能的方法有哪些?</h3><p>加载性能：</p><ol><li>css 压缩：将写好的 css 进行打包压缩，可以减少很多的体积。</li><li>css 单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bottom;margin-left:left;执行的效率更高。</li><li>减少使用@import,而建议使用 link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ol><p>选择器性能：</p><ol><li>关键选择器（keyselector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS 选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</li><li>如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</li><li>避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。</li><li>尽量少的去对标签进行选择，而是用 class。</li><li>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</li></ol><p>渲染性能：</p><ol><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少 css 文档体积。</li><li>属性值为 0 时，不加单位。</li><li>属性值为浮动小数 0.**，可以省略小数点之前的 0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import 前缀，它会影响 css 的加载速度。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>css 雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li><li>正确使用 display 的属性，由于 display 的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li><li>不滥用 web 字体。对于中文网站来说 WebFonts 可能很陌生，国外却很流行。webfonts通常体积庞大，而且一些浏览器在下载 webfonts 时会阻塞页面渲染损伤性能。</li></ol><p>可维护性、健壮性：</p><ol><li>将具有相同属性的样式抽离出来，整合并通过 class 在页面中进行使用，提高 css 的可维护性。</li><li>样式与内容分离：将 css 代码定义到外部 css 中。</li></ol><blockquote><p>上面的选择器性能的第一条,为什么CSS 选择符是从右到左进行匹配的 试想一下，如果采用从左至右的方式读取 CSS 规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配</p></blockquote><h3 id="在网页中应该使用奇数还是偶数的字体？为什么呢？"><a href="#在网页中应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="在网页中应该使用奇数还是偶数的字体？为什么呢？"></a>在网页中应该使用奇数还是偶数的字体？为什么呢？</h3><ol><li>偶数字号相对更容易和 web 设计的其他部分构成比例关系。比如：当我用了 14px 的正文字号，我可能会在一些地方用 14×0.5&#x3D;7px 的 margin，在另一些地方用 14×1.5&#x3D;21px 的标题字号。</li><li>浏览器缘故，低版本的浏览器 ie6 会把奇数字体强制转化为偶数，即 13px 渲染为 14px。</li><li>系统差别，早期的 Windows 里，中易宋体点阵只有 12 和 14、15、16px，唯独缺少 13px。</li></ol><h3 id="如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>如何修改 chrome 记住密码后自动填充表单的黄色背景？</h3><p>chrome 表单自动填充后，input 文本框的背景会变成黄色的，通过审查元素可以看到这是由于 chrome 会默认给自动填充的 input 表单加上 input:-webkit-autofill 私有属性，然后对其赋予以下样式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  background-color:rgb(250,255,189)!important;</span><br><span class="line">  background-image:none!important;</span><br><span class="line">  color:rgb(0,0,0)!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 chrome 默认定义的 background-color，background-image，color 使用 important 是不能提高其优先级的，但是其他属性可使用</p><p>使用足够大的纯色内阴影来覆盖 input 输入框的黄色背景，处理如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill&#123;</span><br><span class="line">  -webkit-box-shadow: 000px 1000px white inset;</span><br><span class="line">  border: 1px solid #CCC !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="让页面里的字体变清晰，变细用 CSS 怎么做？"></a>让页面里的字体变清晰，变细用 CSS 怎么做？</h3><p>webkit 内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。</p><p>在 MacOS 测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设</p><h3 id="使用-rem-布局的优缺点"><a href="#使用-rem-布局的优缺点" class="headerlink" title="使用 rem 布局的优缺点"></a>使用 rem 布局的优缺点</h3><p>优点：<br>在屏幕分辨率千差万别的时代，只要将 rem 与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持 rem 了，兼容性也非常的好。</p><p>缺点：</p><ol><li>在奇葩的 dpr 设备上表现效果不太好，比如一些华为的高端机型用 rem 布局会出现错乱。</li><li>使用 iframe 引用也会出现问题。</li><li>rem 在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。</li></ol><p>(…未完待续)</p>]]></content>
    
    
    <summary type="html">&lt;hr style=&#39;filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)&#39; color=&#39;#FF0000&#39; size=&#39;1&#39; /&gt;

&lt;blockquote&gt;
&lt;p&gt;整理了一下常见的css的问题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.chensheng.group/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.chensheng.group/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
