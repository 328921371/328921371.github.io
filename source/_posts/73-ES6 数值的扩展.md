---
title: ECMAScript 6 数值的扩展
categories:
  - ECMAScript 6
tags:
  - ECMAScript 6
copyright: true
comments: true
abbrlink: 863214f9
date: 2018-12-12 17:19:24
---

<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

> ES6将数值的许多操作都封装了起来,相比较ES5,规范了许多,提供了更为简洁的最大安全值

<!--more-->

文章主要参考阮一峰老师的 ECMAScript 6入门,站在巨人的肩膀上看世界...

## 二进制与八进制

这个其实不算是ES6的语法,只是ES6规范了写法,顺便提一下

> 二进制声明：二进制的英文单词是Binary,二进制的开始是0（零），然后第二个位置是b（注意这里大小写都可以实现），然后跟上二进制的值就可以了。

> 八进制声明：八进制的英文单词是Octal，也是以0（零）开始的，然后第二个位置是O（欧），然后跟上八进制的值就可以了。

```
  //二进制声明Binary
  let binary = 0B010101
  console.log(binary)

  // 八进制声明Octal
  let octal = 0O777
  console.log(octal)
```

## 判断数值

> 使用Number.isFinite()来进行数字验证，只要是数字，不论是浮点型还是整形都会返回true，其他时候会返回false。

阮一峰老师是这样解释的: Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。
需要注意,这里的无限指的不是无限循环的小数

```
  // 如果参数类型不是数值，Number.isFinite一律返回false。
  Number.isFinite(10/3) // true
  Number.isFinite(NaN); // false
  Number.isFinite(Infinity); // false
  Number.isFinite(-Infinity); // false
  Number.isFinite('foo'); // false
  Number.isFinite('15'); // false
  Number.isFinite(true); // false
```

> Number.isNaN()用来检查一个值是否为NaN。

```
  // 如果参数类型不是NaN，Number.isNaN一律返回false。
  Number.isNaN(NaN) // true
  Number.isNaN(15) // false
  Number.isNaN('15') // false
  Number.isNaN(true) // false
  Number.isNaN(9/NaN) // true
  Number.isNaN('true' / 0) // true
  Number.isNaN('true' / 'true') // true
```

> 注意!!! isFinite() 和 Number.isFinite() 是不一样的,前者是先将非数值的转为数值,再进行判断

```
  isFinite(25) // true
  isFinite("25") // true
  Number.isFinite(25) // true
  Number.isFinite("25") // false
```

> Number.isInteger()用来判断一个数值是否为整数。

```
  Number.isInteger(25) // true
  Number.isInteger(25.1) // false
```

## 类型转化

和ES5的区别不大,只是移植到Number对象上面,逐步减少全局性方法，使得语言逐步模块化。

```
  // ES6的写法
  Number.parseInt('12.34') // 12
  Number.parseFloat('123.45#') // 123.45
```

## 最小进度

Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。

这也是javaScript上经典的 0.1 + 0.2 === 0.3 //false 的原因了

写个代码解释一下..
```
0.1 + 0.2
// 0.30000000000000004

0.1 + 0.2 - 0.3
// 5.551115123125783e-17

5.551115123125783e-17.toFixed(20)
// '0.00000000000000005551'
```

> Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。

```
  function withinErrorMargin (left, right) {
    return Math.abs(left - right) < Number.EPSILON * Math.pow(2, 2);
  }

  0.1 + 0.2 === 0.3 // false
  withinErrorMargin(0.1 + 0.2, 0.3) // true

  1.1 + 1.3 === 2.4 // false
  withinErrorMargin(1.1 + 1.3, 2.4) // true
```

## 安全整数

整数的操作是有一个取值范围的，它的取值范围就是2的53次方。,ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。

` Math.pow(2, 53) // 9007199254740992 `

> Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。

```
  Number.isSafeInteger(9007199254740990) // true
  Number.isSafeInteger(9007199254740992) // false
```

## 取整

> Math.trunc方法用于去除一个数的小数部分，返回整数部分。

这不是四舍五入 !!!

```
  Math.trunc(4.1) // 4
  Math.trunc(4.9) // 4
  Math.trunc(-4.1) // -4
  Math.trunc(-4.9) // -4
  Math.trunc(-0.1234) // -0
```

对于非数值，Math.trunc内部使用Number方法将其先转为数值。

```
  Math.trunc('123.456') // 123
  Math.trunc(true) //1
  Math.trunc(false) // 0
  Math.trunc(null) // 0
```

对于空值和无法截取整数的值，返回NaN。

```
  Math.trunc(NaN);      // NaN
  Math.trunc('foo');    // NaN
  Math.trunc();         // NaN
  Math.trunc(undefined) // NaN
```

## 判断正负

> Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。

```
  Math.sign(-5) // -1
  Math.sign(5) // +1
  Math.sign(0) // +0
  Math.sign(-0) // -0
  Math.sign(NaN) // NaN
  Math.sign('')  // 0
  Math.sign(true)  // +1
  Math.sign(false)  // 0
  Math.sign(null)  // 0
  Math.sign('9')  // +1
  Math.sign('foo')  // NaN
  Math.sign()  // NaN
  Math.sign(undefined)  // NaN
```

## 指数运算符

> ES2016 新增了一个指数运算符（**）

```
  2 ** 2 // 4
  2 ** 3 // 8
```

这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。

```
  // 相当于 2 * * (3 * * 2)
  2 * * 3 * * 2
  // 512
```

> 注意，V8 引擎的指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。

以上就是我对ECMAScript 6数值扩展的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。