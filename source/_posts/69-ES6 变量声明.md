---
title: ECMAScript 6 变量声明
categories:
  - ECMAScript 6
tags:
  - ECMAScript 6
copyright: true
comments: true
abbrlink: '44896981'
date: 2018-12-04 14:24:11
---

<hr style='filter:progid:DXImageTransform.Microsoft.Glow(color=#FF0000,strength=10)' color='#FF0000' size='1' />

> 很早就想记录一下学习ES6的过程,因为一些事情一直拖到了现在,现在总结一下ES6,准备拥抱ES7,一个一个知识点来吧

<!--more-->

首先先介绍一下ECMAScript和JavaScript到底是什么关系

简单的来说ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。日常场合，这两个词是可以互换的。

对于ES6的支持度和转码,我这里就不再多说了,总结一下ES6常用到的语法知识


> ES6新增了let和const命令

## let 命令

先说一下let,之前我们都是使用var来声明变量,但是当项目庞大的时候,对象容易混乱,let很好的解决了这个问题:

* 不存在变量提升
* 块级作用域
* 不允许重复声明

我们一点一点来看

### 不存在变量提升

举个例子,在ES5的时候

```
  console.log(cs); // 输出undefined
  var cs = 2;
```

运行时,var会将变量提升,使的代码变成这样
```
  var cs
  console.log(cs);
  cs = 2;
```

所以变量输出undefined

但是let就杜绝了这种情况发生

```
  console.log(cs); // 报错ReferenceError
  let bar = 2;
  let cs = 2;
```


### 块级作用域

按照阮一峰老师的话来说,叫作暂时性死区,同样举个例子

```
  var cs = 123;

  if (true) {
    cs = 'abc'; // ReferenceError
    let cs;
  }
```

> ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

再说一个块级作用域的作用,下面的这个循环,var和let的输出就不一样

```
  for(let i = 0;i < 10;i++){
    setTimeout(()=>{
      console.log(i)
    },0)
  }
```

### 不允许重复声明

> let不允许在相同作用域内，重复声明同一个变量。

```
  / 报错
  function func() {
    let a = 10;
    var a = 1;
  }

  // 报错
  function func() {
    let a = 10;
    let a = 1;
  }
```

## const 命令

> 这个就很好理解了,const声明一个只读的常量。一旦声明，常量的值就不能改变。

```
  const PI = 3.1415;
  PI // 3.1415

  PI = 3; //报错
```

>const声明的常量，也与let一样不可重复声明。


以上就是我对ECMAScript 6声明变量的一些理解，如果文章由于我学识浅薄，导致您发现有严重谬误的地方，请一定在评论中指出，我会在第一时间修正我的博文，以避免误人子弟。